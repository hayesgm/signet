defmodule Signet.Contract.IConsole do
  @moduledoc ~S"""
  This module was auto-generated by Signet. Any changes may be lost.

  See `mix help signet.gen` for more information.
  """
  use Signet.Hex

  def contract_name do
    "IConsole"
  end

  def log_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :address},
        %{name: "p2", type: :string}
      ]
    }
  end

  def encode_log(p0, p1, p2) do
    ABI.encode(log_selector(), [p0, p1, p2])
  end

  def prepare_log(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log(p0, p1, p2), opts)
  end

  def build_trx_log(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log(p0, p1, p2)}
  end

  def call_log(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log(contract, p0, p1, p2), opts)
  end

  def execute_log(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log(p0, p1, p2), opts)
  end

  def decode_log_call(<<0, 113, 80, 190>> <> calldata) do
    _signature = hex!("0x007150be")
    ABI.decode(log_selector(), calldata)
  end

  def exec_vm_log(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log(p0, p1, p2), exec_opts)
  end

  def log_00dd87b9_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_00dd87b9(p0, p1, p2, p3) do
    ABI.encode(log_00dd87b9_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_00dd87b9(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_00dd87b9(p0, p1, p2, p3), opts)
  end

  def build_trx_log_00dd87b9(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_00dd87b9(p0, p1, p2, p3)}
  end

  def call_log_00dd87b9(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_00dd87b9(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_00dd87b9(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_00dd87b9(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_00dd87b9(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_00dd87b9(p0, p1, p2, p3), opts)
  end

  def decode_log_00dd87b9_call(<<0, 221, 135, 185>> <> calldata) do
    _signature = hex!("0x00dd87b9")
    ABI.decode(log_00dd87b9_selector(), calldata)
  end

  def exec_vm_log_00dd87b9(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_00dd87b9(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_00dd87b9_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_00dd87b9_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_00dd87b9(p0, p1, p2, p3), exec_opts)
  end

  def log_018c84c2_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :address},
        %{name: "p2", type: :address}
      ]
    }
  end

  def encode_log_018c84c2(p0, p1, p2) do
    ABI.encode(log_018c84c2_selector(), [p0, p1, p2])
  end

  def prepare_log_018c84c2(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_018c84c2(p0, p1, p2), opts)
  end

  def build_trx_log_018c84c2(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_018c84c2(p0, p1, p2)}
  end

  def call_log_018c84c2(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_018c84c2(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_018c84c2(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_018c84c2(contract, p0, p1, p2), opts)
  end

  def execute_log_018c84c2(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_018c84c2(p0, p1, p2), opts)
  end

  def decode_log_018c84c2_call(<<1, 140, 132, 194>> <> calldata) do
    _signature = hex!("0x018c84c2")
    ABI.decode(log_018c84c2_selector(), calldata)
  end

  def exec_vm_log_018c84c2(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_018c84c2(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_018c84c2_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_018c84c2_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_018c84c2(p0, p1, p2), exec_opts)
  end

  def log_031c6f73_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :address},
        %{name: "p2", type: :address},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_031c6f73(p0, p1, p2, p3) do
    ABI.encode(log_031c6f73_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_031c6f73(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_031c6f73(p0, p1, p2, p3), opts)
  end

  def build_trx_log_031c6f73(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_031c6f73(p0, p1, p2, p3)}
  end

  def call_log_031c6f73(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_031c6f73(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_031c6f73(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_031c6f73(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_031c6f73(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_031c6f73(p0, p1, p2, p3), opts)
  end

  def decode_log_031c6f73_call(<<3, 28, 111, 115>> <> calldata) do
    _signature = hex!("0x031c6f73")
    ABI.decode(log_031c6f73_selector(), calldata)
  end

  def exec_vm_log_031c6f73(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_031c6f73(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_031c6f73_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_031c6f73_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_031c6f73(p0, p1, p2, p3), exec_opts)
  end

  def log_0454c079_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :address},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_0454c079(p0, p1, p2, p3) do
    ABI.encode(log_0454c079_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_0454c079(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_0454c079(p0, p1, p2, p3), opts)
  end

  def build_trx_log_0454c079(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_0454c079(p0, p1, p2, p3)}
  end

  def call_log_0454c079(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_0454c079(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_0454c079(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_0454c079(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_0454c079(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_0454c079(p0, p1, p2, p3), opts)
  end

  def decode_log_0454c079_call(<<4, 84, 192, 121>> <> calldata) do
    _signature = hex!("0x0454c079")
    ABI.decode(log_0454c079_selector(), calldata)
  end

  def exec_vm_log_0454c079(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_0454c079(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_0454c079_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_0454c079_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_0454c079(p0, p1, p2, p3), exec_opts)
  end

  def log_078287f5_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :address},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_078287f5(p0, p1, p2, p3) do
    ABI.encode(log_078287f5_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_078287f5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_078287f5(p0, p1, p2, p3), opts)
  end

  def build_trx_log_078287f5(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_078287f5(p0, p1, p2, p3)}
  end

  def call_log_078287f5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_078287f5(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_078287f5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_078287f5(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_078287f5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_078287f5(p0, p1, p2, p3), opts)
  end

  def decode_log_078287f5_call(<<7, 130, 135, 245>> <> calldata) do
    _signature = hex!("0x078287f5")
    ABI.decode(log_078287f5_selector(), calldata)
  end

  def exec_vm_log_078287f5(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_078287f5(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_078287f5_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_078287f5_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_078287f5(p0, p1, p2, p3), exec_opts)
  end

  def log_07831502_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :address},
        %{name: "p2", type: :bool},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_07831502(p0, p1, p2, p3) do
    ABI.encode(log_07831502_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_07831502(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_07831502(p0, p1, p2, p3), opts)
  end

  def build_trx_log_07831502(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_07831502(p0, p1, p2, p3)}
  end

  def call_log_07831502(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_07831502(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_07831502(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_07831502(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_07831502(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_07831502(p0, p1, p2, p3), opts)
  end

  def decode_log_07831502_call(<<7, 131, 21, 2>> <> calldata) do
    _signature = hex!("0x07831502")
    ABI.decode(log_07831502_selector(), calldata)
  end

  def exec_vm_log_07831502(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_07831502(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_07831502_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_07831502_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_07831502(p0, p1, p2, p3), exec_opts)
  end

  def log_088ef9d2_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :address}
      ]
    }
  end

  def encode_log_088ef9d2(p0, p1, p2) do
    ABI.encode(log_088ef9d2_selector(), [p0, p1, p2])
  end

  def prepare_log_088ef9d2(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_088ef9d2(p0, p1, p2), opts)
  end

  def build_trx_log_088ef9d2(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_088ef9d2(p0, p1, p2)}
  end

  def call_log_088ef9d2(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_088ef9d2(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_088ef9d2(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_088ef9d2(contract, p0, p1, p2), opts)
  end

  def execute_log_088ef9d2(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_088ef9d2(p0, p1, p2), opts)
  end

  def decode_log_088ef9d2_call(<<8, 142, 249, 210>> <> calldata) do
    _signature = hex!("0x088ef9d2")
    ABI.decode(log_088ef9d2_selector(), calldata)
  end

  def exec_vm_log_088ef9d2(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_088ef9d2(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_088ef9d2_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_088ef9d2_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_088ef9d2(p0, p1, p2), exec_opts)
  end

  def log_091ffaf5_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :address},
        %{name: "p2", type: :address},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_091ffaf5(p0, p1, p2, p3) do
    ABI.encode(log_091ffaf5_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_091ffaf5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_091ffaf5(p0, p1, p2, p3), opts)
  end

  def build_trx_log_091ffaf5(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_091ffaf5(p0, p1, p2, p3)}
  end

  def call_log_091ffaf5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_091ffaf5(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_091ffaf5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_091ffaf5(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_091ffaf5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_091ffaf5(p0, p1, p2, p3), opts)
  end

  def decode_log_091ffaf5_call(<<9, 31, 250, 245>> <> calldata) do
    _signature = hex!("0x091ffaf5")
    ABI.decode(log_091ffaf5_selector(), calldata)
  end

  def exec_vm_log_091ffaf5(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_091ffaf5(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_091ffaf5_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_091ffaf5_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_091ffaf5(p0, p1, p2, p3), exec_opts)
  end

  def log_0aa6cfad_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :bool},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_0aa6cfad(p0, p1, p2, p3) do
    ABI.encode(log_0aa6cfad_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_0aa6cfad(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_0aa6cfad(p0, p1, p2, p3), opts)
  end

  def build_trx_log_0aa6cfad(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_0aa6cfad(p0, p1, p2, p3)}
  end

  def call_log_0aa6cfad(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_0aa6cfad(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_0aa6cfad(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_0aa6cfad(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_0aa6cfad(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_0aa6cfad(p0, p1, p2, p3), opts)
  end

  def decode_log_0aa6cfad_call(<<10, 166, 207, 173>> <> calldata) do
    _signature = hex!("0x0aa6cfad")
    ABI.decode(log_0aa6cfad_selector(), calldata)
  end

  def exec_vm_log_0aa6cfad(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_0aa6cfad(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_0aa6cfad_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_0aa6cfad_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_0aa6cfad(p0, p1, p2, p3), exec_opts)
  end

  def log_0bb00eab_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :bool},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_0bb00eab(p0, p1, p2, p3) do
    ABI.encode(log_0bb00eab_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_0bb00eab(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_0bb00eab(p0, p1, p2, p3), opts)
  end

  def build_trx_log_0bb00eab(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_0bb00eab(p0, p1, p2, p3)}
  end

  def call_log_0bb00eab(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_0bb00eab(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_0bb00eab(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_0bb00eab(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_0bb00eab(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_0bb00eab(p0, p1, p2, p3), opts)
  end

  def decode_log_0bb00eab_call(<<11, 176, 14, 171>> <> calldata) do
    _signature = hex!("0x0bb00eab")
    ABI.decode(log_0bb00eab_selector(), calldata)
  end

  def exec_vm_log_0bb00eab(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_0bb00eab(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_0bb00eab_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_0bb00eab_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_0bb00eab(p0, p1, p2, p3), exec_opts)
  end

  def log_0c66d1be_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :address},
        %{name: "p2", type: :address},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_0c66d1be(p0, p1, p2, p3) do
    ABI.encode(log_0c66d1be_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_0c66d1be(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_0c66d1be(p0, p1, p2, p3), opts)
  end

  def build_trx_log_0c66d1be(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_0c66d1be(p0, p1, p2, p3)}
  end

  def call_log_0c66d1be(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_0c66d1be(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_0c66d1be(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_0c66d1be(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_0c66d1be(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_0c66d1be(p0, p1, p2, p3), opts)
  end

  def decode_log_0c66d1be_call(<<12, 102, 209, 190>> <> calldata) do
    _signature = hex!("0x0c66d1be")
    ABI.decode(log_0c66d1be_selector(), calldata)
  end

  def exec_vm_log_0c66d1be(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_0c66d1be(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_0c66d1be_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_0c66d1be_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_0c66d1be(p0, p1, p2, p3), exec_opts)
  end

  def log_0c9cd9c1_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :address},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_0c9cd9c1(p0, p1, p2, p3) do
    ABI.encode(log_0c9cd9c1_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_0c9cd9c1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_0c9cd9c1(p0, p1, p2, p3), opts)
  end

  def build_trx_log_0c9cd9c1(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_0c9cd9c1(p0, p1, p2, p3)}
  end

  def call_log_0c9cd9c1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_0c9cd9c1(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_0c9cd9c1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_0c9cd9c1(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_0c9cd9c1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_0c9cd9c1(p0, p1, p2, p3), opts)
  end

  def decode_log_0c9cd9c1_call(<<12, 156, 217, 193>> <> calldata) do
    _signature = hex!("0x0c9cd9c1")
    ABI.decode(log_0c9cd9c1_selector(), calldata)
  end

  def exec_vm_log_0c9cd9c1(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_0c9cd9c1(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_0c9cd9c1_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_0c9cd9c1_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_0c9cd9c1(p0, p1, p2, p3), exec_opts)
  end

  def log_0d26b925_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :address},
        %{name: "p2", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_0d26b925(p0, p1, p2) do
    ABI.encode(log_0d26b925_selector(), [p0, p1, p2])
  end

  def prepare_log_0d26b925(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_0d26b925(p0, p1, p2), opts)
  end

  def build_trx_log_0d26b925(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_0d26b925(p0, p1, p2)}
  end

  def call_log_0d26b925(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_0d26b925(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_0d26b925(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_0d26b925(contract, p0, p1, p2), opts)
  end

  def execute_log_0d26b925(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_0d26b925(p0, p1, p2), opts)
  end

  def decode_log_0d26b925_call(<<13, 38, 185, 37>> <> calldata) do
    _signature = hex!("0x0d26b925")
    ABI.decode(log_0d26b925_selector(), calldata)
  end

  def exec_vm_log_0d26b925(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_0d26b925(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_0d26b925_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_0d26b925_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_0d26b925(p0, p1, p2), exec_opts)
  end

  def log_0d36fa20_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :string},
        %{name: "p2", type: :address},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_0d36fa20(p0, p1, p2, p3) do
    ABI.encode(log_0d36fa20_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_0d36fa20(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_0d36fa20(p0, p1, p2, p3), opts)
  end

  def build_trx_log_0d36fa20(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_0d36fa20(p0, p1, p2, p3)}
  end

  def call_log_0d36fa20(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_0d36fa20(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_0d36fa20(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_0d36fa20(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_0d36fa20(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_0d36fa20(p0, p1, p2, p3), opts)
  end

  def decode_log_0d36fa20_call(<<13, 54, 250, 32>> <> calldata) do
    _signature = hex!("0x0d36fa20")
    ABI.decode(log_0d36fa20_selector(), calldata)
  end

  def exec_vm_log_0d36fa20(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_0d36fa20(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_0d36fa20_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_0d36fa20_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_0d36fa20(p0, p1, p2, p3), exec_opts)
  end

  def log_0df12b76_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :string},
        %{name: "p2", type: :address},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_0df12b76(p0, p1, p2, p3) do
    ABI.encode(log_0df12b76_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_0df12b76(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_0df12b76(p0, p1, p2, p3), opts)
  end

  def build_trx_log_0df12b76(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_0df12b76(p0, p1, p2, p3)}
  end

  def call_log_0df12b76(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_0df12b76(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_0df12b76(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_0df12b76(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_0df12b76(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_0df12b76(p0, p1, p2, p3), opts)
  end

  def decode_log_0df12b76_call(<<13, 241, 43, 118>> <> calldata) do
    _signature = hex!("0x0df12b76")
    ABI.decode(log_0df12b76_selector(), calldata)
  end

  def exec_vm_log_0df12b76(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_0df12b76(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_0df12b76_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_0df12b76_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_0df12b76(p0, p1, p2, p3), exec_opts)
  end

  def log_0e378994_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :address},
        %{name: "p2", type: :address},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_0e378994(p0, p1, p2, p3) do
    ABI.encode(log_0e378994_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_0e378994(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_0e378994(p0, p1, p2, p3), opts)
  end

  def build_trx_log_0e378994(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_0e378994(p0, p1, p2, p3)}
  end

  def call_log_0e378994(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_0e378994(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_0e378994(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_0e378994(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_0e378994(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_0e378994(p0, p1, p2, p3), opts)
  end

  def decode_log_0e378994_call(<<14, 55, 137, 148>> <> calldata) do
    _signature = hex!("0x0e378994")
    ABI.decode(log_0e378994_selector(), calldata)
  end

  def exec_vm_log_0e378994(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_0e378994(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_0e378994_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_0e378994_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_0e378994(p0, p1, p2, p3), exec_opts)
  end

  def log_0ef7e050_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :string},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_0ef7e050(p0, p1, p2, p3) do
    ABI.encode(log_0ef7e050_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_0ef7e050(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_0ef7e050(p0, p1, p2, p3), opts)
  end

  def build_trx_log_0ef7e050(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_0ef7e050(p0, p1, p2, p3)}
  end

  def call_log_0ef7e050(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_0ef7e050(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_0ef7e050(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_0ef7e050(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_0ef7e050(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_0ef7e050(p0, p1, p2, p3), opts)
  end

  def decode_log_0ef7e050_call(<<14, 247, 224, 80>> <> calldata) do
    _signature = hex!("0x0ef7e050")
    ABI.decode(log_0ef7e050_selector(), calldata)
  end

  def exec_vm_log_0ef7e050(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_0ef7e050(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_0ef7e050_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_0ef7e050_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_0ef7e050(p0, p1, p2, p3), exec_opts)
  end

  def log_100f650e_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :address},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_100f650e(p0, p1, p2, p3) do
    ABI.encode(log_100f650e_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_100f650e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_100f650e(p0, p1, p2, p3), opts)
  end

  def build_trx_log_100f650e(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_100f650e(p0, p1, p2, p3)}
  end

  def call_log_100f650e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_100f650e(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_100f650e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_100f650e(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_100f650e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_100f650e(p0, p1, p2, p3), opts)
  end

  def decode_log_100f650e_call(<<16, 15, 101, 14>> <> calldata) do
    _signature = hex!("0x100f650e")
    ABI.decode(log_100f650e_selector(), calldata)
  end

  def exec_vm_log_100f650e(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_100f650e(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_100f650e_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_100f650e_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_100f650e(p0, p1, p2, p3), exec_opts)
  end

  def log_1023f7b2_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :string},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_1023f7b2(p0, p1, p2, p3) do
    ABI.encode(log_1023f7b2_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_1023f7b2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_1023f7b2(p0, p1, p2, p3), opts)
  end

  def build_trx_log_1023f7b2(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_1023f7b2(p0, p1, p2, p3)}
  end

  def call_log_1023f7b2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_1023f7b2(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_1023f7b2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_1023f7b2(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_1023f7b2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_1023f7b2(p0, p1, p2, p3), opts)
  end

  def decode_log_1023f7b2_call(<<16, 35, 247, 178>> <> calldata) do
    _signature = hex!("0x1023f7b2")
    ABI.decode(log_1023f7b2_selector(), calldata)
  end

  def exec_vm_log_1023f7b2(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_1023f7b2(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_1023f7b2_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_1023f7b2_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_1023f7b2(p0, p1, p2, p3), exec_opts)
  end

  def log_1078f68d_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :address}
      ]
    }
  end

  def encode_log_1078f68d(p0, p1, p2) do
    ABI.encode(log_1078f68d_selector(), [p0, p1, p2])
  end

  def prepare_log_1078f68d(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_1078f68d(p0, p1, p2), opts)
  end

  def build_trx_log_1078f68d(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_1078f68d(p0, p1, p2)}
  end

  def call_log_1078f68d(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_1078f68d(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_1078f68d(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_1078f68d(contract, p0, p1, p2), opts)
  end

  def execute_log_1078f68d(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_1078f68d(p0, p1, p2), opts)
  end

  def decode_log_1078f68d_call(<<16, 120, 246, 141>> <> calldata) do
    _signature = hex!("0x1078f68d")
    ABI.decode(log_1078f68d_selector(), calldata)
  end

  def exec_vm_log_1078f68d(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_1078f68d(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_1078f68d_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_1078f68d_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_1078f68d(p0, p1, p2), exec_opts)
  end

  def log_1093ee11_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :string},
        %{name: "p2", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_1093ee11(p0, p1, p2) do
    ABI.encode(log_1093ee11_selector(), [p0, p1, p2])
  end

  def prepare_log_1093ee11(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_1093ee11(p0, p1, p2), opts)
  end

  def build_trx_log_1093ee11(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_1093ee11(p0, p1, p2)}
  end

  def call_log_1093ee11(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_1093ee11(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_1093ee11(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_1093ee11(contract, p0, p1, p2), opts)
  end

  def execute_log_1093ee11(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_1093ee11(p0, p1, p2), opts)
  end

  def decode_log_1093ee11_call(<<16, 147, 238, 17>> <> calldata) do
    _signature = hex!("0x1093ee11")
    ABI.decode(log_1093ee11_selector(), calldata)
  end

  def exec_vm_log_1093ee11(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_1093ee11(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_1093ee11_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_1093ee11_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_1093ee11(p0, p1, p2), exec_opts)
  end

  def log_12d6c788_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :string},
        %{name: "p2", type: :address},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_12d6c788(p0, p1, p2, p3) do
    ABI.encode(log_12d6c788_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_12d6c788(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_12d6c788(p0, p1, p2, p3), opts)
  end

  def build_trx_log_12d6c788(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_12d6c788(p0, p1, p2, p3)}
  end

  def call_log_12d6c788(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_12d6c788(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_12d6c788(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_12d6c788(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_12d6c788(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_12d6c788(p0, p1, p2, p3), opts)
  end

  def decode_log_12d6c788_call(<<18, 214, 199, 136>> <> calldata) do
    _signature = hex!("0x12d6c788")
    ABI.decode(log_12d6c788_selector(), calldata)
  end

  def exec_vm_log_12d6c788(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_12d6c788(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_12d6c788_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_12d6c788_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_12d6c788(p0, p1, p2, p3), exec_opts)
  end

  def log_12f21602_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :bool},
        %{name: "p2", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_12f21602(p0, p1, p2) do
    ABI.encode(log_12f21602_selector(), [p0, p1, p2])
  end

  def prepare_log_12f21602(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_12f21602(p0, p1, p2), opts)
  end

  def build_trx_log_12f21602(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_12f21602(p0, p1, p2)}
  end

  def call_log_12f21602(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_12f21602(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_12f21602(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_12f21602(contract, p0, p1, p2), opts)
  end

  def execute_log_12f21602(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_12f21602(p0, p1, p2), opts)
  end

  def decode_log_12f21602_call(<<18, 242, 22, 2>> <> calldata) do
    _signature = hex!("0x12f21602")
    ABI.decode(log_12f21602_selector(), calldata)
  end

  def exec_vm_log_12f21602(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_12f21602(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_12f21602_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_12f21602_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_12f21602(p0, p1, p2), exec_opts)
  end

  def log_136b05dd_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :address},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_136b05dd(p0, p1, p2, p3) do
    ABI.encode(log_136b05dd_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_136b05dd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_136b05dd(p0, p1, p2, p3), opts)
  end

  def build_trx_log_136b05dd(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_136b05dd(p0, p1, p2, p3)}
  end

  def call_log_136b05dd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_136b05dd(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_136b05dd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_136b05dd(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_136b05dd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_136b05dd(p0, p1, p2, p3), opts)
  end

  def decode_log_136b05dd_call(<<19, 107, 5, 221>> <> calldata) do
    _signature = hex!("0x136b05dd")
    ABI.decode(log_136b05dd_selector(), calldata)
  end

  def exec_vm_log_136b05dd(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_136b05dd(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_136b05dd_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_136b05dd_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_136b05dd(p0, p1, p2, p3), exec_opts)
  end

  def log_1537dc87_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :address},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_1537dc87(p0, p1, p2, p3) do
    ABI.encode(log_1537dc87_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_1537dc87(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_1537dc87(p0, p1, p2, p3), opts)
  end

  def build_trx_log_1537dc87(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_1537dc87(p0, p1, p2, p3)}
  end

  def call_log_1537dc87(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_1537dc87(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_1537dc87(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_1537dc87(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_1537dc87(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_1537dc87(p0, p1, p2, p3), opts)
  end

  def decode_log_1537dc87_call(<<21, 55, 220, 135>> <> calldata) do
    _signature = hex!("0x1537dc87")
    ABI.decode(log_1537dc87_selector(), calldata)
  end

  def exec_vm_log_1537dc87(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_1537dc87(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_1537dc87_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_1537dc87_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_1537dc87(p0, p1, p2, p3), exec_opts)
  end

  def log_1596a1ce_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :string},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_1596a1ce(p0, p1, p2, p3) do
    ABI.encode(log_1596a1ce_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_1596a1ce(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_1596a1ce(p0, p1, p2, p3), opts)
  end

  def build_trx_log_1596a1ce(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_1596a1ce(p0, p1, p2, p3)}
  end

  def call_log_1596a1ce(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_1596a1ce(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_1596a1ce(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_1596a1ce(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_1596a1ce(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_1596a1ce(p0, p1, p2, p3), opts)
  end

  def decode_log_1596a1ce_call(<<21, 150, 161, 206>> <> calldata) do
    _signature = hex!("0x1596a1ce")
    ABI.decode(log_1596a1ce_selector(), calldata)
  end

  def exec_vm_log_1596a1ce(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_1596a1ce(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_1596a1ce_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_1596a1ce_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_1596a1ce(p0, p1, p2, p3), exec_opts)
  end

  def log_159f8927_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :string},
        %{name: "p2", type: :string},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_159f8927(p0, p1, p2, p3) do
    ABI.encode(log_159f8927_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_159f8927(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_159f8927(p0, p1, p2, p3), opts)
  end

  def build_trx_log_159f8927(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_159f8927(p0, p1, p2, p3)}
  end

  def call_log_159f8927(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_159f8927(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_159f8927(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_159f8927(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_159f8927(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_159f8927(p0, p1, p2, p3), opts)
  end

  def decode_log_159f8927_call(<<21, 159, 137, 39>> <> calldata) do
    _signature = hex!("0x159f8927")
    ABI.decode(log_159f8927_selector(), calldata)
  end

  def exec_vm_log_159f8927(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_159f8927(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_159f8927_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_159f8927_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_159f8927(p0, p1, p2, p3), exec_opts)
  end

  def log_15c127b5_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :address},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_15c127b5(p0, p1, p2, p3) do
    ABI.encode(log_15c127b5_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_15c127b5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_15c127b5(p0, p1, p2, p3), opts)
  end

  def build_trx_log_15c127b5(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_15c127b5(p0, p1, p2, p3)}
  end

  def call_log_15c127b5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_15c127b5(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_15c127b5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_15c127b5(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_15c127b5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_15c127b5(p0, p1, p2, p3), opts)
  end

  def decode_log_15c127b5_call(<<21, 193, 39, 181>> <> calldata) do
    _signature = hex!("0x15c127b5")
    ABI.decode(log_15c127b5_selector(), calldata)
  end

  def exec_vm_log_15c127b5(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_15c127b5(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_15c127b5_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_15c127b5_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_15c127b5(p0, p1, p2, p3), exec_opts)
  end

  def log_15cac476_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :address},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_15cac476(p0, p1, p2, p3) do
    ABI.encode(log_15cac476_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_15cac476(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_15cac476(p0, p1, p2, p3), opts)
  end

  def build_trx_log_15cac476(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_15cac476(p0, p1, p2, p3)}
  end

  def call_log_15cac476(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_15cac476(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_15cac476(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_15cac476(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_15cac476(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_15cac476(p0, p1, p2, p3), opts)
  end

  def decode_log_15cac476_call(<<21, 202, 196, 118>> <> calldata) do
    _signature = hex!("0x15cac476")
    ABI.decode(log_15cac476_selector(), calldata)
  end

  def exec_vm_log_15cac476(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_15cac476(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_15cac476_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_15cac476_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_15cac476(p0, p1, p2, p3), exec_opts)
  end

  def log_1606a393_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :string},
        %{name: "p2", type: :bool},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_1606a393(p0, p1, p2, p3) do
    ABI.encode(log_1606a393_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_1606a393(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_1606a393(p0, p1, p2, p3), opts)
  end

  def build_trx_log_1606a393(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_1606a393(p0, p1, p2, p3)}
  end

  def call_log_1606a393(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_1606a393(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_1606a393(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_1606a393(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_1606a393(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_1606a393(p0, p1, p2, p3), opts)
  end

  def decode_log_1606a393_call(<<22, 6, 163, 147>> <> calldata) do
    _signature = hex!("0x1606a393")
    ABI.decode(log_1606a393_selector(), calldata)
  end

  def exec_vm_log_1606a393(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_1606a393(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_1606a393_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_1606a393_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_1606a393(p0, p1, p2, p3), exec_opts)
  end

  def log_1762e32a_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :string},
        %{name: "p2", type: :string},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_1762e32a(p0, p1, p2, p3) do
    ABI.encode(log_1762e32a_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_1762e32a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_1762e32a(p0, p1, p2, p3), opts)
  end

  def build_trx_log_1762e32a(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_1762e32a(p0, p1, p2, p3)}
  end

  def call_log_1762e32a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_1762e32a(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_1762e32a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_1762e32a(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_1762e32a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_1762e32a(p0, p1, p2, p3), opts)
  end

  def decode_log_1762e32a_call(<<23, 98, 227, 42>> <> calldata) do
    _signature = hex!("0x1762e32a")
    ABI.decode(log_1762e32a_selector(), calldata)
  end

  def exec_vm_log_1762e32a(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_1762e32a(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_1762e32a_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_1762e32a_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_1762e32a(p0, p1, p2, p3), exec_opts)
  end

  def log_17fe6185_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :address},
        %{name: "p2", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_17fe6185(p0, p1, p2) do
    ABI.encode(log_17fe6185_selector(), [p0, p1, p2])
  end

  def prepare_log_17fe6185(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_17fe6185(p0, p1, p2), opts)
  end

  def build_trx_log_17fe6185(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_17fe6185(p0, p1, p2)}
  end

  def call_log_17fe6185(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_17fe6185(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_17fe6185(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_17fe6185(contract, p0, p1, p2), opts)
  end

  def execute_log_17fe6185(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_17fe6185(p0, p1, p2), opts)
  end

  def decode_log_17fe6185_call(<<23, 254, 97, 133>> <> calldata) do
    _signature = hex!("0x17fe6185")
    ABI.decode(log_17fe6185_selector(), calldata)
  end

  def exec_vm_log_17fe6185(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_17fe6185(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_17fe6185_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_17fe6185_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_17fe6185(p0, p1, p2), exec_opts)
  end

  def log_18c9c746_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :address},
        %{name: "p2", type: :bool}
      ]
    }
  end

  def encode_log_18c9c746(p0, p1, p2) do
    ABI.encode(log_18c9c746_selector(), [p0, p1, p2])
  end

  def prepare_log_18c9c746(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_18c9c746(p0, p1, p2), opts)
  end

  def build_trx_log_18c9c746(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_18c9c746(p0, p1, p2)}
  end

  def call_log_18c9c746(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_18c9c746(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_18c9c746(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_18c9c746(contract, p0, p1, p2), opts)
  end

  def execute_log_18c9c746(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_18c9c746(p0, p1, p2), opts)
  end

  def decode_log_18c9c746_call(<<24, 201, 199, 70>> <> calldata) do
    _signature = hex!("0x18c9c746")
    ABI.decode(log_18c9c746_selector(), calldata)
  end

  def exec_vm_log_18c9c746(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_18c9c746(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_18c9c746_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_18c9c746_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_18c9c746(p0, p1, p2), exec_opts)
  end

  def log_193fb800_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_193fb800(p0, p1, p2, p3) do
    ABI.encode(log_193fb800_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_193fb800(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_193fb800(p0, p1, p2, p3), opts)
  end

  def build_trx_log_193fb800(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_193fb800(p0, p1, p2, p3)}
  end

  def call_log_193fb800(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_193fb800(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_193fb800(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_193fb800(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_193fb800(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_193fb800(p0, p1, p2, p3), opts)
  end

  def decode_log_193fb800_call(<<25, 63, 184, 0>> <> calldata) do
    _signature = hex!("0x193fb800")
    ABI.decode(log_193fb800_selector(), calldata)
  end

  def exec_vm_log_193fb800(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_193fb800(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_193fb800_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_193fb800_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_193fb800(p0, p1, p2, p3), exec_opts)
  end

  def log_19fd4956_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :string},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_19fd4956(p0, p1, p2, p3) do
    ABI.encode(log_19fd4956_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_19fd4956(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_19fd4956(p0, p1, p2, p3), opts)
  end

  def build_trx_log_19fd4956(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_19fd4956(p0, p1, p2, p3)}
  end

  def call_log_19fd4956(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_19fd4956(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_19fd4956(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_19fd4956(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_19fd4956(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_19fd4956(p0, p1, p2, p3), opts)
  end

  def decode_log_19fd4956_call(<<25, 253, 73, 86>> <> calldata) do
    _signature = hex!("0x19fd4956")
    ABI.decode(log_19fd4956_selector(), calldata)
  end

  def exec_vm_log_19fd4956(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_19fd4956(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_19fd4956_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_19fd4956_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_19fd4956(p0, p1, p2, p3), exec_opts)
  end

  def log_1ad96de6_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :string},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_1ad96de6(p0, p1, p2, p3) do
    ABI.encode(log_1ad96de6_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_1ad96de6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_1ad96de6(p0, p1, p2, p3), opts)
  end

  def build_trx_log_1ad96de6(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_1ad96de6(p0, p1, p2, p3)}
  end

  def call_log_1ad96de6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_1ad96de6(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_1ad96de6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_1ad96de6(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_1ad96de6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_1ad96de6(p0, p1, p2, p3), opts)
  end

  def decode_log_1ad96de6_call(<<26, 217, 109, 230>> <> calldata) do
    _signature = hex!("0x1ad96de6")
    ABI.decode(log_1ad96de6_selector(), calldata)
  end

  def exec_vm_log_1ad96de6(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_1ad96de6(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_1ad96de6_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_1ad96de6_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_1ad96de6(p0, p1, p2, p3), exec_opts)
  end

  def log_1bb3b09a_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :address},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_1bb3b09a(p0, p1, p2, p3) do
    ABI.encode(log_1bb3b09a_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_1bb3b09a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_1bb3b09a(p0, p1, p2, p3), opts)
  end

  def build_trx_log_1bb3b09a(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_1bb3b09a(p0, p1, p2, p3)}
  end

  def call_log_1bb3b09a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_1bb3b09a(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_1bb3b09a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_1bb3b09a(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_1bb3b09a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_1bb3b09a(p0, p1, p2, p3), opts)
  end

  def decode_log_1bb3b09a_call(<<27, 179, 176, 154>> <> calldata) do
    _signature = hex!("0x1bb3b09a")
    ABI.decode(log_1bb3b09a_selector(), calldata)
  end

  def exec_vm_log_1bb3b09a(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_1bb3b09a(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_1bb3b09a_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_1bb3b09a_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_1bb3b09a(p0, p1, p2, p3), exec_opts)
  end

  def log_1c41a336_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :address},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_1c41a336(p0, p1, p2, p3) do
    ABI.encode(log_1c41a336_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_1c41a336(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_1c41a336(p0, p1, p2, p3), opts)
  end

  def build_trx_log_1c41a336(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_1c41a336(p0, p1, p2, p3)}
  end

  def call_log_1c41a336(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_1c41a336(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_1c41a336(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_1c41a336(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_1c41a336(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_1c41a336(p0, p1, p2, p3), opts)
  end

  def decode_log_1c41a336_call(<<28, 65, 163, 54>> <> calldata) do
    _signature = hex!("0x1c41a336")
    ABI.decode(log_1c41a336_selector(), calldata)
  end

  def exec_vm_log_1c41a336(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_1c41a336(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_1c41a336_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_1c41a336_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_1c41a336(p0, p1, p2, p3), exec_opts)
  end

  def log_1c7ec448_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :address}
      ]
    }
  end

  def encode_log_1c7ec448(p0, p1, p2) do
    ABI.encode(log_1c7ec448_selector(), [p0, p1, p2])
  end

  def prepare_log_1c7ec448(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_1c7ec448(p0, p1, p2), opts)
  end

  def build_trx_log_1c7ec448(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_1c7ec448(p0, p1, p2)}
  end

  def call_log_1c7ec448(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_1c7ec448(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_1c7ec448(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_1c7ec448(contract, p0, p1, p2), opts)
  end

  def execute_log_1c7ec448(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_1c7ec448(p0, p1, p2), opts)
  end

  def decode_log_1c7ec448_call(<<28, 126, 196, 72>> <> calldata) do
    _signature = hex!("0x1c7ec448")
    ABI.decode(log_1c7ec448_selector(), calldata)
  end

  def exec_vm_log_1c7ec448(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_1c7ec448(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_1c7ec448_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_1c7ec448_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_1c7ec448(p0, p1, p2), exec_opts)
  end

  def log_1c9d7eb3_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:uint, 256}}, %{name: "p1", type: :bool}]
    }
  end

  def encode_log_1c9d7eb3(p0, p1) do
    ABI.encode(log_1c9d7eb3_selector(), [p0, p1])
  end

  def prepare_log_1c9d7eb3(contract, p0, p1, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_1c9d7eb3(p0, p1), opts)
  end

  def build_trx_log_1c9d7eb3(contract, p0, p1) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_1c9d7eb3(p0, p1)}
  end

  def call_log_1c9d7eb3(contract, p0, p1, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_1c9d7eb3(contract, p0, p1), opts)
  end

  def estimate_gas_log_1c9d7eb3(contract, p0, p1, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_1c9d7eb3(contract, p0, p1), opts)
  end

  def execute_log_1c9d7eb3(contract, p0, p1, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_1c9d7eb3(p0, p1), opts)
  end

  def decode_log_1c9d7eb3_call(<<28, 157, 126, 179>> <> calldata) do
    _signature = hex!("0x1c9d7eb3")
    ABI.decode(log_1c9d7eb3_selector(), calldata)
  end

  def exec_vm_log_1c9d7eb3(p0, p1, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_1c9d7eb3(p0, p1), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_1c9d7eb3_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_1c9d7eb3_raw(p0, p1, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_1c9d7eb3(p0, p1), exec_opts)
  end

  def log_1d14d001_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :address},
        %{name: "p2", type: :address},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_1d14d001(p0, p1, p2, p3) do
    ABI.encode(log_1d14d001_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_1d14d001(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_1d14d001(p0, p1, p2, p3), opts)
  end

  def build_trx_log_1d14d001(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_1d14d001(p0, p1, p2, p3)}
  end

  def call_log_1d14d001(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_1d14d001(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_1d14d001(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_1d14d001(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_1d14d001(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_1d14d001(p0, p1, p2, p3), opts)
  end

  def decode_log_1d14d001_call(<<29, 20, 208, 1>> <> calldata) do
    _signature = hex!("0x1d14d001")
    ABI.decode(log_1d14d001_selector(), calldata)
  end

  def exec_vm_log_1d14d001(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_1d14d001(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_1d14d001_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_1d14d001_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_1d14d001(p0, p1, p2, p3), exec_opts)
  end

  def log_1da986ea_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :address},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_1da986ea(p0, p1, p2, p3) do
    ABI.encode(log_1da986ea_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_1da986ea(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_1da986ea(p0, p1, p2, p3), opts)
  end

  def build_trx_log_1da986ea(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_1da986ea(p0, p1, p2, p3)}
  end

  def call_log_1da986ea(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_1da986ea(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_1da986ea(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_1da986ea(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_1da986ea(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_1da986ea(p0, p1, p2, p3), opts)
  end

  def decode_log_1da986ea_call(<<29, 169, 134, 234>> <> calldata) do
    _signature = hex!("0x1da986ea")
    ABI.decode(log_1da986ea_selector(), calldata)
  end

  def exec_vm_log_1da986ea(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_1da986ea(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_1da986ea_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_1da986ea_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_1da986ea(p0, p1, p2, p3), exec_opts)
  end

  def log_1dc8e1b8_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :string},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_1dc8e1b8(p0, p1, p2, p3) do
    ABI.encode(log_1dc8e1b8_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_1dc8e1b8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_1dc8e1b8(p0, p1, p2, p3), opts)
  end

  def build_trx_log_1dc8e1b8(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_1dc8e1b8(p0, p1, p2, p3)}
  end

  def call_log_1dc8e1b8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_1dc8e1b8(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_1dc8e1b8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_1dc8e1b8(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_1dc8e1b8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_1dc8e1b8(p0, p1, p2, p3), opts)
  end

  def decode_log_1dc8e1b8_call(<<29, 200, 225, 184>> <> calldata) do
    _signature = hex!("0x1dc8e1b8")
    ABI.decode(log_1dc8e1b8_selector(), calldata)
  end

  def exec_vm_log_1dc8e1b8(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_1dc8e1b8(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_1dc8e1b8_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_1dc8e1b8_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_1dc8e1b8(p0, p1, p2, p3), exec_opts)
  end

  def log_1e4b87e5_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :string},
        %{name: "p2", type: :string},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_1e4b87e5(p0, p1, p2, p3) do
    ABI.encode(log_1e4b87e5_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_1e4b87e5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_1e4b87e5(p0, p1, p2, p3), opts)
  end

  def build_trx_log_1e4b87e5(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_1e4b87e5(p0, p1, p2, p3)}
  end

  def call_log_1e4b87e5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_1e4b87e5(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_1e4b87e5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_1e4b87e5(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_1e4b87e5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_1e4b87e5(p0, p1, p2, p3), opts)
  end

  def decode_log_1e4b87e5_call(<<30, 75, 135, 229>> <> calldata) do
    _signature = hex!("0x1e4b87e5")
    ABI.decode(log_1e4b87e5_selector(), calldata)
  end

  def exec_vm_log_1e4b87e5(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_1e4b87e5(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_1e4b87e5_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_1e4b87e5_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_1e4b87e5(p0, p1, p2, p3), exec_opts)
  end

  def log_20098014_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :bool},
        %{name: "p2", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_20098014(p0, p1, p2) do
    ABI.encode(log_20098014_selector(), [p0, p1, p2])
  end

  def prepare_log_20098014(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_20098014(p0, p1, p2), opts)
  end

  def build_trx_log_20098014(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_20098014(p0, p1, p2)}
  end

  def call_log_20098014(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_20098014(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_20098014(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_20098014(contract, p0, p1, p2), opts)
  end

  def execute_log_20098014(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_20098014(p0, p1, p2), opts)
  end

  def decode_log_20098014_call(<<32, 9, 128, 20>> <> calldata) do
    _signature = hex!("0x20098014")
    ABI.decode(log_20098014_selector(), calldata)
  end

  def exec_vm_log_20098014(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_20098014(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_20098014_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_20098014_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_20098014(p0, p1, p2), exec_opts)
  end

  def log_205871c2_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :string},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_205871c2(p0, p1, p2, p3) do
    ABI.encode(log_205871c2_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_205871c2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_205871c2(p0, p1, p2, p3), opts)
  end

  def build_trx_log_205871c2(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_205871c2(p0, p1, p2, p3)}
  end

  def call_log_205871c2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_205871c2(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_205871c2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_205871c2(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_205871c2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_205871c2(p0, p1, p2, p3), opts)
  end

  def decode_log_205871c2_call(<<32, 88, 113, 194>> <> calldata) do
    _signature = hex!("0x205871c2")
    ABI.decode(log_205871c2_selector(), calldata)
  end

  def exec_vm_log_205871c2(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_205871c2(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_205871c2_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_205871c2_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_205871c2(p0, p1, p2, p3), exec_opts)
  end

  def log_20718650_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :bool}
      ]
    }
  end

  def encode_log_20718650(p0, p1, p2) do
    ABI.encode(log_20718650_selector(), [p0, p1, p2])
  end

  def prepare_log_20718650(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_20718650(p0, p1, p2), opts)
  end

  def build_trx_log_20718650(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_20718650(p0, p1, p2)}
  end

  def call_log_20718650(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_20718650(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_20718650(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_20718650(contract, p0, p1, p2), opts)
  end

  def execute_log_20718650(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_20718650(p0, p1, p2), opts)
  end

  def decode_log_20718650_call(<<32, 113, 134, 80>> <> calldata) do
    _signature = hex!("0x20718650")
    ABI.decode(log_20718650_selector(), calldata)
  end

  def exec_vm_log_20718650(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_20718650(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_20718650_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_20718650_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_20718650(p0, p1, p2), exec_opts)
  end

  def log_20e3984d_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_20e3984d(p0, p1, p2, p3) do
    ABI.encode(log_20e3984d_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_20e3984d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_20e3984d(p0, p1, p2, p3), opts)
  end

  def build_trx_log_20e3984d(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_20e3984d(p0, p1, p2, p3)}
  end

  def call_log_20e3984d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_20e3984d(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_20e3984d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_20e3984d(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_20e3984d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_20e3984d(p0, p1, p2, p3), opts)
  end

  def decode_log_20e3984d_call(<<32, 227, 152, 77>> <> calldata) do
    _signature = hex!("0x20e3984d")
    ABI.decode(log_20e3984d_selector(), calldata)
  end

  def exec_vm_log_20e3984d(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_20e3984d(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_20e3984d_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_20e3984d_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_20e3984d(p0, p1, p2, p3), exec_opts)
  end

  def log_212255cc_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :string}
      ]
    }
  end

  def encode_log_212255cc(p0, p1, p2) do
    ABI.encode(log_212255cc_selector(), [p0, p1, p2])
  end

  def prepare_log_212255cc(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_212255cc(p0, p1, p2), opts)
  end

  def build_trx_log_212255cc(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_212255cc(p0, p1, p2)}
  end

  def call_log_212255cc(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_212255cc(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_212255cc(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_212255cc(contract, p0, p1, p2), opts)
  end

  def execute_log_212255cc(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_212255cc(p0, p1, p2), opts)
  end

  def decode_log_212255cc_call(<<33, 34, 85, 204>> <> calldata) do
    _signature = hex!("0x212255cc")
    ABI.decode(log_212255cc_selector(), calldata)
  end

  def exec_vm_log_212255cc(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_212255cc(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_212255cc_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_212255cc_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_212255cc(p0, p1, p2), exec_opts)
  end

  def log_21ad0683_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :string},
        %{name: "p2", type: :string},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_21ad0683(p0, p1, p2, p3) do
    ABI.encode(log_21ad0683_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_21ad0683(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_21ad0683(p0, p1, p2, p3), opts)
  end

  def build_trx_log_21ad0683(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_21ad0683(p0, p1, p2, p3)}
  end

  def call_log_21ad0683(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_21ad0683(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_21ad0683(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_21ad0683(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_21ad0683(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_21ad0683(p0, p1, p2, p3), opts)
  end

  def decode_log_21ad0683_call(<<33, 173, 6, 131>> <> calldata) do
    _signature = hex!("0x21ad0683")
    ABI.decode(log_21ad0683_selector(), calldata)
  end

  def exec_vm_log_21ad0683(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_21ad0683(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_21ad0683_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_21ad0683_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_21ad0683(p0, p1, p2, p3), exec_opts)
  end

  def log_21bdaf25_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :address},
        %{name: "p2", type: :string},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_21bdaf25(p0, p1, p2, p3) do
    ABI.encode(log_21bdaf25_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_21bdaf25(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_21bdaf25(p0, p1, p2, p3), opts)
  end

  def build_trx_log_21bdaf25(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_21bdaf25(p0, p1, p2, p3)}
  end

  def call_log_21bdaf25(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_21bdaf25(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_21bdaf25(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_21bdaf25(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_21bdaf25(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_21bdaf25(p0, p1, p2, p3), opts)
  end

  def decode_log_21bdaf25_call(<<33, 189, 175, 37>> <> calldata) do
    _signature = hex!("0x21bdaf25")
    ABI.decode(log_21bdaf25_selector(), calldata)
  end

  def exec_vm_log_21bdaf25(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_21bdaf25(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_21bdaf25_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_21bdaf25_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_21bdaf25(p0, p1, p2, p3), exec_opts)
  end

  def log_223603bd_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :address},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_223603bd(p0, p1, p2, p3) do
    ABI.encode(log_223603bd_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_223603bd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_223603bd(p0, p1, p2, p3), opts)
  end

  def build_trx_log_223603bd(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_223603bd(p0, p1, p2, p3)}
  end

  def call_log_223603bd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_223603bd(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_223603bd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_223603bd(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_223603bd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_223603bd(p0, p1, p2, p3), opts)
  end

  def decode_log_223603bd_call(<<34, 54, 3, 189>> <> calldata) do
    _signature = hex!("0x223603bd")
    ABI.decode(log_223603bd_selector(), calldata)
  end

  def exec_vm_log_223603bd(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_223603bd(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_223603bd_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_223603bd_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_223603bd(p0, p1, p2, p3), exec_opts)
  end

  def log_22f6b999_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :bool},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_22f6b999(p0, p1, p2, p3) do
    ABI.encode(log_22f6b999_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_22f6b999(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_22f6b999(p0, p1, p2, p3), opts)
  end

  def build_trx_log_22f6b999(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_22f6b999(p0, p1, p2, p3)}
  end

  def call_log_22f6b999(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_22f6b999(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_22f6b999(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_22f6b999(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_22f6b999(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_22f6b999(p0, p1, p2, p3), opts)
  end

  def decode_log_22f6b999_call(<<34, 246, 185, 153>> <> calldata) do
    _signature = hex!("0x22f6b999")
    ABI.decode(log_22f6b999_selector(), calldata)
  end

  def exec_vm_log_22f6b999(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_22f6b999(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_22f6b999_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_22f6b999_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_22f6b999(p0, p1, p2, p3), exec_opts)
  end

  def log_245986f2_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :address},
        %{name: "p2", type: :string},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_245986f2(p0, p1, p2, p3) do
    ABI.encode(log_245986f2_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_245986f2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_245986f2(p0, p1, p2, p3), opts)
  end

  def build_trx_log_245986f2(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_245986f2(p0, p1, p2, p3)}
  end

  def call_log_245986f2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_245986f2(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_245986f2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_245986f2(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_245986f2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_245986f2(p0, p1, p2, p3), opts)
  end

  def decode_log_245986f2_call(<<36, 89, 134, 242>> <> calldata) do
    _signature = hex!("0x245986f2")
    ABI.decode(log_245986f2_selector(), calldata)
  end

  def exec_vm_log_245986f2(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_245986f2(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_245986f2_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_245986f2_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_245986f2(p0, p1, p2, p3), exec_opts)
  end

  def log_2488b414_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :address},
        %{name: "p2", type: :address},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_2488b414(p0, p1, p2, p3) do
    ABI.encode(log_2488b414_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_2488b414(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_2488b414(p0, p1, p2, p3), opts)
  end

  def build_trx_log_2488b414(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_2488b414(p0, p1, p2, p3)}
  end

  def call_log_2488b414(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_2488b414(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_2488b414(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_2488b414(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_2488b414(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_2488b414(p0, p1, p2, p3), opts)
  end

  def decode_log_2488b414_call(<<36, 136, 180, 20>> <> calldata) do
    _signature = hex!("0x2488b414")
    ABI.decode(log_2488b414_selector(), calldata)
  end

  def exec_vm_log_2488b414(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_2488b414(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_2488b414_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_2488b414_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_2488b414(p0, p1, p2, p3), exec_opts)
  end

  def log_24f91465_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :string},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_24f91465(p0, p1, p2, p3) do
    ABI.encode(log_24f91465_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_24f91465(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_24f91465(p0, p1, p2, p3), opts)
  end

  def build_trx_log_24f91465(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_24f91465(p0, p1, p2, p3)}
  end

  def call_log_24f91465(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_24f91465(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_24f91465(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_24f91465(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_24f91465(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_24f91465(p0, p1, p2, p3), opts)
  end

  def decode_log_24f91465_call(<<36, 249, 20, 101>> <> calldata) do
    _signature = hex!("0x24f91465")
    ABI.decode(log_24f91465_selector(), calldata)
  end

  def exec_vm_log_24f91465(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_24f91465(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_24f91465_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_24f91465_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_24f91465(p0, p1, p2, p3), exec_opts)
  end

  def log_2555fa46_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :string}
      ]
    }
  end

  def encode_log_2555fa46(p0, p1, p2) do
    ABI.encode(log_2555fa46_selector(), [p0, p1, p2])
  end

  def prepare_log_2555fa46(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_2555fa46(p0, p1, p2), opts)
  end

  def build_trx_log_2555fa46(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_2555fa46(p0, p1, p2)}
  end

  def call_log_2555fa46(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_2555fa46(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_2555fa46(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_2555fa46(contract, p0, p1, p2), opts)
  end

  def execute_log_2555fa46(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_2555fa46(p0, p1, p2), opts)
  end

  def decode_log_2555fa46_call(<<37, 85, 250, 70>> <> calldata) do
    _signature = hex!("0x2555fa46")
    ABI.decode(log_2555fa46_selector(), calldata)
  end

  def exec_vm_log_2555fa46(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_2555fa46(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_2555fa46_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_2555fa46_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_2555fa46(p0, p1, p2), exec_opts)
  end

  def log_26f560a8_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :address},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_26f560a8(p0, p1, p2, p3) do
    ABI.encode(log_26f560a8_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_26f560a8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_26f560a8(p0, p1, p2, p3), opts)
  end

  def build_trx_log_26f560a8(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_26f560a8(p0, p1, p2, p3)}
  end

  def call_log_26f560a8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_26f560a8(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_26f560a8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_26f560a8(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_26f560a8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_26f560a8(p0, p1, p2, p3), opts)
  end

  def decode_log_26f560a8_call(<<38, 245, 96, 168>> <> calldata) do
    _signature = hex!("0x26f560a8")
    ABI.decode(log_26f560a8_selector(), calldata)
  end

  def exec_vm_log_26f560a8(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_26f560a8(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_26f560a8_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_26f560a8_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_26f560a8(p0, p1, p2, p3), exec_opts)
  end

  def log_27d8afd2_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :string},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_27d8afd2(p0, p1, p2, p3) do
    ABI.encode(log_27d8afd2_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_27d8afd2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_27d8afd2(p0, p1, p2, p3), opts)
  end

  def build_trx_log_27d8afd2(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_27d8afd2(p0, p1, p2, p3)}
  end

  def call_log_27d8afd2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_27d8afd2(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_27d8afd2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_27d8afd2(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_27d8afd2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_27d8afd2(p0, p1, p2, p3), opts)
  end

  def decode_log_27d8afd2_call(<<39, 216, 175, 210>> <> calldata) do
    _signature = hex!("0x27d8afd2")
    ABI.decode(log_27d8afd2_selector(), calldata)
  end

  def exec_vm_log_27d8afd2(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_27d8afd2(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_27d8afd2_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_27d8afd2_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_27d8afd2(p0, p1, p2, p3), exec_opts)
  end

  def log_28863fcb_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :string},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_28863fcb(p0, p1, p2, p3) do
    ABI.encode(log_28863fcb_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_28863fcb(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_28863fcb(p0, p1, p2, p3), opts)
  end

  def build_trx_log_28863fcb(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_28863fcb(p0, p1, p2, p3)}
  end

  def call_log_28863fcb(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_28863fcb(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_28863fcb(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_28863fcb(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_28863fcb(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_28863fcb(p0, p1, p2, p3), opts)
  end

  def decode_log_28863fcb_call(<<40, 134, 63, 203>> <> calldata) do
    _signature = hex!("0x28863fcb")
    ABI.decode(log_28863fcb_selector(), calldata)
  end

  def exec_vm_log_28863fcb(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_28863fcb(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_28863fcb_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_28863fcb_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_28863fcb(p0, p1, p2, p3), exec_opts)
  end

  def log_2a110e83_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: :bool}, %{name: "p1", type: :bool}]
    }
  end

  def encode_log_2a110e83(p0, p1) do
    ABI.encode(log_2a110e83_selector(), [p0, p1])
  end

  def prepare_log_2a110e83(contract, p0, p1, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_2a110e83(p0, p1), opts)
  end

  def build_trx_log_2a110e83(contract, p0, p1) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_2a110e83(p0, p1)}
  end

  def call_log_2a110e83(contract, p0, p1, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_2a110e83(contract, p0, p1), opts)
  end

  def estimate_gas_log_2a110e83(contract, p0, p1, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_2a110e83(contract, p0, p1), opts)
  end

  def execute_log_2a110e83(contract, p0, p1, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_2a110e83(p0, p1), opts)
  end

  def decode_log_2a110e83_call(<<42, 17, 14, 131>> <> calldata) do
    _signature = hex!("0x2a110e83")
    ABI.decode(log_2a110e83_selector(), calldata)
  end

  def exec_vm_log_2a110e83(p0, p1, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_2a110e83(p0, p1), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_2a110e83_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_2a110e83_raw(p0, p1, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_2a110e83(p0, p1), exec_opts)
  end

  def log_2ae408d4_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_2ae408d4(p0, p1, p2, p3) do
    ABI.encode(log_2ae408d4_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_2ae408d4(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_2ae408d4(p0, p1, p2, p3), opts)
  end

  def build_trx_log_2ae408d4(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_2ae408d4(p0, p1, p2, p3)}
  end

  def call_log_2ae408d4(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_2ae408d4(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_2ae408d4(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_2ae408d4(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_2ae408d4(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_2ae408d4(p0, p1, p2, p3), opts)
  end

  def decode_log_2ae408d4_call(<<42, 228, 8, 212>> <> calldata) do
    _signature = hex!("0x2ae408d4")
    ABI.decode(log_2ae408d4_selector(), calldata)
  end

  def exec_vm_log_2ae408d4(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_2ae408d4(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_2ae408d4_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_2ae408d4_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_2ae408d4(p0, p1, p2, p3), exec_opts)
  end

  def log_2b2b18dc_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :string},
        %{name: "p2", type: :address},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_2b2b18dc(p0, p1, p2, p3) do
    ABI.encode(log_2b2b18dc_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_2b2b18dc(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_2b2b18dc(p0, p1, p2, p3), opts)
  end

  def build_trx_log_2b2b18dc(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_2b2b18dc(p0, p1, p2, p3)}
  end

  def call_log_2b2b18dc(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_2b2b18dc(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_2b2b18dc(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_2b2b18dc(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_2b2b18dc(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_2b2b18dc(p0, p1, p2, p3), opts)
  end

  def decode_log_2b2b18dc_call(<<43, 43, 24, 220>> <> calldata) do
    _signature = hex!("0x2b2b18dc")
    ABI.decode(log_2b2b18dc_selector(), calldata)
  end

  def exec_vm_log_2b2b18dc(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_2b2b18dc(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_2b2b18dc_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_2b2b18dc_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_2b2b18dc(p0, p1, p2, p3), exec_opts)
  end

  def log_2c1754ed_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :string},
        %{name: "p2", type: :string},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_2c1754ed(p0, p1, p2, p3) do
    ABI.encode(log_2c1754ed_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_2c1754ed(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_2c1754ed(p0, p1, p2, p3), opts)
  end

  def build_trx_log_2c1754ed(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_2c1754ed(p0, p1, p2, p3)}
  end

  def call_log_2c1754ed(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_2c1754ed(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_2c1754ed(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_2c1754ed(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_2c1754ed(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_2c1754ed(p0, p1, p2, p3), opts)
  end

  def decode_log_2c1754ed_call(<<44, 23, 84, 237>> <> calldata) do
    _signature = hex!("0x2c1754ed")
    ABI.decode(log_2c1754ed_selector(), calldata)
  end

  def exec_vm_log_2c1754ed(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_2c1754ed(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_2c1754ed_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_2c1754ed_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_2c1754ed(p0, p1, p2, p3), exec_opts)
  end

  def log_2c1d0746_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :string},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_2c1d0746(p0, p1, p2, p3) do
    ABI.encode(log_2c1d0746_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_2c1d0746(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_2c1d0746(p0, p1, p2, p3), opts)
  end

  def build_trx_log_2c1d0746(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_2c1d0746(p0, p1, p2, p3)}
  end

  def call_log_2c1d0746(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_2c1d0746(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_2c1d0746(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_2c1d0746(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_2c1d0746(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_2c1d0746(p0, p1, p2, p3), opts)
  end

  def decode_log_2c1d0746_call(<<44, 29, 7, 70>> <> calldata) do
    _signature = hex!("0x2c1d0746")
    ABI.decode(log_2c1d0746_selector(), calldata)
  end

  def exec_vm_log_2c1d0746(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_2c1d0746(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_2c1d0746_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_2c1d0746_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_2c1d0746(p0, p1, p2, p3), exec_opts)
  end

  def log_2c2ecbc2_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: :address}]
    }
  end

  def encode_log_2c2ecbc2(p0) do
    ABI.encode(log_2c2ecbc2_selector(), [p0])
  end

  def prepare_log_2c2ecbc2(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_2c2ecbc2(p0), opts)
  end

  def build_trx_log_2c2ecbc2(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_2c2ecbc2(p0)}
  end

  def call_log_2c2ecbc2(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_2c2ecbc2(contract, p0), opts)
  end

  def estimate_gas_log_2c2ecbc2(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_2c2ecbc2(contract, p0), opts)
  end

  def execute_log_2c2ecbc2(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_2c2ecbc2(p0), opts)
  end

  def decode_log_2c2ecbc2_call(<<44, 46, 203, 194>> <> calldata) do
    _signature = hex!("0x2c2ecbc2")
    ABI.decode(log_2c2ecbc2_selector(), calldata)
  end

  def exec_vm_log_2c2ecbc2(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_2c2ecbc2(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_2c2ecbc2_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_2c2ecbc2_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_2c2ecbc2(p0), exec_opts)
  end

  def log_2cd4134a_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :address},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_2cd4134a(p0, p1, p2, p3) do
    ABI.encode(log_2cd4134a_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_2cd4134a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_2cd4134a(p0, p1, p2, p3), opts)
  end

  def build_trx_log_2cd4134a(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_2cd4134a(p0, p1, p2, p3)}
  end

  def call_log_2cd4134a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_2cd4134a(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_2cd4134a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_2cd4134a(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_2cd4134a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_2cd4134a(p0, p1, p2, p3), opts)
  end

  def decode_log_2cd4134a_call(<<44, 212, 19, 74>> <> calldata) do
    _signature = hex!("0x2cd4134a")
    ABI.decode(log_2cd4134a_selector(), calldata)
  end

  def exec_vm_log_2cd4134a(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_2cd4134a(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_2cd4134a_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_2cd4134a_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_2cd4134a(p0, p1, p2, p3), exec_opts)
  end

  def log_2ced7cef_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :string},
        %{name: "p2", type: :string}
      ]
    }
  end

  def encode_log_2ced7cef(p0, p1, p2) do
    ABI.encode(log_2ced7cef_selector(), [p0, p1, p2])
  end

  def prepare_log_2ced7cef(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_2ced7cef(p0, p1, p2), opts)
  end

  def build_trx_log_2ced7cef(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_2ced7cef(p0, p1, p2)}
  end

  def call_log_2ced7cef(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_2ced7cef(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_2ced7cef(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_2ced7cef(contract, p0, p1, p2), opts)
  end

  def execute_log_2ced7cef(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_2ced7cef(p0, p1, p2), opts)
  end

  def decode_log_2ced7cef_call(<<44, 237, 124, 239>> <> calldata) do
    _signature = hex!("0x2ced7cef")
    ABI.decode(log_2ced7cef_selector(), calldata)
  end

  def exec_vm_log_2ced7cef(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_2ced7cef(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_2ced7cef_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_2ced7cef_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_2ced7cef(p0, p1, p2), exec_opts)
  end

  def log_2d5b6cb9_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:int, 256}}]
    }
  end

  def encode_log_2d5b6cb9(p0) do
    ABI.encode(log_2d5b6cb9_selector(), [p0])
  end

  def prepare_log_2d5b6cb9(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_2d5b6cb9(p0), opts)
  end

  def build_trx_log_2d5b6cb9(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_2d5b6cb9(p0)}
  end

  def call_log_2d5b6cb9(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_2d5b6cb9(contract, p0), opts)
  end

  def estimate_gas_log_2d5b6cb9(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_2d5b6cb9(contract, p0), opts)
  end

  def execute_log_2d5b6cb9(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_2d5b6cb9(p0), opts)
  end

  def decode_log_2d5b6cb9_call(<<45, 91, 108, 185>> <> calldata) do
    _signature = hex!("0x2d5b6cb9")
    ABI.decode(log_2d5b6cb9_selector(), calldata)
  end

  def exec_vm_log_2d5b6cb9(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_2d5b6cb9(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_2d5b6cb9_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_2d5b6cb9_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_2d5b6cb9(p0), exec_opts)
  end

  def log_2d8e33a4_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :address},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_2d8e33a4(p0, p1, p2, p3) do
    ABI.encode(log_2d8e33a4_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_2d8e33a4(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_2d8e33a4(p0, p1, p2, p3), opts)
  end

  def build_trx_log_2d8e33a4(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_2d8e33a4(p0, p1, p2, p3)}
  end

  def call_log_2d8e33a4(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_2d8e33a4(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_2d8e33a4(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_2d8e33a4(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_2d8e33a4(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_2d8e33a4(p0, p1, p2, p3), opts)
  end

  def decode_log_2d8e33a4_call(<<45, 142, 51, 164>> <> calldata) do
    _signature = hex!("0x2d8e33a4")
    ABI.decode(log_2d8e33a4_selector(), calldata)
  end

  def exec_vm_log_2d8e33a4(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_2d8e33a4(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_2d8e33a4_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_2d8e33a4_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_2d8e33a4(p0, p1, p2, p3), exec_opts)
  end

  def log_2dd778e6_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :address},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_2dd778e6(p0, p1, p2, p3) do
    ABI.encode(log_2dd778e6_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_2dd778e6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_2dd778e6(p0, p1, p2, p3), opts)
  end

  def build_trx_log_2dd778e6(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_2dd778e6(p0, p1, p2, p3)}
  end

  def call_log_2dd778e6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_2dd778e6(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_2dd778e6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_2dd778e6(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_2dd778e6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_2dd778e6(p0, p1, p2, p3), opts)
  end

  def decode_log_2dd778e6_call(<<45, 215, 120, 230>> <> calldata) do
    _signature = hex!("0x2dd778e6")
    ABI.decode(log_2dd778e6_selector(), calldata)
  end

  def exec_vm_log_2dd778e6(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_2dd778e6(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_2dd778e6_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_2dd778e6_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_2dd778e6(p0, p1, p2, p3), exec_opts)
  end

  def log_319af333_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: :string}, %{name: "p1", type: :address}]
    }
  end

  def encode_log_319af333(p0, p1) do
    ABI.encode(log_319af333_selector(), [p0, p1])
  end

  def prepare_log_319af333(contract, p0, p1, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_319af333(p0, p1), opts)
  end

  def build_trx_log_319af333(contract, p0, p1) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_319af333(p0, p1)}
  end

  def call_log_319af333(contract, p0, p1, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_319af333(contract, p0, p1), opts)
  end

  def estimate_gas_log_319af333(contract, p0, p1, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_319af333(contract, p0, p1), opts)
  end

  def execute_log_319af333(contract, p0, p1, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_319af333(p0, p1), opts)
  end

  def decode_log_319af333_call(<<49, 154, 243, 51>> <> calldata) do
    _signature = hex!("0x319af333")
    ABI.decode(log_319af333_selector(), calldata)
  end

  def exec_vm_log_319af333(p0, p1, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_319af333(p0, p1), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_319af333_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_319af333_raw(p0, p1, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_319af333(p0, p1), exec_opts)
  end

  def log_32458eed_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: :bool}]
    }
  end

  def encode_log_32458eed(p0) do
    ABI.encode(log_32458eed_selector(), [p0])
  end

  def prepare_log_32458eed(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_32458eed(p0), opts)
  end

  def build_trx_log_32458eed(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_32458eed(p0)}
  end

  def call_log_32458eed(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_32458eed(contract, p0), opts)
  end

  def estimate_gas_log_32458eed(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_32458eed(contract, p0), opts)
  end

  def execute_log_32458eed(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_32458eed(p0), opts)
  end

  def decode_log_32458eed_call(<<50, 69, 142, 237>> <> calldata) do
    _signature = hex!("0x32458eed")
    ABI.decode(log_32458eed_selector(), calldata)
  end

  def exec_vm_log_32458eed(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_32458eed(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_32458eed_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_32458eed_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_32458eed(p0), exec_opts)
  end

  def log_33e9dd1d_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :address},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_33e9dd1d(p0, p1, p2, p3) do
    ABI.encode(log_33e9dd1d_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_33e9dd1d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_33e9dd1d(p0, p1, p2, p3), opts)
  end

  def build_trx_log_33e9dd1d(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_33e9dd1d(p0, p1, p2, p3)}
  end

  def call_log_33e9dd1d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_33e9dd1d(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_33e9dd1d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_33e9dd1d(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_33e9dd1d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_33e9dd1d(p0, p1, p2, p3), opts)
  end

  def decode_log_33e9dd1d_call(<<51, 233, 221, 29>> <> calldata) do
    _signature = hex!("0x33e9dd1d")
    ABI.decode(log_33e9dd1d_selector(), calldata)
  end

  def exec_vm_log_33e9dd1d(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_33e9dd1d(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_33e9dd1d_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_33e9dd1d_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_33e9dd1d(p0, p1, p2, p3), exec_opts)
  end

  def log_34f0e636_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_34f0e636(p0, p1, p2, p3) do
    ABI.encode(log_34f0e636_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_34f0e636(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_34f0e636(p0, p1, p2, p3), opts)
  end

  def build_trx_log_34f0e636(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_34f0e636(p0, p1, p2, p3)}
  end

  def call_log_34f0e636(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_34f0e636(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_34f0e636(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_34f0e636(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_34f0e636(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_34f0e636(p0, p1, p2, p3), opts)
  end

  def decode_log_34f0e636_call(<<52, 240, 230, 54>> <> calldata) do
    _signature = hex!("0x34f0e636")
    ABI.decode(log_34f0e636_selector(), calldata)
  end

  def exec_vm_log_34f0e636(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_34f0e636(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_34f0e636_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_34f0e636_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_34f0e636(p0, p1, p2, p3), exec_opts)
  end

  def log_35085f7b_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :address}
      ]
    }
  end

  def encode_log_35085f7b(p0, p1, p2) do
    ABI.encode(log_35085f7b_selector(), [p0, p1, p2])
  end

  def prepare_log_35085f7b(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_35085f7b(p0, p1, p2), opts)
  end

  def build_trx_log_35085f7b(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_35085f7b(p0, p1, p2)}
  end

  def call_log_35085f7b(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_35085f7b(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_35085f7b(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_35085f7b(contract, p0, p1, p2), opts)
  end

  def execute_log_35085f7b(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_35085f7b(p0, p1, p2), opts)
  end

  def decode_log_35085f7b_call(<<53, 8, 95, 123>> <> calldata) do
    _signature = hex!("0x35085f7b")
    ABI.decode(log_35085f7b_selector(), calldata)
  end

  def exec_vm_log_35085f7b(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_35085f7b(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_35085f7b_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_35085f7b_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_35085f7b(p0, p1, p2), exec_opts)
  end

  def log_354c36d6_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_354c36d6(p0, p1, p2, p3) do
    ABI.encode(log_354c36d6_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_354c36d6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_354c36d6(p0, p1, p2, p3), opts)
  end

  def build_trx_log_354c36d6(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_354c36d6(p0, p1, p2, p3)}
  end

  def call_log_354c36d6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_354c36d6(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_354c36d6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_354c36d6(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_354c36d6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_354c36d6(p0, p1, p2, p3), opts)
  end

  def decode_log_354c36d6_call(<<53, 76, 54, 214>> <> calldata) do
    _signature = hex!("0x354c36d6")
    ABI.decode(log_354c36d6_selector(), calldata)
  end

  def exec_vm_log_354c36d6(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_354c36d6(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_354c36d6_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_354c36d6_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_354c36d6(p0, p1, p2, p3), exec_opts)
  end

  def log_35a5071f_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :string},
        %{name: "p2", type: :string},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_35a5071f(p0, p1, p2, p3) do
    ABI.encode(log_35a5071f_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_35a5071f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_35a5071f(p0, p1, p2, p3), opts)
  end

  def build_trx_log_35a5071f(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_35a5071f(p0, p1, p2, p3)}
  end

  def call_log_35a5071f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_35a5071f(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_35a5071f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_35a5071f(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_35a5071f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_35a5071f(p0, p1, p2, p3), opts)
  end

  def decode_log_35a5071f_call(<<53, 165, 7, 31>> <> calldata) do
    _signature = hex!("0x35a5071f")
    ABI.decode(log_35a5071f_selector(), calldata)
  end

  def exec_vm_log_35a5071f(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_35a5071f(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_35a5071f_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_35a5071f_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_35a5071f(p0, p1, p2, p3), exec_opts)
  end

  def log_37103367_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_37103367(p0, p1, p2) do
    ABI.encode(log_37103367_selector(), [p0, p1, p2])
  end

  def prepare_log_37103367(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_37103367(p0, p1, p2), opts)
  end

  def build_trx_log_37103367(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_37103367(p0, p1, p2)}
  end

  def call_log_37103367(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_37103367(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_37103367(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_37103367(contract, p0, p1, p2), opts)
  end

  def execute_log_37103367(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_37103367(p0, p1, p2), opts)
  end

  def decode_log_37103367_call(<<55, 16, 51, 103>> <> calldata) do
    _signature = hex!("0x37103367")
    ABI.decode(log_37103367_selector(), calldata)
  end

  def exec_vm_log_37103367(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_37103367(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_37103367_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_37103367_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_37103367(p0, p1, p2), exec_opts)
  end

  def log_374bb4b2_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_374bb4b2(p0, p1, p2, p3) do
    ABI.encode(log_374bb4b2_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_374bb4b2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_374bb4b2(p0, p1, p2, p3), opts)
  end

  def build_trx_log_374bb4b2(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_374bb4b2(p0, p1, p2, p3)}
  end

  def call_log_374bb4b2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_374bb4b2(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_374bb4b2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_374bb4b2(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_374bb4b2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_374bb4b2(p0, p1, p2, p3), opts)
  end

  def decode_log_374bb4b2_call(<<55, 75, 180, 178>> <> calldata) do
    _signature = hex!("0x374bb4b2")
    ABI.decode(log_374bb4b2_selector(), calldata)
  end

  def exec_vm_log_374bb4b2(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_374bb4b2(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_374bb4b2_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_374bb4b2_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_374bb4b2(p0, p1, p2, p3), exec_opts)
  end

  def log_37aa7d4c_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :string},
        %{name: "p2", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_37aa7d4c(p0, p1, p2) do
    ABI.encode(log_37aa7d4c_selector(), [p0, p1, p2])
  end

  def prepare_log_37aa7d4c(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_37aa7d4c(p0, p1, p2), opts)
  end

  def build_trx_log_37aa7d4c(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_37aa7d4c(p0, p1, p2)}
  end

  def call_log_37aa7d4c(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_37aa7d4c(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_37aa7d4c(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_37aa7d4c(contract, p0, p1, p2), opts)
  end

  def execute_log_37aa7d4c(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_37aa7d4c(p0, p1, p2), opts)
  end

  def decode_log_37aa7d4c_call(<<55, 170, 125, 76>> <> calldata) do
    _signature = hex!("0x37aa7d4c")
    ABI.decode(log_37aa7d4c_selector(), calldata)
  end

  def exec_vm_log_37aa7d4c(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_37aa7d4c(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_37aa7d4c_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_37aa7d4c_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_37aa7d4c(p0, p1, p2), exec_opts)
  end

  def log_386ff5f4_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :bool},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_386ff5f4(p0, p1, p2, p3) do
    ABI.encode(log_386ff5f4_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_386ff5f4(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_386ff5f4(p0, p1, p2, p3), opts)
  end

  def build_trx_log_386ff5f4(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_386ff5f4(p0, p1, p2, p3)}
  end

  def call_log_386ff5f4(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_386ff5f4(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_386ff5f4(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_386ff5f4(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_386ff5f4(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_386ff5f4(p0, p1, p2, p3), opts)
  end

  def decode_log_386ff5f4_call(<<56, 111, 245, 244>> <> calldata) do
    _signature = hex!("0x386ff5f4")
    ABI.decode(log_386ff5f4_selector(), calldata)
  end

  def exec_vm_log_386ff5f4(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_386ff5f4(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_386ff5f4_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_386ff5f4_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_386ff5f4(p0, p1, p2, p3), exec_opts)
  end

  def log_3971e78c_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :address},
        %{name: "p2", type: :bool},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_3971e78c(p0, p1, p2, p3) do
    ABI.encode(log_3971e78c_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_3971e78c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_3971e78c(p0, p1, p2, p3), opts)
  end

  def build_trx_log_3971e78c(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_3971e78c(p0, p1, p2, p3)}
  end

  def call_log_3971e78c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_3971e78c(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_3971e78c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_3971e78c(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_3971e78c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_3971e78c(p0, p1, p2, p3), opts)
  end

  def decode_log_3971e78c_call(<<57, 113, 231, 140>> <> calldata) do
    _signature = hex!("0x3971e78c")
    ABI.decode(log_3971e78c_selector(), calldata)
  end

  def exec_vm_log_3971e78c(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_3971e78c(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_3971e78c_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_3971e78c_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_3971e78c(p0, p1, p2, p3), exec_opts)
  end

  def log_399174d3_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: :bool}, %{name: "p1", type: {:uint, 256}}]
    }
  end

  def encode_log_399174d3(p0, p1) do
    ABI.encode(log_399174d3_selector(), [p0, p1])
  end

  def prepare_log_399174d3(contract, p0, p1, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_399174d3(p0, p1), opts)
  end

  def build_trx_log_399174d3(contract, p0, p1) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_399174d3(p0, p1)}
  end

  def call_log_399174d3(contract, p0, p1, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_399174d3(contract, p0, p1), opts)
  end

  def estimate_gas_log_399174d3(contract, p0, p1, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_399174d3(contract, p0, p1), opts)
  end

  def execute_log_399174d3(contract, p0, p1, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_399174d3(p0, p1), opts)
  end

  def decode_log_399174d3_call(<<57, 145, 116, 211>> <> calldata) do
    _signature = hex!("0x399174d3")
    ABI.decode(log_399174d3_selector(), calldata)
  end

  def exec_vm_log_399174d3(p0, p1, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_399174d3(p0, p1), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_399174d3_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_399174d3_raw(p0, p1, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_399174d3(p0, p1), exec_opts)
  end

  def log_3b2279b4_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :string},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_3b2279b4(p0, p1, p2, p3) do
    ABI.encode(log_3b2279b4_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_3b2279b4(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_3b2279b4(p0, p1, p2, p3), opts)
  end

  def build_trx_log_3b2279b4(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_3b2279b4(p0, p1, p2, p3)}
  end

  def call_log_3b2279b4(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_3b2279b4(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_3b2279b4(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_3b2279b4(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_3b2279b4(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_3b2279b4(p0, p1, p2, p3), opts)
  end

  def decode_log_3b2279b4_call(<<59, 34, 121, 180>> <> calldata) do
    _signature = hex!("0x3b2279b4")
    ABI.decode(log_3b2279b4_selector(), calldata)
  end

  def exec_vm_log_3b2279b4(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_3b2279b4(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_3b2279b4_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_3b2279b4_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_3b2279b4(p0, p1, p2, p3), exec_opts)
  end

  def log_3b2a5ce0_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_3b2a5ce0(p0, p1, p2, p3) do
    ABI.encode(log_3b2a5ce0_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_3b2a5ce0(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_3b2a5ce0(p0, p1, p2, p3), opts)
  end

  def build_trx_log_3b2a5ce0(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_3b2a5ce0(p0, p1, p2, p3)}
  end

  def call_log_3b2a5ce0(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_3b2a5ce0(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_3b2a5ce0(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_3b2a5ce0(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_3b2a5ce0(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_3b2a5ce0(p0, p1, p2, p3), opts)
  end

  def decode_log_3b2a5ce0_call(<<59, 42, 92, 224>> <> calldata) do
    _signature = hex!("0x3b2a5ce0")
    ABI.decode(log_3b2a5ce0_selector(), calldata)
  end

  def exec_vm_log_3b2a5ce0(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_3b2a5ce0(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_3b2a5ce0_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_3b2a5ce0_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_3b2a5ce0(p0, p1, p2, p3), exec_opts)
  end

  def log_3bf5e537_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_3bf5e537(p0, p1, p2, p3) do
    ABI.encode(log_3bf5e537_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_3bf5e537(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_3bf5e537(p0, p1, p2, p3), opts)
  end

  def build_trx_log_3bf5e537(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_3bf5e537(p0, p1, p2, p3)}
  end

  def call_log_3bf5e537(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_3bf5e537(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_3bf5e537(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_3bf5e537(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_3bf5e537(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_3bf5e537(p0, p1, p2, p3), opts)
  end

  def decode_log_3bf5e537_call(<<59, 245, 229, 55>> <> calldata) do
    _signature = hex!("0x3bf5e537")
    ABI.decode(log_3bf5e537_selector(), calldata)
  end

  def exec_vm_log_3bf5e537(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_3bf5e537(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_3bf5e537_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_3bf5e537_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_3bf5e537(p0, p1, p2, p3), exec_opts)
  end

  def log_3ca6268e_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: :string}, %{name: "p1", type: {:int, 256}}]
    }
  end

  def encode_log_3ca6268e(p0, p1) do
    ABI.encode(log_3ca6268e_selector(), [p0, p1])
  end

  def prepare_log_3ca6268e(contract, p0, p1, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_3ca6268e(p0, p1), opts)
  end

  def build_trx_log_3ca6268e(contract, p0, p1) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_3ca6268e(p0, p1)}
  end

  def call_log_3ca6268e(contract, p0, p1, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_3ca6268e(contract, p0, p1), opts)
  end

  def estimate_gas_log_3ca6268e(contract, p0, p1, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_3ca6268e(contract, p0, p1), opts)
  end

  def execute_log_3ca6268e(contract, p0, p1, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_3ca6268e(p0, p1), opts)
  end

  def decode_log_3ca6268e_call(<<60, 166, 38, 142>> <> calldata) do
    _signature = hex!("0x3ca6268e")
    ABI.decode(log_3ca6268e_selector(), calldata)
  end

  def exec_vm_log_3ca6268e(p0, p1, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_3ca6268e(p0, p1), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_3ca6268e_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_3ca6268e_raw(p0, p1, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_3ca6268e(p0, p1), exec_opts)
  end

  def log_3e128ca3_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :address},
        %{name: "p2", type: :string},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_3e128ca3(p0, p1, p2, p3) do
    ABI.encode(log_3e128ca3_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_3e128ca3(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_3e128ca3(p0, p1, p2, p3), opts)
  end

  def build_trx_log_3e128ca3(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_3e128ca3(p0, p1, p2, p3)}
  end

  def call_log_3e128ca3(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_3e128ca3(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_3e128ca3(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_3e128ca3(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_3e128ca3(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_3e128ca3(p0, p1, p2, p3), opts)
  end

  def decode_log_3e128ca3_call(<<62, 18, 140, 163>> <> calldata) do
    _signature = hex!("0x3e128ca3")
    ABI.decode(log_3e128ca3_selector(), calldata)
  end

  def exec_vm_log_3e128ca3(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_3e128ca3(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_3e128ca3_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_3e128ca3_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_3e128ca3(p0, p1, p2, p3), exec_opts)
  end

  def log_3e9f866a_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :address},
        %{name: "p2", type: :bool},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_3e9f866a(p0, p1, p2, p3) do
    ABI.encode(log_3e9f866a_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_3e9f866a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_3e9f866a(p0, p1, p2, p3), opts)
  end

  def build_trx_log_3e9f866a(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_3e9f866a(p0, p1, p2, p3)}
  end

  def call_log_3e9f866a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_3e9f866a(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_3e9f866a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_3e9f866a(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_3e9f866a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_3e9f866a(p0, p1, p2, p3), opts)
  end

  def decode_log_3e9f866a_call(<<62, 159, 134, 106>> <> calldata) do
    _signature = hex!("0x3e9f866a")
    ABI.decode(log_3e9f866a_selector(), calldata)
  end

  def exec_vm_log_3e9f866a(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_3e9f866a(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_3e9f866a_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_3e9f866a_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_3e9f866a(p0, p1, p2, p3), exec_opts)
  end

  def log_3f8a701d_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :string},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_3f8a701d(p0, p1, p2, p3) do
    ABI.encode(log_3f8a701d_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_3f8a701d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_3f8a701d(p0, p1, p2, p3), opts)
  end

  def build_trx_log_3f8a701d(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_3f8a701d(p0, p1, p2, p3)}
  end

  def call_log_3f8a701d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_3f8a701d(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_3f8a701d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_3f8a701d(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_3f8a701d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_3f8a701d(p0, p1, p2, p3), opts)
  end

  def decode_log_3f8a701d_call(<<63, 138, 112, 29>> <> calldata) do
    _signature = hex!("0x3f8a701d")
    ABI.decode(log_3f8a701d_selector(), calldata)
  end

  def exec_vm_log_3f8a701d(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_3f8a701d(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_3f8a701d_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_3f8a701d_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_3f8a701d(p0, p1, p2, p3), exec_opts)
  end

  def log_40785869_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :string},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_40785869(p0, p1, p2, p3) do
    ABI.encode(log_40785869_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_40785869(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_40785869(p0, p1, p2, p3), opts)
  end

  def build_trx_log_40785869(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_40785869(p0, p1, p2, p3)}
  end

  def call_log_40785869(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_40785869(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_40785869(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_40785869(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_40785869(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_40785869(p0, p1, p2, p3), opts)
  end

  def decode_log_40785869_call(<<64, 120, 88, 105>> <> calldata) do
    _signature = hex!("0x40785869")
    ABI.decode(log_40785869_selector(), calldata)
  end

  def exec_vm_log_40785869(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_40785869(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_40785869_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_40785869_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_40785869(p0, p1, p2, p3), exec_opts)
  end

  def log_41304fac_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: :string}]
    }
  end

  def encode_log_41304fac(p0) do
    ABI.encode(log_41304fac_selector(), [p0])
  end

  def prepare_log_41304fac(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_41304fac(p0), opts)
  end

  def build_trx_log_41304fac(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_41304fac(p0)}
  end

  def call_log_41304fac(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_41304fac(contract, p0), opts)
  end

  def estimate_gas_log_41304fac(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_41304fac(contract, p0), opts)
  end

  def execute_log_41304fac(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_41304fac(p0), opts)
  end

  def decode_log_41304fac_call(<<65, 48, 79, 172>> <> calldata) do
    _signature = hex!("0x41304fac")
    ABI.decode(log_41304fac_selector(), calldata)
  end

  def exec_vm_log_41304fac(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_41304fac(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_41304fac_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_41304fac_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_41304fac(p0), exec_opts)
  end

  def log_42d21db7_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :string},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_42d21db7(p0, p1, p2, p3) do
    ABI.encode(log_42d21db7_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_42d21db7(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_42d21db7(p0, p1, p2, p3), opts)
  end

  def build_trx_log_42d21db7(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_42d21db7(p0, p1, p2, p3)}
  end

  def call_log_42d21db7(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_42d21db7(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_42d21db7(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_42d21db7(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_42d21db7(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_42d21db7(p0, p1, p2, p3), opts)
  end

  def decode_log_42d21db7_call(<<66, 210, 29, 183>> <> calldata) do
    _signature = hex!("0x42d21db7")
    ABI.decode(log_42d21db7_selector(), calldata)
  end

  def exec_vm_log_42d21db7(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_42d21db7(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_42d21db7_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_42d21db7_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_42d21db7(p0, p1, p2, p3), exec_opts)
  end

  def log_439c7bef_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :string},
        %{name: "p2", type: :address},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_439c7bef(p0, p1, p2, p3) do
    ABI.encode(log_439c7bef_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_439c7bef(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_439c7bef(p0, p1, p2, p3), opts)
  end

  def build_trx_log_439c7bef(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_439c7bef(p0, p1, p2, p3)}
  end

  def call_log_439c7bef(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_439c7bef(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_439c7bef(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_439c7bef(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_439c7bef(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_439c7bef(p0, p1, p2, p3), opts)
  end

  def decode_log_439c7bef_call(<<67, 156, 123, 239>> <> calldata) do
    _signature = hex!("0x439c7bef")
    ABI.decode(log_439c7bef_selector(), calldata)
  end

  def exec_vm_log_439c7bef(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_439c7bef(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_439c7bef_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_439c7bef_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_439c7bef(p0, p1, p2, p3), exec_opts)
  end

  def log_448830a8_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :string},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_448830a8(p0, p1, p2, p3) do
    ABI.encode(log_448830a8_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_448830a8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_448830a8(p0, p1, p2, p3), opts)
  end

  def build_trx_log_448830a8(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_448830a8(p0, p1, p2, p3)}
  end

  def call_log_448830a8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_448830a8(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_448830a8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_448830a8(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_448830a8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_448830a8(p0, p1, p2, p3), opts)
  end

  def decode_log_448830a8_call(<<68, 136, 48, 168>> <> calldata) do
    _signature = hex!("0x448830a8")
    ABI.decode(log_448830a8_selector(), calldata)
  end

  def exec_vm_log_448830a8(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_448830a8(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_448830a8_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_448830a8_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_448830a8(p0, p1, p2, p3), exec_opts)
  end

  def log_454d54a5_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :address},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_454d54a5(p0, p1, p2, p3) do
    ABI.encode(log_454d54a5_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_454d54a5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_454d54a5(p0, p1, p2, p3), opts)
  end

  def build_trx_log_454d54a5(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_454d54a5(p0, p1, p2, p3)}
  end

  def call_log_454d54a5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_454d54a5(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_454d54a5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_454d54a5(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_454d54a5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_454d54a5(p0, p1, p2, p3), opts)
  end

  def decode_log_454d54a5_call(<<69, 77, 84, 165>> <> calldata) do
    _signature = hex!("0x454d54a5")
    ABI.decode(log_454d54a5_selector(), calldata)
  end

  def exec_vm_log_454d54a5(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_454d54a5(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_454d54a5_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_454d54a5_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_454d54a5(p0, p1, p2, p3), exec_opts)
  end

  def log_457fe3cf_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :string},
        %{name: "p2", type: :address},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_457fe3cf(p0, p1, p2, p3) do
    ABI.encode(log_457fe3cf_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_457fe3cf(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_457fe3cf(p0, p1, p2, p3), opts)
  end

  def build_trx_log_457fe3cf(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_457fe3cf(p0, p1, p2, p3)}
  end

  def call_log_457fe3cf(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_457fe3cf(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_457fe3cf(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_457fe3cf(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_457fe3cf(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_457fe3cf(p0, p1, p2, p3), opts)
  end

  def decode_log_457fe3cf_call(<<69, 127, 227, 207>> <> calldata) do
    _signature = hex!("0x457fe3cf")
    ABI.decode(log_457fe3cf_selector(), calldata)
  end

  def exec_vm_log_457fe3cf(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_457fe3cf(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_457fe3cf_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_457fe3cf_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_457fe3cf(p0, p1, p2, p3), exec_opts)
  end

  def log_46600be0_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :address},
        %{name: "p2", type: :address},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_46600be0(p0, p1, p2, p3) do
    ABI.encode(log_46600be0_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_46600be0(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_46600be0(p0, p1, p2, p3), opts)
  end

  def build_trx_log_46600be0(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_46600be0(p0, p1, p2, p3)}
  end

  def call_log_46600be0(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_46600be0(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_46600be0(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_46600be0(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_46600be0(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_46600be0(p0, p1, p2, p3), opts)
  end

  def decode_log_46600be0_call(<<70, 96, 11, 224>> <> calldata) do
    _signature = hex!("0x46600be0")
    ABI.decode(log_46600be0_selector(), calldata)
  end

  def exec_vm_log_46600be0(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_46600be0(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_46600be0_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_46600be0_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_46600be0(p0, p1, p2, p3), exec_opts)
  end

  def log_46826b5d_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :address},
        %{name: "p2", type: :string},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_46826b5d(p0, p1, p2, p3) do
    ABI.encode(log_46826b5d_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_46826b5d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_46826b5d(p0, p1, p2, p3), opts)
  end

  def build_trx_log_46826b5d(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_46826b5d(p0, p1, p2, p3)}
  end

  def call_log_46826b5d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_46826b5d(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_46826b5d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_46826b5d(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_46826b5d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_46826b5d(p0, p1, p2, p3), opts)
  end

  def decode_log_46826b5d_call(<<70, 130, 107, 93>> <> calldata) do
    _signature = hex!("0x46826b5d")
    ABI.decode(log_46826b5d_selector(), calldata)
  end

  def exec_vm_log_46826b5d(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_46826b5d(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_46826b5d_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_46826b5d_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_46826b5d(p0, p1, p2, p3), exec_opts)
  end

  def log_475c5c33_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :string},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_475c5c33(p0, p1, p2, p3) do
    ABI.encode(log_475c5c33_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_475c5c33(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_475c5c33(p0, p1, p2, p3), opts)
  end

  def build_trx_log_475c5c33(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_475c5c33(p0, p1, p2, p3)}
  end

  def call_log_475c5c33(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_475c5c33(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_475c5c33(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_475c5c33(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_475c5c33(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_475c5c33(p0, p1, p2, p3), opts)
  end

  def decode_log_475c5c33_call(<<71, 92, 92, 51>> <> calldata) do
    _signature = hex!("0x475c5c33")
    ABI.decode(log_475c5c33_selector(), calldata)
  end

  def exec_vm_log_475c5c33(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_475c5c33(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_475c5c33_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_475c5c33_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_475c5c33(p0, p1, p2, p3), exec_opts)
  end

  def log_4766da72_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :bool}
      ]
    }
  end

  def encode_log_4766da72(p0, p1, p2) do
    ABI.encode(log_4766da72_selector(), [p0, p1, p2])
  end

  def prepare_log_4766da72(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_4766da72(p0, p1, p2), opts)
  end

  def build_trx_log_4766da72(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_4766da72(p0, p1, p2)}
  end

  def call_log_4766da72(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_4766da72(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_4766da72(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_4766da72(contract, p0, p1, p2), opts)
  end

  def execute_log_4766da72(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_4766da72(p0, p1, p2), opts)
  end

  def decode_log_4766da72_call(<<71, 102, 218, 114>> <> calldata) do
    _signature = hex!("0x4766da72")
    ABI.decode(log_4766da72_selector(), calldata)
  end

  def exec_vm_log_4766da72(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_4766da72(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_4766da72_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_4766da72_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_4766da72(p0, p1, p2), exec_opts)
  end

  def log_478d1c62_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :address},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_478d1c62(p0, p1, p2, p3) do
    ABI.encode(log_478d1c62_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_478d1c62(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_478d1c62(p0, p1, p2, p3), opts)
  end

  def build_trx_log_478d1c62(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_478d1c62(p0, p1, p2, p3)}
  end

  def call_log_478d1c62(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_478d1c62(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_478d1c62(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_478d1c62(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_478d1c62(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_478d1c62(p0, p1, p2, p3), opts)
  end

  def decode_log_478d1c62_call(<<71, 141, 28, 98>> <> calldata) do
    _signature = hex!("0x478d1c62")
    ABI.decode(log_478d1c62_selector(), calldata)
  end

  def exec_vm_log_478d1c62(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_478d1c62(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_478d1c62_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_478d1c62_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_478d1c62(p0, p1, p2, p3), exec_opts)
  end

  def log_483d0416_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :string},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_483d0416(p0, p1, p2, p3) do
    ABI.encode(log_483d0416_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_483d0416(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_483d0416(p0, p1, p2, p3), opts)
  end

  def build_trx_log_483d0416(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_483d0416(p0, p1, p2, p3)}
  end

  def call_log_483d0416(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_483d0416(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_483d0416(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_483d0416(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_483d0416(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_483d0416(p0, p1, p2, p3), opts)
  end

  def decode_log_483d0416_call(<<72, 61, 4, 22>> <> calldata) do
    _signature = hex!("0x483d0416")
    ABI.decode(log_483d0416_selector(), calldata)
  end

  def exec_vm_log_483d0416(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_483d0416(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_483d0416_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_483d0416_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_483d0416(p0, p1, p2, p3), exec_opts)
  end

  def log_4a28c017_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_4a28c017(p0, p1, p2, p3) do
    ABI.encode(log_4a28c017_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_4a28c017(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_4a28c017(p0, p1, p2, p3), opts)
  end

  def build_trx_log_4a28c017(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_4a28c017(p0, p1, p2, p3)}
  end

  def call_log_4a28c017(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_4a28c017(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_4a28c017(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_4a28c017(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_4a28c017(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_4a28c017(p0, p1, p2, p3), opts)
  end

  def decode_log_4a28c017_call(<<74, 40, 192, 23>> <> calldata) do
    _signature = hex!("0x4a28c017")
    ABI.decode(log_4a28c017_selector(), calldata)
  end

  def exec_vm_log_4a28c017(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_4a28c017(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_4a28c017_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_4a28c017_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_4a28c017(p0, p1, p2, p3), exec_opts)
  end

  def log_4a66cb34_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :address},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_4a66cb34(p0, p1, p2, p3) do
    ABI.encode(log_4a66cb34_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_4a66cb34(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_4a66cb34(p0, p1, p2, p3), opts)
  end

  def build_trx_log_4a66cb34(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_4a66cb34(p0, p1, p2, p3)}
  end

  def call_log_4a66cb34(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_4a66cb34(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_4a66cb34(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_4a66cb34(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_4a66cb34(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_4a66cb34(p0, p1, p2, p3), opts)
  end

  def decode_log_4a66cb34_call(<<74, 102, 203, 52>> <> calldata) do
    _signature = hex!("0x4a66cb34")
    ABI.decode(log_4a66cb34_selector(), calldata)
  end

  def exec_vm_log_4a66cb34(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_4a66cb34(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_4a66cb34_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_4a66cb34_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_4a66cb34(p0, p1, p2, p3), exec_opts)
  end

  def log_4b5c4277_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: :string}, %{name: "p1", type: :string}]
    }
  end

  def encode_log_4b5c4277(p0, p1) do
    ABI.encode(log_4b5c4277_selector(), [p0, p1])
  end

  def prepare_log_4b5c4277(contract, p0, p1, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_4b5c4277(p0, p1), opts)
  end

  def build_trx_log_4b5c4277(contract, p0, p1) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_4b5c4277(p0, p1)}
  end

  def call_log_4b5c4277(contract, p0, p1, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_4b5c4277(contract, p0, p1), opts)
  end

  def estimate_gas_log_4b5c4277(contract, p0, p1, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_4b5c4277(contract, p0, p1), opts)
  end

  def execute_log_4b5c4277(contract, p0, p1, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_4b5c4277(p0, p1), opts)
  end

  def decode_log_4b5c4277_call(<<75, 92, 66, 119>> <> calldata) do
    _signature = hex!("0x4b5c4277")
    ABI.decode(log_4b5c4277_selector(), calldata)
  end

  def exec_vm_log_4b5c4277(p0, p1, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_4b5c4277(p0, p1), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_4b5c4277_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_4b5c4277_raw(p0, p1, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_4b5c4277(p0, p1), exec_opts)
  end

  def log_4c123d57_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :address},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_4c123d57(p0, p1, p2, p3) do
    ABI.encode(log_4c123d57_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_4c123d57(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_4c123d57(p0, p1, p2, p3), opts)
  end

  def build_trx_log_4c123d57(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_4c123d57(p0, p1, p2, p3)}
  end

  def call_log_4c123d57(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_4c123d57(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_4c123d57(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_4c123d57(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_4c123d57(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_4c123d57(p0, p1, p2, p3), opts)
  end

  def decode_log_4c123d57_call(<<76, 18, 61, 87>> <> calldata) do
    _signature = hex!("0x4c123d57")
    ABI.decode(log_4c123d57_selector(), calldata)
  end

  def exec_vm_log_4c123d57(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_4c123d57(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_4c123d57_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_4c123d57_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_4c123d57(p0, p1, p2, p3), exec_opts)
  end

  def log_4ceda75a_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :string},
        %{name: "p2", type: :bool}
      ]
    }
  end

  def encode_log_4ceda75a(p0, p1, p2) do
    ABI.encode(log_4ceda75a_selector(), [p0, p1, p2])
  end

  def prepare_log_4ceda75a(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_4ceda75a(p0, p1, p2), opts)
  end

  def build_trx_log_4ceda75a(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_4ceda75a(p0, p1, p2)}
  end

  def call_log_4ceda75a(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_4ceda75a(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_4ceda75a(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_4ceda75a(contract, p0, p1, p2), opts)
  end

  def execute_log_4ceda75a(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_4ceda75a(p0, p1, p2), opts)
  end

  def decode_log_4ceda75a_call(<<76, 237, 167, 90>> <> calldata) do
    _signature = hex!("0x4ceda75a")
    ABI.decode(log_4ceda75a_selector(), calldata)
  end

  def exec_vm_log_4ceda75a(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_4ceda75a(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_4ceda75a_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_4ceda75a_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_4ceda75a(p0, p1, p2), exec_opts)
  end

  def log_4f04fdc6_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :address},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_4f04fdc6(p0, p1, p2, p3) do
    ABI.encode(log_4f04fdc6_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_4f04fdc6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_4f04fdc6(p0, p1, p2, p3), opts)
  end

  def build_trx_log_4f04fdc6(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_4f04fdc6(p0, p1, p2, p3)}
  end

  def call_log_4f04fdc6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_4f04fdc6(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_4f04fdc6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_4f04fdc6(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_4f04fdc6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_4f04fdc6(p0, p1, p2, p3), opts)
  end

  def decode_log_4f04fdc6_call(<<79, 4, 253, 198>> <> calldata) do
    _signature = hex!("0x4f04fdc6")
    ABI.decode(log_4f04fdc6_selector(), calldata)
  end

  def exec_vm_log_4f04fdc6(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_4f04fdc6(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_4f04fdc6_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_4f04fdc6_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_4f04fdc6(p0, p1, p2, p3), exec_opts)
  end

  def log_50709698_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: :bool}, %{name: "p1", type: :bool}, %{name: "p2", type: :bool}]
    }
  end

  def encode_log_50709698(p0, p1, p2) do
    ABI.encode(log_50709698_selector(), [p0, p1, p2])
  end

  def prepare_log_50709698(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_50709698(p0, p1, p2), opts)
  end

  def build_trx_log_50709698(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_50709698(p0, p1, p2)}
  end

  def call_log_50709698(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_50709698(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_50709698(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_50709698(contract, p0, p1, p2), opts)
  end

  def execute_log_50709698(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_50709698(p0, p1, p2), opts)
  end

  def decode_log_50709698_call(<<80, 112, 150, 152>> <> calldata) do
    _signature = hex!("0x50709698")
    ABI.decode(log_50709698_selector(), calldata)
  end

  def exec_vm_log_50709698(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_50709698(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_50709698_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_50709698_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_50709698(p0, p1, p2), exec_opts)
  end

  def log_50ad461d_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :string},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_50ad461d(p0, p1, p2, p3) do
    ABI.encode(log_50ad461d_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_50ad461d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_50ad461d(p0, p1, p2, p3), opts)
  end

  def build_trx_log_50ad461d(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_50ad461d(p0, p1, p2, p3)}
  end

  def call_log_50ad461d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_50ad461d(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_50ad461d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_50ad461d(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_50ad461d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_50ad461d(p0, p1, p2, p3), opts)
  end

  def decode_log_50ad461d_call(<<80, 173, 70, 29>> <> calldata) do
    _signature = hex!("0x50ad461d")
    ABI.decode(log_50ad461d_selector(), calldata)
  end

  def exec_vm_log_50ad461d(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_50ad461d(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_50ad461d_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_50ad461d_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_50ad461d(p0, p1, p2, p3), exec_opts)
  end

  def log_515e38b6_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :string},
        %{name: "p2", type: :bool},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_515e38b6(p0, p1, p2, p3) do
    ABI.encode(log_515e38b6_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_515e38b6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_515e38b6(p0, p1, p2, p3), opts)
  end

  def build_trx_log_515e38b6(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_515e38b6(p0, p1, p2, p3)}
  end

  def call_log_515e38b6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_515e38b6(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_515e38b6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_515e38b6(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_515e38b6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_515e38b6(p0, p1, p2, p3), opts)
  end

  def decode_log_515e38b6_call(<<81, 94, 56, 182>> <> calldata) do
    _signature = hex!("0x515e38b6")
    ABI.decode(log_515e38b6_selector(), calldata)
  end

  def exec_vm_log_515e38b6(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_515e38b6(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_515e38b6_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_515e38b6_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_515e38b6(p0, p1, p2, p3), exec_opts)
  end

  def log_51973ec9_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: []
    }
  end

  def encode_log_51973ec9() do
    ABI.encode(log_51973ec9_selector(), [])
  end

  def prepare_log_51973ec9(contract, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_51973ec9(), opts)
  end

  def build_trx_log_51973ec9(contract) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_51973ec9()}
  end

  def call_log_51973ec9(contract, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_51973ec9(contract), opts)
  end

  def estimate_gas_log_51973ec9(contract, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_51973ec9(contract), opts)
  end

  def execute_log_51973ec9(contract, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_51973ec9(), opts)
  end

  def decode_log_51973ec9_call(<<81, 151, 62, 201>> <> calldata) do
    _signature = hex!("0x51973ec9")
    ABI.decode(log_51973ec9_selector(), calldata)
  end

  def exec_vm_log_51973ec9(exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_51973ec9(), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_51973ec9_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_51973ec9_raw(exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_51973ec9(), exec_opts)
  end

  def log_51f09ff8_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :address},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_51f09ff8(p0, p1, p2, p3) do
    ABI.encode(log_51f09ff8_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_51f09ff8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_51f09ff8(p0, p1, p2, p3), opts)
  end

  def build_trx_log_51f09ff8(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_51f09ff8(p0, p1, p2, p3)}
  end

  def call_log_51f09ff8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_51f09ff8(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_51f09ff8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_51f09ff8(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_51f09ff8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_51f09ff8(p0, p1, p2, p3), opts)
  end

  def decode_log_51f09ff8_call(<<81, 240, 159, 248>> <> calldata) do
    _signature = hex!("0x51f09ff8")
    ABI.decode(log_51f09ff8_selector(), calldata)
  end

  def exec_vm_log_51f09ff8(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_51f09ff8(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_51f09ff8_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_51f09ff8_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_51f09ff8(p0, p1, p2, p3), exec_opts)
  end

  def log_538e06ab_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :string},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_538e06ab(p0, p1, p2, p3) do
    ABI.encode(log_538e06ab_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_538e06ab(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_538e06ab(p0, p1, p2, p3), opts)
  end

  def build_trx_log_538e06ab(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_538e06ab(p0, p1, p2, p3)}
  end

  def call_log_538e06ab(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_538e06ab(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_538e06ab(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_538e06ab(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_538e06ab(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_538e06ab(p0, p1, p2, p3), opts)
  end

  def decode_log_538e06ab_call(<<83, 142, 6, 171>> <> calldata) do
    _signature = hex!("0x538e06ab")
    ABI.decode(log_538e06ab_selector(), calldata)
  end

  def exec_vm_log_538e06ab(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_538e06ab(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_538e06ab_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_538e06ab_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_538e06ab(p0, p1, p2, p3), exec_opts)
  end

  def log_54a7a9a0_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :bool},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_54a7a9a0(p0, p1, p2, p3) do
    ABI.encode(log_54a7a9a0_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_54a7a9a0(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_54a7a9a0(p0, p1, p2, p3), opts)
  end

  def build_trx_log_54a7a9a0(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_54a7a9a0(p0, p1, p2, p3)}
  end

  def call_log_54a7a9a0(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_54a7a9a0(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_54a7a9a0(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_54a7a9a0(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_54a7a9a0(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_54a7a9a0(p0, p1, p2, p3), opts)
  end

  def decode_log_54a7a9a0_call(<<84, 167, 169, 160>> <> calldata) do
    _signature = hex!("0x54a7a9a0")
    ABI.decode(log_54a7a9a0_selector(), calldata)
  end

  def exec_vm_log_54a7a9a0(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_54a7a9a0(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_54a7a9a0_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_54a7a9a0_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_54a7a9a0(p0, p1, p2, p3), exec_opts)
  end

  def log_56a5d1b1_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :address},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_56a5d1b1(p0, p1, p2, p3) do
    ABI.encode(log_56a5d1b1_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_56a5d1b1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_56a5d1b1(p0, p1, p2, p3), opts)
  end

  def build_trx_log_56a5d1b1(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_56a5d1b1(p0, p1, p2, p3)}
  end

  def call_log_56a5d1b1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_56a5d1b1(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_56a5d1b1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_56a5d1b1(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_56a5d1b1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_56a5d1b1(p0, p1, p2, p3), opts)
  end

  def decode_log_56a5d1b1_call(<<86, 165, 209, 177>> <> calldata) do
    _signature = hex!("0x56a5d1b1")
    ABI.decode(log_56a5d1b1_selector(), calldata)
  end

  def exec_vm_log_56a5d1b1(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_56a5d1b1(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_56a5d1b1_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_56a5d1b1_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_56a5d1b1(p0, p1, p2, p3), exec_opts)
  end

  def log_5821efa1_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :string},
        %{name: "p2", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_5821efa1(p0, p1, p2) do
    ABI.encode(log_5821efa1_selector(), [p0, p1, p2])
  end

  def prepare_log_5821efa1(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_5821efa1(p0, p1, p2), opts)
  end

  def build_trx_log_5821efa1(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_5821efa1(p0, p1, p2)}
  end

  def call_log_5821efa1(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_5821efa1(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_5821efa1(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_5821efa1(contract, p0, p1, p2), opts)
  end

  def execute_log_5821efa1(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_5821efa1(p0, p1, p2), opts)
  end

  def decode_log_5821efa1_call(<<88, 33, 239, 161>> <> calldata) do
    _signature = hex!("0x5821efa1")
    ABI.decode(log_5821efa1_selector(), calldata)
  end

  def exec_vm_log_5821efa1(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_5821efa1(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_5821efa1_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_5821efa1_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_5821efa1(p0, p1, p2), exec_opts)
  end

  def log_5970e089_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :string}
      ]
    }
  end

  def encode_log_5970e089(p0, p1, p2) do
    ABI.encode(log_5970e089_selector(), [p0, p1, p2])
  end

  def prepare_log_5970e089(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_5970e089(p0, p1, p2), opts)
  end

  def build_trx_log_5970e089(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_5970e089(p0, p1, p2)}
  end

  def call_log_5970e089(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_5970e089(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_5970e089(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_5970e089(contract, p0, p1, p2), opts)
  end

  def execute_log_5970e089(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_5970e089(p0, p1, p2), opts)
  end

  def decode_log_5970e089_call(<<89, 112, 224, 137>> <> calldata) do
    _signature = hex!("0x5970e089")
    ABI.decode(log_5970e089_selector(), calldata)
  end

  def exec_vm_log_5970e089(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_5970e089(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_5970e089_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_5970e089_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_5970e089(p0, p1, p2), exec_opts)
  end

  def log_59cfcbe3_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_59cfcbe3(p0, p1, p2, p3) do
    ABI.encode(log_59cfcbe3_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_59cfcbe3(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_59cfcbe3(p0, p1, p2, p3), opts)
  end

  def build_trx_log_59cfcbe3(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_59cfcbe3(p0, p1, p2, p3)}
  end

  def call_log_59cfcbe3(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_59cfcbe3(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_59cfcbe3(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_59cfcbe3(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_59cfcbe3(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_59cfcbe3(p0, p1, p2, p3), opts)
  end

  def decode_log_59cfcbe3_call(<<89, 207, 203, 227>> <> calldata) do
    _signature = hex!("0x59cfcbe3")
    ABI.decode(log_59cfcbe3_selector(), calldata)
  end

  def exec_vm_log_59cfcbe3(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_59cfcbe3(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_59cfcbe3_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_59cfcbe3_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_59cfcbe3(p0, p1, p2, p3), exec_opts)
  end

  def log_5a477632_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :address},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_5a477632(p0, p1, p2, p3) do
    ABI.encode(log_5a477632_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_5a477632(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_5a477632(p0, p1, p2, p3), opts)
  end

  def build_trx_log_5a477632(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_5a477632(p0, p1, p2, p3)}
  end

  def call_log_5a477632(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_5a477632(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_5a477632(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_5a477632(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_5a477632(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_5a477632(p0, p1, p2, p3), opts)
  end

  def decode_log_5a477632_call(<<90, 71, 118, 50>> <> calldata) do
    _signature = hex!("0x5a477632")
    ABI.decode(log_5a477632_selector(), calldata)
  end

  def exec_vm_log_5a477632(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_5a477632(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_5a477632_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_5a477632_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_5a477632(p0, p1, p2, p3), exec_opts)
  end

  def log_5a9b5ed5_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :address},
        %{name: "p2", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_5a9b5ed5(p0, p1, p2) do
    ABI.encode(log_5a9b5ed5_selector(), [p0, p1, p2])
  end

  def prepare_log_5a9b5ed5(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_5a9b5ed5(p0, p1, p2), opts)
  end

  def build_trx_log_5a9b5ed5(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_5a9b5ed5(p0, p1, p2)}
  end

  def call_log_5a9b5ed5(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_5a9b5ed5(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_5a9b5ed5(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_5a9b5ed5(contract, p0, p1, p2), opts)
  end

  def execute_log_5a9b5ed5(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_5a9b5ed5(p0, p1, p2), opts)
  end

  def decode_log_5a9b5ed5_call(<<90, 155, 94, 213>> <> calldata) do
    _signature = hex!("0x5a9b5ed5")
    ABI.decode(log_5a9b5ed5_selector(), calldata)
  end

  def exec_vm_log_5a9b5ed5(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_5a9b5ed5(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_5a9b5ed5_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_5a9b5ed5_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_5a9b5ed5(p0, p1, p2), exec_opts)
  end

  def log_5ab84e1f_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :string},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_5ab84e1f(p0, p1, p2, p3) do
    ABI.encode(log_5ab84e1f_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_5ab84e1f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_5ab84e1f(p0, p1, p2, p3), opts)
  end

  def build_trx_log_5ab84e1f(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_5ab84e1f(p0, p1, p2, p3)}
  end

  def call_log_5ab84e1f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_5ab84e1f(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_5ab84e1f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_5ab84e1f(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_5ab84e1f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_5ab84e1f(p0, p1, p2, p3), opts)
  end

  def decode_log_5ab84e1f_call(<<90, 184, 78, 31>> <> calldata) do
    _signature = hex!("0x5ab84e1f")
    ABI.decode(log_5ab84e1f_selector(), calldata)
  end

  def exec_vm_log_5ab84e1f(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_5ab84e1f(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_5ab84e1f_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_5ab84e1f_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_5ab84e1f(p0, p1, p2, p3), exec_opts)
  end

  def log_5abd992a_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :address},
        %{name: "p2", type: :bool},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_5abd992a(p0, p1, p2, p3) do
    ABI.encode(log_5abd992a_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_5abd992a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_5abd992a(p0, p1, p2, p3), opts)
  end

  def build_trx_log_5abd992a(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_5abd992a(p0, p1, p2, p3)}
  end

  def call_log_5abd992a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_5abd992a(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_5abd992a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_5abd992a(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_5abd992a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_5abd992a(p0, p1, p2, p3), opts)
  end

  def decode_log_5abd992a_call(<<90, 189, 153, 42>> <> calldata) do
    _signature = hex!("0x5abd992a")
    ABI.decode(log_5abd992a_selector(), calldata)
  end

  def exec_vm_log_5abd992a(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_5abd992a(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_5abd992a_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_5abd992a_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_5abd992a(p0, p1, p2, p3), exec_opts)
  end

  def log_5c430d47_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :string},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_5c430d47(p0, p1, p2, p3) do
    ABI.encode(log_5c430d47_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_5c430d47(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_5c430d47(p0, p1, p2, p3), opts)
  end

  def build_trx_log_5c430d47(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_5c430d47(p0, p1, p2, p3)}
  end

  def call_log_5c430d47(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_5c430d47(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_5c430d47(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_5c430d47(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_5c430d47(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_5c430d47(p0, p1, p2, p3), opts)
  end

  def decode_log_5c430d47_call(<<92, 67, 13, 71>> <> calldata) do
    _signature = hex!("0x5c430d47")
    ABI.decode(log_5c430d47_selector(), calldata)
  end

  def exec_vm_log_5c430d47(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_5c430d47(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_5c430d47_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_5c430d47_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_5c430d47(p0, p1, p2, p3), exec_opts)
  end

  def log_5c96b331_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :address}
      ]
    }
  end

  def encode_log_5c96b331(p0, p1, p2) do
    ABI.encode(log_5c96b331_selector(), [p0, p1, p2])
  end

  def prepare_log_5c96b331(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_5c96b331(p0, p1, p2), opts)
  end

  def build_trx_log_5c96b331(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_5c96b331(p0, p1, p2)}
  end

  def call_log_5c96b331(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_5c96b331(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_5c96b331(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_5c96b331(contract, p0, p1, p2), opts)
  end

  def execute_log_5c96b331(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_5c96b331(p0, p1, p2), opts)
  end

  def decode_log_5c96b331_call(<<92, 150, 179, 49>> <> calldata) do
    _signature = hex!("0x5c96b331")
    ABI.decode(log_5c96b331_selector(), calldata)
  end

  def exec_vm_log_5c96b331(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_5c96b331(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_5c96b331_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_5c96b331_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_5c96b331(p0, p1, p2), exec_opts)
  end

  def log_5ccd4e37_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :string},
        %{name: "p2", type: :address},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_5ccd4e37(p0, p1, p2, p3) do
    ABI.encode(log_5ccd4e37_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_5ccd4e37(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_5ccd4e37(p0, p1, p2, p3), opts)
  end

  def build_trx_log_5ccd4e37(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_5ccd4e37(p0, p1, p2, p3)}
  end

  def call_log_5ccd4e37(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_5ccd4e37(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_5ccd4e37(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_5ccd4e37(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_5ccd4e37(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_5ccd4e37(p0, p1, p2, p3), opts)
  end

  def decode_log_5ccd4e37_call(<<92, 205, 78, 55>> <> calldata) do
    _signature = hex!("0x5ccd4e37")
    ABI.decode(log_5ccd4e37_selector(), calldata)
  end

  def exec_vm_log_5ccd4e37(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_5ccd4e37(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_5ccd4e37_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_5ccd4e37_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_5ccd4e37(p0, p1, p2, p3), exec_opts)
  end

  def log_5d02c50b_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :string},
        %{name: "p2", type: :string},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_5d02c50b(p0, p1, p2, p3) do
    ABI.encode(log_5d02c50b_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_5d02c50b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_5d02c50b(p0, p1, p2, p3), opts)
  end

  def build_trx_log_5d02c50b(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_5d02c50b(p0, p1, p2, p3)}
  end

  def call_log_5d02c50b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_5d02c50b(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_5d02c50b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_5d02c50b(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_5d02c50b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_5d02c50b(p0, p1, p2, p3), opts)
  end

  def decode_log_5d02c50b_call(<<93, 2, 197, 11>> <> calldata) do
    _signature = hex!("0x5d02c50b")
    ABI.decode(log_5d02c50b_selector(), calldata)
  end

  def exec_vm_log_5d02c50b(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_5d02c50b(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_5d02c50b_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_5d02c50b_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_5d02c50b(p0, p1, p2, p3), exec_opts)
  end

  def log_5d08bb05_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :address},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_5d08bb05(p0, p1, p2, p3) do
    ABI.encode(log_5d08bb05_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_5d08bb05(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_5d08bb05(p0, p1, p2, p3), opts)
  end

  def build_trx_log_5d08bb05(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_5d08bb05(p0, p1, p2, p3)}
  end

  def call_log_5d08bb05(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_5d08bb05(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_5d08bb05(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_5d08bb05(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_5d08bb05(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_5d08bb05(p0, p1, p2, p3), opts)
  end

  def decode_log_5d08bb05_call(<<93, 8, 187, 5>> <> calldata) do
    _signature = hex!("0x5d08bb05")
    ABI.decode(log_5d08bb05_selector(), calldata)
  end

  def exec_vm_log_5d08bb05(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_5d08bb05(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_5d08bb05_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_5d08bb05_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_5d08bb05(p0, p1, p2, p3), exec_opts)
  end

  def log_5d1a971a_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :string},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_5d1a971a(p0, p1, p2, p3) do
    ABI.encode(log_5d1a971a_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_5d1a971a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_5d1a971a(p0, p1, p2, p3), opts)
  end

  def build_trx_log_5d1a971a(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_5d1a971a(p0, p1, p2, p3)}
  end

  def call_log_5d1a971a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_5d1a971a(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_5d1a971a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_5d1a971a(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_5d1a971a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_5d1a971a(p0, p1, p2, p3), opts)
  end

  def decode_log_5d1a971a_call(<<93, 26, 151, 26>> <> calldata) do
    _signature = hex!("0x5d1a971a")
    ABI.decode(log_5d1a971a_selector(), calldata)
  end

  def exec_vm_log_5d1a971a(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_5d1a971a(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_5d1a971a_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_5d1a971a_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_5d1a971a(p0, p1, p2, p3), exec_opts)
  end

  def log_5da297eb_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :string},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_5da297eb(p0, p1, p2, p3) do
    ABI.encode(log_5da297eb_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_5da297eb(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_5da297eb(p0, p1, p2, p3), opts)
  end

  def build_trx_log_5da297eb(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_5da297eb(p0, p1, p2, p3)}
  end

  def call_log_5da297eb(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_5da297eb(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_5da297eb(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_5da297eb(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_5da297eb(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_5da297eb(p0, p1, p2, p3), opts)
  end

  def decode_log_5da297eb_call(<<93, 162, 151, 235>> <> calldata) do
    _signature = hex!("0x5da297eb")
    ABI.decode(log_5da297eb_selector(), calldata)
  end

  def exec_vm_log_5da297eb(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_5da297eb(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_5da297eb_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_5da297eb_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_5da297eb(p0, p1, p2, p3), exec_opts)
  end

  def log_5e84b0ea_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :string},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_5e84b0ea(p0, p1, p2, p3) do
    ABI.encode(log_5e84b0ea_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_5e84b0ea(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_5e84b0ea(p0, p1, p2, p3), opts)
  end

  def build_trx_log_5e84b0ea(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_5e84b0ea(p0, p1, p2, p3)}
  end

  def call_log_5e84b0ea(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_5e84b0ea(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_5e84b0ea(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_5e84b0ea(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_5e84b0ea(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_5e84b0ea(p0, p1, p2, p3), opts)
  end

  def decode_log_5e84b0ea_call(<<94, 132, 176, 234>> <> calldata) do
    _signature = hex!("0x5e84b0ea")
    ABI.decode(log_5e84b0ea_selector(), calldata)
  end

  def exec_vm_log_5e84b0ea(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_5e84b0ea(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_5e84b0ea_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_5e84b0ea_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_5e84b0ea(p0, p1, p2, p3), exec_opts)
  end

  def log_5ea2b7ae_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :address},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_5ea2b7ae(p0, p1, p2, p3) do
    ABI.encode(log_5ea2b7ae_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_5ea2b7ae(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_5ea2b7ae(p0, p1, p2, p3), opts)
  end

  def build_trx_log_5ea2b7ae(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_5ea2b7ae(p0, p1, p2, p3)}
  end

  def call_log_5ea2b7ae(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_5ea2b7ae(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_5ea2b7ae(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_5ea2b7ae(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_5ea2b7ae(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_5ea2b7ae(p0, p1, p2, p3), opts)
  end

  def decode_log_5ea2b7ae_call(<<94, 162, 183, 174>> <> calldata) do
    _signature = hex!("0x5ea2b7ae")
    ABI.decode(log_5ea2b7ae_selector(), calldata)
  end

  def exec_vm_log_5ea2b7ae(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_5ea2b7ae(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_5ea2b7ae_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_5ea2b7ae_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_5ea2b7ae(p0, p1, p2, p3), exec_opts)
  end

  def log_5f15d28c_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :address},
        %{name: "p2", type: :string},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_5f15d28c(p0, p1, p2, p3) do
    ABI.encode(log_5f15d28c_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_5f15d28c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_5f15d28c(p0, p1, p2, p3), opts)
  end

  def build_trx_log_5f15d28c(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_5f15d28c(p0, p1, p2, p3)}
  end

  def call_log_5f15d28c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_5f15d28c(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_5f15d28c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_5f15d28c(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_5f15d28c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_5f15d28c(p0, p1, p2, p3), opts)
  end

  def decode_log_5f15d28c_call(<<95, 21, 210, 140>> <> calldata) do
    _signature = hex!("0x5f15d28c")
    ABI.decode(log_5f15d28c_selector(), calldata)
  end

  def exec_vm_log_5f15d28c(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_5f15d28c(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_5f15d28c_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_5f15d28c_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_5f15d28c(p0, p1, p2, p3), exec_opts)
  end

  def log_5f1d5c9f_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :string},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_5f1d5c9f(p0, p1, p2, p3) do
    ABI.encode(log_5f1d5c9f_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_5f1d5c9f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_5f1d5c9f(p0, p1, p2, p3), opts)
  end

  def build_trx_log_5f1d5c9f(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_5f1d5c9f(p0, p1, p2, p3)}
  end

  def call_log_5f1d5c9f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_5f1d5c9f(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_5f1d5c9f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_5f1d5c9f(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_5f1d5c9f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_5f1d5c9f(p0, p1, p2, p3), opts)
  end

  def decode_log_5f1d5c9f_call(<<95, 29, 92, 159>> <> calldata) do
    _signature = hex!("0x5f1d5c9f")
    ABI.decode(log_5f1d5c9f_selector(), calldata)
  end

  def exec_vm_log_5f1d5c9f(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_5f1d5c9f(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_5f1d5c9f_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_5f1d5c9f_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_5f1d5c9f(p0, p1, p2, p3), exec_opts)
  end

  def log_5f743a7c_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :address},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_5f743a7c(p0, p1, p2, p3) do
    ABI.encode(log_5f743a7c_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_5f743a7c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_5f743a7c(p0, p1, p2, p3), opts)
  end

  def build_trx_log_5f743a7c(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_5f743a7c(p0, p1, p2, p3)}
  end

  def call_log_5f743a7c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_5f743a7c(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_5f743a7c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_5f743a7c(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_5f743a7c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_5f743a7c(p0, p1, p2, p3), opts)
  end

  def decode_log_5f743a7c_call(<<95, 116, 58, 124>> <> calldata) do
    _signature = hex!("0x5f743a7c")
    ABI.decode(log_5f743a7c_selector(), calldata)
  end

  def exec_vm_log_5f743a7c(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_5f743a7c(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_5f743a7c_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_5f743a7c_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_5f743a7c(p0, p1, p2, p3), exec_opts)
  end

  def log_5f7b9afb_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :address},
        %{name: "p2", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_5f7b9afb(p0, p1, p2) do
    ABI.encode(log_5f7b9afb_selector(), [p0, p1, p2])
  end

  def prepare_log_5f7b9afb(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_5f7b9afb(p0, p1, p2), opts)
  end

  def build_trx_log_5f7b9afb(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_5f7b9afb(p0, p1, p2)}
  end

  def call_log_5f7b9afb(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_5f7b9afb(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_5f7b9afb(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_5f7b9afb(contract, p0, p1, p2), opts)
  end

  def execute_log_5f7b9afb(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_5f7b9afb(p0, p1, p2), opts)
  end

  def decode_log_5f7b9afb_call(<<95, 123, 154, 251>> <> calldata) do
    _signature = hex!("0x5f7b9afb")
    ABI.decode(log_5f7b9afb_selector(), calldata)
  end

  def exec_vm_log_5f7b9afb(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_5f7b9afb(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_5f7b9afb_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_5f7b9afb_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_5f7b9afb(p0, p1, p2), exec_opts)
  end

  def log_6168ed61_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :string},
        %{name: "p2", type: :address},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_6168ed61(p0, p1, p2, p3) do
    ABI.encode(log_6168ed61_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_6168ed61(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_6168ed61(p0, p1, p2, p3), opts)
  end

  def build_trx_log_6168ed61(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_6168ed61(p0, p1, p2, p3)}
  end

  def call_log_6168ed61(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_6168ed61(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_6168ed61(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_6168ed61(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_6168ed61(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_6168ed61(p0, p1, p2, p3), opts)
  end

  def decode_log_6168ed61_call(<<97, 104, 237, 97>> <> calldata) do
    _signature = hex!("0x6168ed61")
    ABI.decode(log_6168ed61_selector(), calldata)
  end

  def exec_vm_log_6168ed61(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_6168ed61(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_6168ed61_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_6168ed61_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_6168ed61(p0, p1, p2, p3), exec_opts)
  end

  def log_619e4d0e_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :bool},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_619e4d0e(p0, p1, p2, p3) do
    ABI.encode(log_619e4d0e_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_619e4d0e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_619e4d0e(p0, p1, p2, p3), opts)
  end

  def build_trx_log_619e4d0e(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_619e4d0e(p0, p1, p2, p3)}
  end

  def call_log_619e4d0e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_619e4d0e(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_619e4d0e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_619e4d0e(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_619e4d0e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_619e4d0e(p0, p1, p2, p3), opts)
  end

  def decode_log_619e4d0e_call(<<97, 158, 77, 14>> <> calldata) do
    _signature = hex!("0x619e4d0e")
    ABI.decode(log_619e4d0e_selector(), calldata)
  end

  def exec_vm_log_619e4d0e(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_619e4d0e(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_619e4d0e_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_619e4d0e_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_619e4d0e(p0, p1, p2, p3), exec_opts)
  end

  def log_63183678_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :string},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_63183678(p0, p1, p2, p3) do
    ABI.encode(log_63183678_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_63183678(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_63183678(p0, p1, p2, p3), opts)
  end

  def build_trx_log_63183678(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_63183678(p0, p1, p2, p3)}
  end

  def call_log_63183678(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_63183678(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_63183678(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_63183678(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_63183678(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_63183678(p0, p1, p2, p3), opts)
  end

  def decode_log_63183678_call(<<99, 24, 54, 120>> <> calldata) do
    _signature = hex!("0x63183678")
    ABI.decode(log_63183678_selector(), calldata)
  end

  def exec_vm_log_63183678(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_63183678(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_63183678_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_63183678_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_63183678(p0, p1, p2, p3), exec_opts)
  end

  def log_63cb41f9_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :address},
        %{name: "p2", type: :string}
      ]
    }
  end

  def encode_log_63cb41f9(p0, p1, p2) do
    ABI.encode(log_63cb41f9_selector(), [p0, p1, p2])
  end

  def prepare_log_63cb41f9(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_63cb41f9(p0, p1, p2), opts)
  end

  def build_trx_log_63cb41f9(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_63cb41f9(p0, p1, p2)}
  end

  def call_log_63cb41f9(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_63cb41f9(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_63cb41f9(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_63cb41f9(contract, p0, p1, p2), opts)
  end

  def execute_log_63cb41f9(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_63cb41f9(p0, p1, p2), opts)
  end

  def decode_log_63cb41f9_call(<<99, 203, 65, 249>> <> calldata) do
    _signature = hex!("0x63cb41f9")
    ABI.decode(log_63cb41f9_selector(), calldata)
  end

  def exec_vm_log_63cb41f9(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_63cb41f9(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_63cb41f9_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_63cb41f9_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_63cb41f9(p0, p1, p2), exec_opts)
  end

  def log_63fb8bc5_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :address},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_63fb8bc5(p0, p1, p2, p3) do
    ABI.encode(log_63fb8bc5_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_63fb8bc5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_63fb8bc5(p0, p1, p2, p3), opts)
  end

  def build_trx_log_63fb8bc5(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_63fb8bc5(p0, p1, p2, p3)}
  end

  def call_log_63fb8bc5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_63fb8bc5(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_63fb8bc5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_63fb8bc5(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_63fb8bc5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_63fb8bc5(p0, p1, p2, p3), opts)
  end

  def decode_log_63fb8bc5_call(<<99, 251, 139, 197>> <> calldata) do
    _signature = hex!("0x63fb8bc5")
    ABI.decode(log_63fb8bc5_selector(), calldata)
  end

  def exec_vm_log_63fb8bc5(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_63fb8bc5(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_63fb8bc5_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_63fb8bc5_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_63fb8bc5(p0, p1, p2, p3), exec_opts)
  end

  def log_643fd0df_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:uint, 256}}, %{name: "p1", type: :string}]
    }
  end

  def encode_log_643fd0df(p0, p1) do
    ABI.encode(log_643fd0df_selector(), [p0, p1])
  end

  def prepare_log_643fd0df(contract, p0, p1, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_643fd0df(p0, p1), opts)
  end

  def build_trx_log_643fd0df(contract, p0, p1) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_643fd0df(p0, p1)}
  end

  def call_log_643fd0df(contract, p0, p1, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_643fd0df(contract, p0, p1), opts)
  end

  def estimate_gas_log_643fd0df(contract, p0, p1, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_643fd0df(contract, p0, p1), opts)
  end

  def execute_log_643fd0df(contract, p0, p1, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_643fd0df(p0, p1), opts)
  end

  def decode_log_643fd0df_call(<<100, 63, 208, 223>> <> calldata) do
    _signature = hex!("0x643fd0df")
    ABI.decode(log_643fd0df_selector(), calldata)
  end

  def exec_vm_log_643fd0df(p0, p1, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_643fd0df(p0, p1), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_643fd0df_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_643fd0df_raw(p0, p1, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_643fd0df(p0, p1), exec_opts)
  end

  def log_64b5bb67_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :bool},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_64b5bb67(p0, p1, p2, p3) do
    ABI.encode(log_64b5bb67_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_64b5bb67(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_64b5bb67(p0, p1, p2, p3), opts)
  end

  def build_trx_log_64b5bb67(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_64b5bb67(p0, p1, p2, p3)}
  end

  def call_log_64b5bb67(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_64b5bb67(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_64b5bb67(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_64b5bb67(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_64b5bb67(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_64b5bb67(p0, p1, p2, p3), opts)
  end

  def decode_log_64b5bb67_call(<<100, 181, 187, 103>> <> calldata) do
    _signature = hex!("0x64b5bb67")
    ABI.decode(log_64b5bb67_selector(), calldata)
  end

  def exec_vm_log_64b5bb67(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_64b5bb67(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_64b5bb67_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_64b5bb67_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_64b5bb67(p0, p1, p2, p3), exec_opts)
  end

  def log_660375dd_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :address},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_660375dd(p0, p1, p2, p3) do
    ABI.encode(log_660375dd_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_660375dd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_660375dd(p0, p1, p2, p3), opts)
  end

  def build_trx_log_660375dd(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_660375dd(p0, p1, p2, p3)}
  end

  def call_log_660375dd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_660375dd(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_660375dd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_660375dd(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_660375dd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_660375dd(p0, p1, p2, p3), opts)
  end

  def decode_log_660375dd_call(<<102, 3, 117, 221>> <> calldata) do
    _signature = hex!("0x660375dd")
    ABI.decode(log_660375dd_selector(), calldata)
  end

  def exec_vm_log_660375dd(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_660375dd(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_660375dd_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_660375dd_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_660375dd(p0, p1, p2, p3), exec_opts)
  end

  def log_665bf134_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :address},
        %{name: "p2", type: :address},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_665bf134(p0, p1, p2, p3) do
    ABI.encode(log_665bf134_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_665bf134(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_665bf134(p0, p1, p2, p3), opts)
  end

  def build_trx_log_665bf134(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_665bf134(p0, p1, p2, p3)}
  end

  def call_log_665bf134(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_665bf134(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_665bf134(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_665bf134(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_665bf134(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_665bf134(p0, p1, p2, p3), opts)
  end

  def decode_log_665bf134_call(<<102, 91, 241, 52>> <> calldata) do
    _signature = hex!("0x665bf134")
    ABI.decode(log_665bf134_selector(), calldata)
  end

  def exec_vm_log_665bf134(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_665bf134(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_665bf134_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_665bf134_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_665bf134(p0, p1, p2, p3), exec_opts)
  end

  def log_66f1bc67_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_66f1bc67(p0, p1, p2, p3) do
    ABI.encode(log_66f1bc67_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_66f1bc67(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_66f1bc67(p0, p1, p2, p3), opts)
  end

  def build_trx_log_66f1bc67(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_66f1bc67(p0, p1, p2, p3)}
  end

  def call_log_66f1bc67(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_66f1bc67(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_66f1bc67(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_66f1bc67(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_66f1bc67(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_66f1bc67(p0, p1, p2, p3), opts)
  end

  def decode_log_66f1bc67_call(<<102, 241, 188, 103>> <> calldata) do
    _signature = hex!("0x66f1bc67")
    ABI.decode(log_66f1bc67_selector(), calldata)
  end

  def exec_vm_log_66f1bc67(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_66f1bc67(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_66f1bc67_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_66f1bc67_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_66f1bc67(p0, p1, p2, p3), exec_opts)
  end

  def log_678209a8_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :bool}
      ]
    }
  end

  def encode_log_678209a8(p0, p1, p2) do
    ABI.encode(log_678209a8_selector(), [p0, p1, p2])
  end

  def prepare_log_678209a8(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_678209a8(p0, p1, p2), opts)
  end

  def build_trx_log_678209a8(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_678209a8(p0, p1, p2)}
  end

  def call_log_678209a8(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_678209a8(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_678209a8(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_678209a8(contract, p0, p1, p2), opts)
  end

  def execute_log_678209a8(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_678209a8(p0, p1, p2), opts)
  end

  def decode_log_678209a8_call(<<103, 130, 9, 168>> <> calldata) do
    _signature = hex!("0x678209a8")
    ABI.decode(log_678209a8_selector(), calldata)
  end

  def exec_vm_log_678209a8(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_678209a8(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_678209a8_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_678209a8_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_678209a8(p0, p1, p2), exec_opts)
  end

  def log_67dd6ff1_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :string},
        %{name: "p2", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_67dd6ff1(p0, p1, p2) do
    ABI.encode(log_67dd6ff1_selector(), [p0, p1, p2])
  end

  def prepare_log_67dd6ff1(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_67dd6ff1(p0, p1, p2), opts)
  end

  def build_trx_log_67dd6ff1(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_67dd6ff1(p0, p1, p2)}
  end

  def call_log_67dd6ff1(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_67dd6ff1(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_67dd6ff1(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_67dd6ff1(contract, p0, p1, p2), opts)
  end

  def execute_log_67dd6ff1(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_67dd6ff1(p0, p1, p2), opts)
  end

  def decode_log_67dd6ff1_call(<<103, 221, 111, 241>> <> calldata) do
    _signature = hex!("0x67dd6ff1")
    ABI.decode(log_67dd6ff1_selector(), calldata)
  end

  def exec_vm_log_67dd6ff1(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_67dd6ff1(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_67dd6ff1_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_67dd6ff1_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_67dd6ff1(p0, p1, p2), exec_opts)
  end

  def log_68c8b8bd_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :string},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_68c8b8bd(p0, p1, p2, p3) do
    ABI.encode(log_68c8b8bd_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_68c8b8bd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_68c8b8bd(p0, p1, p2, p3), opts)
  end

  def build_trx_log_68c8b8bd(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_68c8b8bd(p0, p1, p2, p3)}
  end

  def call_log_68c8b8bd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_68c8b8bd(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_68c8b8bd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_68c8b8bd(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_68c8b8bd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_68c8b8bd(p0, p1, p2, p3), opts)
  end

  def decode_log_68c8b8bd_call(<<104, 200, 184, 189>> <> calldata) do
    _signature = hex!("0x68c8b8bd")
    ABI.decode(log_68c8b8bd_selector(), calldata)
  end

  def exec_vm_log_68c8b8bd(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_68c8b8bd(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_68c8b8bd_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_68c8b8bd_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_68c8b8bd(p0, p1, p2, p3), exec_opts)
  end

  def log_691a8f74_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :string},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_691a8f74(p0, p1, p2, p3) do
    ABI.encode(log_691a8f74_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_691a8f74(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_691a8f74(p0, p1, p2, p3), opts)
  end

  def build_trx_log_691a8f74(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_691a8f74(p0, p1, p2, p3)}
  end

  def call_log_691a8f74(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_691a8f74(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_691a8f74(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_691a8f74(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_691a8f74(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_691a8f74(p0, p1, p2, p3), opts)
  end

  def decode_log_691a8f74_call(<<105, 26, 143, 116>> <> calldata) do
    _signature = hex!("0x691a8f74")
    ABI.decode(log_691a8f74_selector(), calldata)
  end

  def exec_vm_log_691a8f74(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_691a8f74(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_691a8f74_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_691a8f74_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_691a8f74(p0, p1, p2, p3), exec_opts)
  end

  def log_69276c86_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:uint, 256}}, %{name: "p1", type: :address}]
    }
  end

  def encode_log_69276c86(p0, p1) do
    ABI.encode(log_69276c86_selector(), [p0, p1])
  end

  def prepare_log_69276c86(contract, p0, p1, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_69276c86(p0, p1), opts)
  end

  def build_trx_log_69276c86(contract, p0, p1) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_69276c86(p0, p1)}
  end

  def call_log_69276c86(contract, p0, p1, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_69276c86(contract, p0, p1), opts)
  end

  def estimate_gas_log_69276c86(contract, p0, p1, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_69276c86(contract, p0, p1), opts)
  end

  def execute_log_69276c86(contract, p0, p1, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_69276c86(p0, p1), opts)
  end

  def decode_log_69276c86_call(<<105, 39, 108, 134>> <> calldata) do
    _signature = hex!("0x69276c86")
    ABI.decode(log_69276c86_selector(), calldata)
  end

  def exec_vm_log_69276c86(p0, p1, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_69276c86(p0, p1), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_69276c86_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_69276c86_raw(p0, p1, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_69276c86(p0, p1), exec_opts)
  end

  def log_69640b59_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_69640b59(p0, p1, p2, p3) do
    ABI.encode(log_69640b59_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_69640b59(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_69640b59(p0, p1, p2, p3), opts)
  end

  def build_trx_log_69640b59(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_69640b59(p0, p1, p2, p3)}
  end

  def call_log_69640b59(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_69640b59(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_69640b59(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_69640b59(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_69640b59(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_69640b59(p0, p1, p2, p3), opts)
  end

  def decode_log_69640b59_call(<<105, 100, 11, 89>> <> calldata) do
    _signature = hex!("0x69640b59")
    ABI.decode(log_69640b59_selector(), calldata)
  end

  def exec_vm_log_69640b59(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_69640b59(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_69640b59_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_69640b59_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_69640b59(p0, p1, p2, p3), exec_opts)
  end

  def log_6a1199e2_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :string},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_6a1199e2(p0, p1, p2, p3) do
    ABI.encode(log_6a1199e2_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_6a1199e2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_6a1199e2(p0, p1, p2, p3), opts)
  end

  def build_trx_log_6a1199e2(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_6a1199e2(p0, p1, p2, p3)}
  end

  def call_log_6a1199e2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_6a1199e2(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_6a1199e2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_6a1199e2(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_6a1199e2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_6a1199e2(p0, p1, p2, p3), opts)
  end

  def decode_log_6a1199e2_call(<<106, 17, 153, 226>> <> calldata) do
    _signature = hex!("0x6a1199e2")
    ABI.decode(log_6a1199e2_selector(), calldata)
  end

  def exec_vm_log_6a1199e2(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_6a1199e2(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_6a1199e2_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_6a1199e2_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_6a1199e2(p0, p1, p2, p3), exec_opts)
  end

  def log_6a9c478b_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :address},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_6a9c478b(p0, p1, p2, p3) do
    ABI.encode(log_6a9c478b_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_6a9c478b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_6a9c478b(p0, p1, p2, p3), opts)
  end

  def build_trx_log_6a9c478b(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_6a9c478b(p0, p1, p2, p3)}
  end

  def call_log_6a9c478b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_6a9c478b(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_6a9c478b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_6a9c478b(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_6a9c478b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_6a9c478b(p0, p1, p2, p3), opts)
  end

  def decode_log_6a9c478b_call(<<106, 156, 71, 139>> <> calldata) do
    _signature = hex!("0x6a9c478b")
    ABI.decode(log_6a9c478b_selector(), calldata)
  end

  def exec_vm_log_6a9c478b(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_6a9c478b(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_6a9c478b_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_6a9c478b_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_6a9c478b(p0, p1, p2, p3), exec_opts)
  end

  def log_6b0e5d53_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :string},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_6b0e5d53(p0, p1, p2, p3) do
    ABI.encode(log_6b0e5d53_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_6b0e5d53(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_6b0e5d53(p0, p1, p2, p3), opts)
  end

  def build_trx_log_6b0e5d53(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_6b0e5d53(p0, p1, p2, p3)}
  end

  def call_log_6b0e5d53(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_6b0e5d53(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_6b0e5d53(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_6b0e5d53(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_6b0e5d53(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_6b0e5d53(p0, p1, p2, p3), opts)
  end

  def decode_log_6b0e5d53_call(<<107, 14, 93, 83>> <> calldata) do
    _signature = hex!("0x6b0e5d53")
    ABI.decode(log_6b0e5d53_selector(), calldata)
  end

  def exec_vm_log_6b0e5d53(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_6b0e5d53(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_6b0e5d53_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_6b0e5d53_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_6b0e5d53(p0, p1, p2, p3), exec_opts)
  end

  def log_6cde40b8_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :address},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_6cde40b8(p0, p1, p2, p3) do
    ABI.encode(log_6cde40b8_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_6cde40b8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_6cde40b8(p0, p1, p2, p3), opts)
  end

  def build_trx_log_6cde40b8(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_6cde40b8(p0, p1, p2, p3)}
  end

  def call_log_6cde40b8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_6cde40b8(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_6cde40b8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_6cde40b8(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_6cde40b8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_6cde40b8(p0, p1, p2, p3), opts)
  end

  def decode_log_6cde40b8_call(<<108, 222, 64, 184>> <> calldata) do
    _signature = hex!("0x6cde40b8")
    ABI.decode(log_6cde40b8_selector(), calldata)
  end

  def exec_vm_log_6cde40b8(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_6cde40b8(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_6cde40b8_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_6cde40b8_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_6cde40b8(p0, p1, p2, p3), exec_opts)
  end

  def log_6d1e8751_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :string},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_6d1e8751(p0, p1, p2, p3) do
    ABI.encode(log_6d1e8751_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_6d1e8751(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_6d1e8751(p0, p1, p2, p3), opts)
  end

  def build_trx_log_6d1e8751(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_6d1e8751(p0, p1, p2, p3)}
  end

  def call_log_6d1e8751(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_6d1e8751(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_6d1e8751(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_6d1e8751(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_6d1e8751(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_6d1e8751(p0, p1, p2, p3), opts)
  end

  def decode_log_6d1e8751_call(<<109, 30, 135, 81>> <> calldata) do
    _signature = hex!("0x6d1e8751")
    ABI.decode(log_6d1e8751_selector(), calldata)
  end

  def exec_vm_log_6d1e8751(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_6d1e8751(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_6d1e8751_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_6d1e8751_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_6d1e8751(p0, p1, p2, p3), exec_opts)
  end

  def log_6d572f44_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :string},
        %{name: "p2", type: :string},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_6d572f44(p0, p1, p2, p3) do
    ABI.encode(log_6d572f44_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_6d572f44(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_6d572f44(p0, p1, p2, p3), opts)
  end

  def build_trx_log_6d572f44(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_6d572f44(p0, p1, p2, p3)}
  end

  def call_log_6d572f44(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_6d572f44(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_6d572f44(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_6d572f44(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_6d572f44(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_6d572f44(p0, p1, p2, p3), opts)
  end

  def decode_log_6d572f44_call(<<109, 87, 47, 68>> <> calldata) do
    _signature = hex!("0x6d572f44")
    ABI.decode(log_6d572f44_selector(), calldata)
  end

  def exec_vm_log_6d572f44(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_6d572f44(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_6d572f44_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_6d572f44_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_6d572f44(p0, p1, p2, p3), exec_opts)
  end

  def log_6d7045c1_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :bool},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_6d7045c1(p0, p1, p2, p3) do
    ABI.encode(log_6d7045c1_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_6d7045c1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_6d7045c1(p0, p1, p2, p3), opts)
  end

  def build_trx_log_6d7045c1(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_6d7045c1(p0, p1, p2, p3)}
  end

  def call_log_6d7045c1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_6d7045c1(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_6d7045c1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_6d7045c1(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_6d7045c1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_6d7045c1(p0, p1, p2, p3), opts)
  end

  def decode_log_6d7045c1_call(<<109, 112, 69, 193>> <> calldata) do
    _signature = hex!("0x6d7045c1")
    ABI.decode(log_6d7045c1_selector(), calldata)
  end

  def exec_vm_log_6d7045c1(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_6d7045c1(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_6d7045c1_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_6d7045c1_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_6d7045c1(p0, p1, p2, p3), exec_opts)
  end

  def log_6dd434ca_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :string},
        %{name: "p2", type: :address},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_6dd434ca(p0, p1, p2, p3) do
    ABI.encode(log_6dd434ca_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_6dd434ca(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_6dd434ca(p0, p1, p2, p3), opts)
  end

  def build_trx_log_6dd434ca(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_6dd434ca(p0, p1, p2, p3)}
  end

  def call_log_6dd434ca(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_6dd434ca(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_6dd434ca(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_6dd434ca(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_6dd434ca(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_6dd434ca(p0, p1, p2, p3), opts)
  end

  def decode_log_6dd434ca_call(<<109, 212, 52, 202>> <> calldata) do
    _signature = hex!("0x6dd434ca")
    ABI.decode(log_6dd434ca_selector(), calldata)
  end

  def exec_vm_log_6dd434ca(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_6dd434ca(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_6dd434ca_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_6dd434ca_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_6dd434ca(p0, p1, p2, p3), exec_opts)
  end

  def log_6f1a594e_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :address},
        %{name: "p2", type: :string},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_6f1a594e(p0, p1, p2, p3) do
    ABI.encode(log_6f1a594e_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_6f1a594e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_6f1a594e(p0, p1, p2, p3), opts)
  end

  def build_trx_log_6f1a594e(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_6f1a594e(p0, p1, p2, p3)}
  end

  def call_log_6f1a594e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_6f1a594e(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_6f1a594e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_6f1a594e(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_6f1a594e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_6f1a594e(p0, p1, p2, p3), opts)
  end

  def decode_log_6f1a594e_call(<<111, 26, 89, 78>> <> calldata) do
    _signature = hex!("0x6f1a594e")
    ABI.decode(log_6f1a594e_selector(), calldata)
  end

  def exec_vm_log_6f1a594e(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_6f1a594e(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_6f1a594e_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_6f1a594e_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_6f1a594e(p0, p1, p2, p3), exec_opts)
  end

  def log_6f7c603e_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :address},
        %{name: "p2", type: :string},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_6f7c603e(p0, p1, p2, p3) do
    ABI.encode(log_6f7c603e_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_6f7c603e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_6f7c603e(p0, p1, p2, p3), opts)
  end

  def build_trx_log_6f7c603e(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_6f7c603e(p0, p1, p2, p3)}
  end

  def call_log_6f7c603e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_6f7c603e(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_6f7c603e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_6f7c603e(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_6f7c603e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_6f7c603e(p0, p1, p2, p3), opts)
  end

  def decode_log_6f7c603e_call(<<111, 124, 96, 62>> <> calldata) do
    _signature = hex!("0x6f7c603e")
    ABI.decode(log_6f7c603e_selector(), calldata)
  end

  def exec_vm_log_6f7c603e(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_6f7c603e(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_6f7c603e_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_6f7c603e_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_6f7c603e(p0, p1, p2, p3), exec_opts)
  end

  def log_7190a529_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_7190a529(p0, p1, p2, p3) do
    ABI.encode(log_7190a529_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_7190a529(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_7190a529(p0, p1, p2, p3), opts)
  end

  def build_trx_log_7190a529(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_7190a529(p0, p1, p2, p3)}
  end

  def call_log_7190a529(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_7190a529(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_7190a529(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_7190a529(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_7190a529(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_7190a529(p0, p1, p2, p3), opts)
  end

  def decode_log_7190a529_call(<<113, 144, 165, 41>> <> calldata) do
    _signature = hex!("0x7190a529")
    ABI.decode(log_7190a529_selector(), calldata)
  end

  def exec_vm_log_7190a529(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_7190a529(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_7190a529_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_7190a529_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_7190a529(p0, p1, p2, p3), exec_opts)
  end

  def log_71d04af2_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :string}
      ]
    }
  end

  def encode_log_71d04af2(p0, p1, p2) do
    ABI.encode(log_71d04af2_selector(), [p0, p1, p2])
  end

  def prepare_log_71d04af2(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_71d04af2(p0, p1, p2), opts)
  end

  def build_trx_log_71d04af2(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_71d04af2(p0, p1, p2)}
  end

  def call_log_71d04af2(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_71d04af2(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_71d04af2(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_71d04af2(contract, p0, p1, p2), opts)
  end

  def execute_log_71d04af2(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_71d04af2(p0, p1, p2), opts)
  end

  def decode_log_71d04af2_call(<<113, 208, 74, 242>> <> calldata) do
    _signature = hex!("0x71d04af2")
    ABI.decode(log_71d04af2_selector(), calldata)
  end

  def exec_vm_log_71d04af2(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_71d04af2(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_71d04af2_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_71d04af2_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_71d04af2(p0, p1, p2), exec_opts)
  end

  def log_736efbb6_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :address},
        %{name: "p2", type: :address},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_736efbb6(p0, p1, p2, p3) do
    ABI.encode(log_736efbb6_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_736efbb6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_736efbb6(p0, p1, p2, p3), opts)
  end

  def build_trx_log_736efbb6(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_736efbb6(p0, p1, p2, p3)}
  end

  def call_log_736efbb6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_736efbb6(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_736efbb6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_736efbb6(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_736efbb6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_736efbb6(p0, p1, p2, p3), opts)
  end

  def decode_log_736efbb6_call(<<115, 110, 251, 182>> <> calldata) do
    _signature = hex!("0x736efbb6")
    ABI.decode(log_736efbb6_selector(), calldata)
  end

  def exec_vm_log_736efbb6(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_736efbb6(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_736efbb6_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_736efbb6_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_736efbb6(p0, p1, p2, p3), exec_opts)
  end

  def log_742d6ee7_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :bool},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_742d6ee7(p0, p1, p2, p3) do
    ABI.encode(log_742d6ee7_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_742d6ee7(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_742d6ee7(p0, p1, p2, p3), opts)
  end

  def build_trx_log_742d6ee7(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_742d6ee7(p0, p1, p2, p3)}
  end

  def call_log_742d6ee7(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_742d6ee7(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_742d6ee7(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_742d6ee7(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_742d6ee7(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_742d6ee7(p0, p1, p2, p3), opts)
  end

  def decode_log_742d6ee7_call(<<116, 45, 110, 231>> <> calldata) do
    _signature = hex!("0x742d6ee7")
    ABI.decode(log_742d6ee7_selector(), calldata)
  end

  def exec_vm_log_742d6ee7(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_742d6ee7(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_742d6ee7_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_742d6ee7_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_742d6ee7(p0, p1, p2, p3), exec_opts)
  end

  def log_7464ce23_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :bool},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_7464ce23(p0, p1, p2, p3) do
    ABI.encode(log_7464ce23_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_7464ce23(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_7464ce23(p0, p1, p2, p3), opts)
  end

  def build_trx_log_7464ce23(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_7464ce23(p0, p1, p2, p3)}
  end

  def call_log_7464ce23(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_7464ce23(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_7464ce23(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_7464ce23(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_7464ce23(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_7464ce23(p0, p1, p2, p3), opts)
  end

  def decode_log_7464ce23_call(<<116, 100, 206, 35>> <> calldata) do
    _signature = hex!("0x7464ce23")
    ABI.decode(log_7464ce23_selector(), calldata)
  end

  def exec_vm_log_7464ce23(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_7464ce23(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_7464ce23_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_7464ce23_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_7464ce23(p0, p1, p2, p3), exec_opts)
  end

  def log_759f86bb_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: :address}, %{name: "p1", type: :string}]
    }
  end

  def encode_log_759f86bb(p0, p1) do
    ABI.encode(log_759f86bb_selector(), [p0, p1])
  end

  def prepare_log_759f86bb(contract, p0, p1, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_759f86bb(p0, p1), opts)
  end

  def build_trx_log_759f86bb(contract, p0, p1) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_759f86bb(p0, p1)}
  end

  def call_log_759f86bb(contract, p0, p1, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_759f86bb(contract, p0, p1), opts)
  end

  def estimate_gas_log_759f86bb(contract, p0, p1, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_759f86bb(contract, p0, p1), opts)
  end

  def execute_log_759f86bb(contract, p0, p1, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_759f86bb(p0, p1), opts)
  end

  def decode_log_759f86bb_call(<<117, 159, 134, 187>> <> calldata) do
    _signature = hex!("0x759f86bb")
    ABI.decode(log_759f86bb_selector(), calldata)
  end

  def exec_vm_log_759f86bb(p0, p1, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_759f86bb(p0, p1), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_759f86bb_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_759f86bb_raw(p0, p1, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_759f86bb(p0, p1), exec_opts)
  end

  def log_75b605d3_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: :address}, %{name: "p1", type: :bool}]
    }
  end

  def encode_log_75b605d3(p0, p1) do
    ABI.encode(log_75b605d3_selector(), [p0, p1])
  end

  def prepare_log_75b605d3(contract, p0, p1, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_75b605d3(p0, p1), opts)
  end

  def build_trx_log_75b605d3(contract, p0, p1) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_75b605d3(p0, p1)}
  end

  def call_log_75b605d3(contract, p0, p1, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_75b605d3(contract, p0, p1), opts)
  end

  def estimate_gas_log_75b605d3(contract, p0, p1, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_75b605d3(contract, p0, p1), opts)
  end

  def execute_log_75b605d3(contract, p0, p1, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_75b605d3(p0, p1), opts)
  end

  def decode_log_75b605d3_call(<<117, 182, 5, 211>> <> calldata) do
    _signature = hex!("0x75b605d3")
    ABI.decode(log_75b605d3_selector(), calldata)
  end

  def exec_vm_log_75b605d3(p0, p1, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_75b605d3(p0, p1), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_75b605d3_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_75b605d3_raw(p0, p1, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_75b605d3(p0, p1), exec_opts)
  end

  def log_7626db92_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_7626db92(p0, p1, p2, p3) do
    ABI.encode(log_7626db92_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_7626db92(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_7626db92(p0, p1, p2, p3), opts)
  end

  def build_trx_log_7626db92(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_7626db92(p0, p1, p2, p3)}
  end

  def call_log_7626db92(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_7626db92(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_7626db92(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_7626db92(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_7626db92(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_7626db92(p0, p1, p2, p3), opts)
  end

  def decode_log_7626db92_call(<<118, 38, 219, 146>> <> calldata) do
    _signature = hex!("0x7626db92")
    ABI.decode(log_7626db92_selector(), calldata)
  end

  def exec_vm_log_7626db92(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_7626db92(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_7626db92_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_7626db92_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_7626db92(p0, p1, p2, p3), exec_opts)
  end

  def log_79884c2b_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :address},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_79884c2b(p0, p1, p2, p3) do
    ABI.encode(log_79884c2b_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_79884c2b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_79884c2b(p0, p1, p2, p3), opts)
  end

  def build_trx_log_79884c2b(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_79884c2b(p0, p1, p2, p3)}
  end

  def call_log_79884c2b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_79884c2b(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_79884c2b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_79884c2b(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_79884c2b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_79884c2b(p0, p1, p2, p3), opts)
  end

  def decode_log_79884c2b_call(<<121, 136, 76, 43>> <> calldata) do
    _signature = hex!("0x79884c2b")
    ABI.decode(log_79884c2b_selector(), calldata)
  end

  def exec_vm_log_79884c2b(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_79884c2b(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_79884c2b_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_79884c2b_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_79884c2b(p0, p1, p2, p3), exec_opts)
  end

  def log_7af6ab25_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :string},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_7af6ab25(p0, p1, p2, p3) do
    ABI.encode(log_7af6ab25_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_7af6ab25(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_7af6ab25(p0, p1, p2, p3), opts)
  end

  def build_trx_log_7af6ab25(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_7af6ab25(p0, p1, p2, p3)}
  end

  def call_log_7af6ab25(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_7af6ab25(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_7af6ab25(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_7af6ab25(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_7af6ab25(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_7af6ab25(p0, p1, p2, p3), opts)
  end

  def decode_log_7af6ab25_call(<<122, 246, 171, 37>> <> calldata) do
    _signature = hex!("0x7af6ab25")
    ABI.decode(log_7af6ab25_selector(), calldata)
  end

  def exec_vm_log_7af6ab25(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_7af6ab25(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_7af6ab25_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_7af6ab25_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_7af6ab25(p0, p1, p2, p3), exec_opts)
  end

  def log_7afac959_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :string},
        %{name: "p2", type: :address}
      ]
    }
  end

  def encode_log_7afac959(p0, p1, p2) do
    ABI.encode(log_7afac959_selector(), [p0, p1, p2])
  end

  def prepare_log_7afac959(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_7afac959(p0, p1, p2), opts)
  end

  def build_trx_log_7afac959(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_7afac959(p0, p1, p2)}
  end

  def call_log_7afac959(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_7afac959(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_7afac959(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_7afac959(contract, p0, p1, p2), opts)
  end

  def execute_log_7afac959(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_7afac959(p0, p1, p2), opts)
  end

  def decode_log_7afac959_call(<<122, 250, 201, 89>> <> calldata) do
    _signature = hex!("0x7afac959")
    ABI.decode(log_7afac959_selector(), calldata)
  end

  def exec_vm_log_7afac959(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_7afac959(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_7afac959_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_7afac959_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_7afac959(p0, p1, p2), exec_opts)
  end

  def log_7bc0d848_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :address}
      ]
    }
  end

  def encode_log_7bc0d848(p0, p1, p2) do
    ABI.encode(log_7bc0d848_selector(), [p0, p1, p2])
  end

  def prepare_log_7bc0d848(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_7bc0d848(p0, p1, p2), opts)
  end

  def build_trx_log_7bc0d848(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_7bc0d848(p0, p1, p2)}
  end

  def call_log_7bc0d848(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_7bc0d848(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_7bc0d848(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_7bc0d848(contract, p0, p1, p2), opts)
  end

  def execute_log_7bc0d848(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_7bc0d848(p0, p1, p2), opts)
  end

  def decode_log_7bc0d848_call(<<123, 192, 216, 72>> <> calldata) do
    _signature = hex!("0x7bc0d848")
    ABI.decode(log_7bc0d848_selector(), calldata)
  end

  def exec_vm_log_7bc0d848(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_7bc0d848(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_7bc0d848_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_7bc0d848_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_7bc0d848(p0, p1, p2), exec_opts)
  end

  def log_7be0c3eb_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :string},
        %{name: "p2", type: :string},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_7be0c3eb(p0, p1, p2, p3) do
    ABI.encode(log_7be0c3eb_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_7be0c3eb(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_7be0c3eb(p0, p1, p2, p3), opts)
  end

  def build_trx_log_7be0c3eb(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_7be0c3eb(p0, p1, p2, p3)}
  end

  def call_log_7be0c3eb(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_7be0c3eb(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_7be0c3eb(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_7be0c3eb(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_7be0c3eb(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_7be0c3eb(p0, p1, p2, p3), opts)
  end

  def decode_log_7be0c3eb_call(<<123, 224, 195, 235>> <> calldata) do
    _signature = hex!("0x7be0c3eb")
    ABI.decode(log_7be0c3eb_selector(), calldata)
  end

  def exec_vm_log_7be0c3eb(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_7be0c3eb(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_7be0c3eb_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_7be0c3eb_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_7be0c3eb(p0, p1, p2, p3), exec_opts)
  end

  def log_7bf181a1_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :address},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_7bf181a1(p0, p1, p2, p3) do
    ABI.encode(log_7bf181a1_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_7bf181a1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_7bf181a1(p0, p1, p2, p3), opts)
  end

  def build_trx_log_7bf181a1(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_7bf181a1(p0, p1, p2, p3)}
  end

  def call_log_7bf181a1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_7bf181a1(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_7bf181a1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_7bf181a1(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_7bf181a1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_7bf181a1(p0, p1, p2, p3), opts)
  end

  def decode_log_7bf181a1_call(<<123, 241, 129, 161>> <> calldata) do
    _signature = hex!("0x7bf181a1")
    ABI.decode(log_7bf181a1_selector(), calldata)
  end

  def exec_vm_log_7bf181a1(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_7bf181a1(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_7bf181a1_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_7bf181a1_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_7bf181a1(p0, p1, p2, p3), exec_opts)
  end

  def log_7c4632a4_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :string},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_7c4632a4(p0, p1, p2, p3) do
    ABI.encode(log_7c4632a4_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_7c4632a4(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_7c4632a4(p0, p1, p2, p3), opts)
  end

  def build_trx_log_7c4632a4(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_7c4632a4(p0, p1, p2, p3)}
  end

  def call_log_7c4632a4(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_7c4632a4(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_7c4632a4(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_7c4632a4(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_7c4632a4(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_7c4632a4(p0, p1, p2, p3), opts)
  end

  def decode_log_7c4632a4_call(<<124, 70, 50, 164>> <> calldata) do
    _signature = hex!("0x7c4632a4")
    ABI.decode(log_7c4632a4_selector(), calldata)
  end

  def exec_vm_log_7c4632a4(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_7c4632a4(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_7c4632a4_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_7c4632a4_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_7c4632a4(p0, p1, p2, p3), exec_opts)
  end

  def log_7cc3c607_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :string},
        %{name: "p2", type: :address},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_7cc3c607(p0, p1, p2, p3) do
    ABI.encode(log_7cc3c607_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_7cc3c607(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_7cc3c607(p0, p1, p2, p3), opts)
  end

  def build_trx_log_7cc3c607(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_7cc3c607(p0, p1, p2, p3)}
  end

  def call_log_7cc3c607(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_7cc3c607(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_7cc3c607(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_7cc3c607(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_7cc3c607(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_7cc3c607(p0, p1, p2, p3), opts)
  end

  def decode_log_7cc3c607_call(<<124, 195, 198, 7>> <> calldata) do
    _signature = hex!("0x7cc3c607")
    ABI.decode(log_7cc3c607_selector(), calldata)
  end

  def exec_vm_log_7cc3c607(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_7cc3c607(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_7cc3c607_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_7cc3c607_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_7cc3c607(p0, p1, p2, p3), exec_opts)
  end

  def log_7d24491d_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :string},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_7d24491d(p0, p1, p2, p3) do
    ABI.encode(log_7d24491d_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_7d24491d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_7d24491d(p0, p1, p2, p3), opts)
  end

  def build_trx_log_7d24491d(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_7d24491d(p0, p1, p2, p3)}
  end

  def call_log_7d24491d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_7d24491d(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_7d24491d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_7d24491d(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_7d24491d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_7d24491d(p0, p1, p2, p3), opts)
  end

  def decode_log_7d24491d_call(<<125, 36, 73, 29>> <> calldata) do
    _signature = hex!("0x7d24491d")
    ABI.decode(log_7d24491d_selector(), calldata)
  end

  def exec_vm_log_7d24491d(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_7d24491d(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_7d24491d_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_7d24491d_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_7d24491d(p0, p1, p2, p3), exec_opts)
  end

  def log_7dd4d0e0_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :bool},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_7dd4d0e0(p0, p1, p2, p3) do
    ABI.encode(log_7dd4d0e0_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_7dd4d0e0(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_7dd4d0e0(p0, p1, p2, p3), opts)
  end

  def build_trx_log_7dd4d0e0(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_7dd4d0e0(p0, p1, p2, p3)}
  end

  def call_log_7dd4d0e0(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_7dd4d0e0(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_7dd4d0e0(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_7dd4d0e0(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_7dd4d0e0(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_7dd4d0e0(p0, p1, p2, p3), opts)
  end

  def decode_log_7dd4d0e0_call(<<125, 212, 208, 224>> <> calldata) do
    _signature = hex!("0x7dd4d0e0")
    ABI.decode(log_7dd4d0e0_selector(), calldata)
  end

  def exec_vm_log_7dd4d0e0(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_7dd4d0e0(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_7dd4d0e0_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_7dd4d0e0_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_7dd4d0e0(p0, p1, p2, p3), exec_opts)
  end

  def log_7f9bbca2_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :bool},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_7f9bbca2(p0, p1, p2, p3) do
    ABI.encode(log_7f9bbca2_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_7f9bbca2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_7f9bbca2(p0, p1, p2, p3), opts)
  end

  def build_trx_log_7f9bbca2(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_7f9bbca2(p0, p1, p2, p3)}
  end

  def call_log_7f9bbca2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_7f9bbca2(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_7f9bbca2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_7f9bbca2(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_7f9bbca2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_7f9bbca2(p0, p1, p2, p3), opts)
  end

  def decode_log_7f9bbca2_call(<<127, 155, 188, 162>> <> calldata) do
    _signature = hex!("0x7f9bbca2")
    ABI.decode(log_7f9bbca2_selector(), calldata)
  end

  def exec_vm_log_7f9bbca2(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_7f9bbca2(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_7f9bbca2_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_7f9bbca2_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_7f9bbca2(p0, p1, p2, p3), exec_opts)
  end

  def log_800a1c67_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :address},
        %{name: "p2", type: :address},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_800a1c67(p0, p1, p2, p3) do
    ABI.encode(log_800a1c67_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_800a1c67(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_800a1c67(p0, p1, p2, p3), opts)
  end

  def build_trx_log_800a1c67(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_800a1c67(p0, p1, p2, p3)}
  end

  def call_log_800a1c67(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_800a1c67(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_800a1c67(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_800a1c67(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_800a1c67(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_800a1c67(p0, p1, p2, p3), opts)
  end

  def decode_log_800a1c67_call(<<128, 10, 28, 103>> <> calldata) do
    _signature = hex!("0x800a1c67")
    ABI.decode(log_800a1c67_selector(), calldata)
  end

  def exec_vm_log_800a1c67(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_800a1c67(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_800a1c67_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_800a1c67_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_800a1c67(p0, p1, p2, p3), exec_opts)
  end

  def log_80e6a20b_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :string},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_80e6a20b(p0, p1, p2, p3) do
    ABI.encode(log_80e6a20b_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_80e6a20b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_80e6a20b(p0, p1, p2, p3), opts)
  end

  def build_trx_log_80e6a20b(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_80e6a20b(p0, p1, p2, p3)}
  end

  def call_log_80e6a20b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_80e6a20b(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_80e6a20b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_80e6a20b(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_80e6a20b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_80e6a20b(p0, p1, p2, p3), opts)
  end

  def decode_log_80e6a20b_call(<<128, 230, 162, 11>> <> calldata) do
    _signature = hex!("0x80e6a20b")
    ABI.decode(log_80e6a20b_selector(), calldata)
  end

  def exec_vm_log_80e6a20b(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_80e6a20b(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_80e6a20b_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_80e6a20b_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_80e6a20b(p0, p1, p2, p3), exec_opts)
  end

  def log_82112a42_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :address},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_82112a42(p0, p1, p2, p3) do
    ABI.encode(log_82112a42_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_82112a42(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_82112a42(p0, p1, p2, p3), opts)
  end

  def build_trx_log_82112a42(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_82112a42(p0, p1, p2, p3)}
  end

  def call_log_82112a42(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_82112a42(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_82112a42(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_82112a42(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_82112a42(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_82112a42(p0, p1, p2, p3), opts)
  end

  def decode_log_82112a42_call(<<130, 17, 42, 66>> <> calldata) do
    _signature = hex!("0x82112a42")
    ABI.decode(log_82112a42_selector(), calldata)
  end

  def exec_vm_log_82112a42(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_82112a42(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_82112a42_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_82112a42_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_82112a42(p0, p1, p2, p3), exec_opts)
  end

  def log_82c25b74_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :string},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_82c25b74(p0, p1, p2, p3) do
    ABI.encode(log_82c25b74_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_82c25b74(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_82c25b74(p0, p1, p2, p3), opts)
  end

  def build_trx_log_82c25b74(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_82c25b74(p0, p1, p2, p3)}
  end

  def call_log_82c25b74(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_82c25b74(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_82c25b74(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_82c25b74(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_82c25b74(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_82c25b74(p0, p1, p2, p3), opts)
  end

  def decode_log_82c25b74_call(<<130, 194, 91, 116>> <> calldata) do
    _signature = hex!("0x82c25b74")
    ABI.decode(log_82c25b74_selector(), calldata)
  end

  def exec_vm_log_82c25b74(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_82c25b74(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_82c25b74_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_82c25b74_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_82c25b74(p0, p1, p2, p3), exec_opts)
  end

  def log_8309e8a8_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: :address}, %{name: "p1", type: {:uint, 256}}]
    }
  end

  def encode_log_8309e8a8(p0, p1) do
    ABI.encode(log_8309e8a8_selector(), [p0, p1])
  end

  def prepare_log_8309e8a8(contract, p0, p1, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_8309e8a8(p0, p1), opts)
  end

  def build_trx_log_8309e8a8(contract, p0, p1) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_8309e8a8(p0, p1)}
  end

  def call_log_8309e8a8(contract, p0, p1, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_8309e8a8(contract, p0, p1), opts)
  end

  def estimate_gas_log_8309e8a8(contract, p0, p1, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_8309e8a8(contract, p0, p1), opts)
  end

  def execute_log_8309e8a8(contract, p0, p1, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_8309e8a8(p0, p1), opts)
  end

  def decode_log_8309e8a8_call(<<131, 9, 232, 168>> <> calldata) do
    _signature = hex!("0x8309e8a8")
    ABI.decode(log_8309e8a8_selector(), calldata)
  end

  def exec_vm_log_8309e8a8(p0, p1, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_8309e8a8(p0, p1), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_8309e8a8_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_8309e8a8_raw(p0, p1, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_8309e8a8(p0, p1), exec_opts)
  end

  def log_850b7ad6_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :bool}
      ]
    }
  end

  def encode_log_850b7ad6(p0, p1, p2) do
    ABI.encode(log_850b7ad6_selector(), [p0, p1, p2])
  end

  def prepare_log_850b7ad6(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_850b7ad6(p0, p1, p2), opts)
  end

  def build_trx_log_850b7ad6(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_850b7ad6(p0, p1, p2)}
  end

  def call_log_850b7ad6(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_850b7ad6(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_850b7ad6(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_850b7ad6(contract, p0, p1, p2), opts)
  end

  def execute_log_850b7ad6(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_850b7ad6(p0, p1, p2), opts)
  end

  def decode_log_850b7ad6_call(<<133, 11, 122, 214>> <> calldata) do
    _signature = hex!("0x850b7ad6")
    ABI.decode(log_850b7ad6_selector(), calldata)
  end

  def exec_vm_log_850b7ad6(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_850b7ad6(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_850b7ad6_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_850b7ad6_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_850b7ad6(p0, p1, p2), exec_opts)
  end

  def log_853c4849_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: :bool}, %{name: "p1", type: :address}]
    }
  end

  def encode_log_853c4849(p0, p1) do
    ABI.encode(log_853c4849_selector(), [p0, p1])
  end

  def prepare_log_853c4849(contract, p0, p1, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_853c4849(p0, p1), opts)
  end

  def build_trx_log_853c4849(contract, p0, p1) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_853c4849(p0, p1)}
  end

  def call_log_853c4849(contract, p0, p1, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_853c4849(contract, p0, p1), opts)
  end

  def estimate_gas_log_853c4849(contract, p0, p1, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_853c4849(contract, p0, p1), opts)
  end

  def execute_log_853c4849(contract, p0, p1, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_853c4849(p0, p1), opts)
  end

  def decode_log_853c4849_call(<<133, 60, 72, 73>> <> calldata) do
    _signature = hex!("0x853c4849")
    ABI.decode(log_853c4849_selector(), calldata)
  end

  def exec_vm_log_853c4849(p0, p1, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_853c4849(p0, p1), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_853c4849_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_853c4849_raw(p0, p1, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_853c4849(p0, p1), exec_opts)
  end

  def log_854b3496_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_854b3496(p0, p1, p2, p3) do
    ABI.encode(log_854b3496_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_854b3496(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_854b3496(p0, p1, p2, p3), opts)
  end

  def build_trx_log_854b3496(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_854b3496(p0, p1, p2, p3)}
  end

  def call_log_854b3496(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_854b3496(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_854b3496(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_854b3496(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_854b3496(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_854b3496(p0, p1, p2, p3), opts)
  end

  def decode_log_854b3496_call(<<133, 75, 52, 150>> <> calldata) do
    _signature = hex!("0x854b3496")
    ABI.decode(log_854b3496_selector(), calldata)
  end

  def exec_vm_log_854b3496(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_854b3496(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_854b3496_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_854b3496_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_854b3496(p0, p1, p2, p3), exec_opts)
  end

  def log_85775021_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :string}
      ]
    }
  end

  def encode_log_85775021(p0, p1, p2) do
    ABI.encode(log_85775021_selector(), [p0, p1, p2])
  end

  def prepare_log_85775021(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_85775021(p0, p1, p2), opts)
  end

  def build_trx_log_85775021(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_85775021(p0, p1, p2)}
  end

  def call_log_85775021(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_85775021(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_85775021(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_85775021(contract, p0, p1, p2), opts)
  end

  def execute_log_85775021(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_85775021(p0, p1, p2), opts)
  end

  def decode_log_85775021_call(<<133, 119, 80, 33>> <> calldata) do
    _signature = hex!("0x85775021")
    ABI.decode(log_85775021_selector(), calldata)
  end

  def exec_vm_log_85775021(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_85775021(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_85775021_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_85775021_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_85775021(p0, p1, p2), exec_opts)
  end

  def log_88a8c406_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :string},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_88a8c406(p0, p1, p2, p3) do
    ABI.encode(log_88a8c406_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_88a8c406(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_88a8c406(p0, p1, p2, p3), opts)
  end

  def build_trx_log_88a8c406(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_88a8c406(p0, p1, p2, p3)}
  end

  def call_log_88a8c406(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_88a8c406(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_88a8c406(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_88a8c406(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_88a8c406(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_88a8c406(p0, p1, p2, p3), opts)
  end

  def decode_log_88a8c406_call(<<136, 168, 196, 6>> <> calldata) do
    _signature = hex!("0x88a8c406")
    ABI.decode(log_88a8c406_selector(), calldata)
  end

  def exec_vm_log_88a8c406(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_88a8c406(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_88a8c406_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_88a8c406_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_88a8c406(p0, p1, p2, p3), exec_opts)
  end

  def log_88cb6041_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :bool},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_88cb6041(p0, p1, p2, p3) do
    ABI.encode(log_88cb6041_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_88cb6041(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_88cb6041(p0, p1, p2, p3), opts)
  end

  def build_trx_log_88cb6041(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_88cb6041(p0, p1, p2, p3)}
  end

  def call_log_88cb6041(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_88cb6041(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_88cb6041(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_88cb6041(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_88cb6041(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_88cb6041(p0, p1, p2, p3), opts)
  end

  def decode_log_88cb6041_call(<<136, 203, 96, 65>> <> calldata) do
    _signature = hex!("0x88cb6041")
    ABI.decode(log_88cb6041_selector(), calldata)
  end

  def exec_vm_log_88cb6041(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_88cb6041(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_88cb6041_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_88cb6041_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_88cb6041(p0, p1, p2, p3), exec_opts)
  end

  def log_88f6e4b2_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :address},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_88f6e4b2(p0, p1, p2, p3) do
    ABI.encode(log_88f6e4b2_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_88f6e4b2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_88f6e4b2(p0, p1, p2, p3), opts)
  end

  def build_trx_log_88f6e4b2(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_88f6e4b2(p0, p1, p2, p3)}
  end

  def call_log_88f6e4b2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_88f6e4b2(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_88f6e4b2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_88f6e4b2(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_88f6e4b2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_88f6e4b2(p0, p1, p2, p3), opts)
  end

  def decode_log_88f6e4b2_call(<<136, 246, 228, 178>> <> calldata) do
    _signature = hex!("0x88f6e4b2")
    ABI.decode(log_88f6e4b2_selector(), calldata)
  end

  def exec_vm_log_88f6e4b2(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_88f6e4b2(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_88f6e4b2_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_88f6e4b2_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_88f6e4b2(p0, p1, p2, p3), exec_opts)
  end

  def log_895af8c5_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_895af8c5(p0, p1, p2, p3) do
    ABI.encode(log_895af8c5_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_895af8c5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_895af8c5(p0, p1, p2, p3), opts)
  end

  def build_trx_log_895af8c5(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_895af8c5(p0, p1, p2, p3)}
  end

  def call_log_895af8c5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_895af8c5(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_895af8c5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_895af8c5(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_895af8c5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_895af8c5(p0, p1, p2, p3), opts)
  end

  def decode_log_895af8c5_call(<<137, 90, 248, 197>> <> calldata) do
    _signature = hex!("0x895af8c5")
    ABI.decode(log_895af8c5_selector(), calldata)
  end

  def exec_vm_log_895af8c5(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_895af8c5(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_895af8c5_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_895af8c5_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_895af8c5(p0, p1, p2, p3), exec_opts)
  end

  def log_8af7cf8a_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :bool},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_8af7cf8a(p0, p1, p2, p3) do
    ABI.encode(log_8af7cf8a_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_8af7cf8a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_8af7cf8a(p0, p1, p2, p3), opts)
  end

  def build_trx_log_8af7cf8a(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_8af7cf8a(p0, p1, p2, p3)}
  end

  def call_log_8af7cf8a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_8af7cf8a(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_8af7cf8a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_8af7cf8a(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_8af7cf8a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_8af7cf8a(p0, p1, p2, p3), opts)
  end

  def decode_log_8af7cf8a_call(<<138, 247, 207, 138>> <> calldata) do
    _signature = hex!("0x8af7cf8a")
    ABI.decode(log_8af7cf8a_selector(), calldata)
  end

  def exec_vm_log_8af7cf8a(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_8af7cf8a(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_8af7cf8a_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_8af7cf8a_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_8af7cf8a(p0, p1, p2, p3), exec_opts)
  end

  def log_8c329b1a_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_8c329b1a(p0, p1, p2, p3) do
    ABI.encode(log_8c329b1a_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_8c329b1a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_8c329b1a(p0, p1, p2, p3), opts)
  end

  def build_trx_log_8c329b1a(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_8c329b1a(p0, p1, p2, p3)}
  end

  def call_log_8c329b1a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_8c329b1a(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_8c329b1a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_8c329b1a(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_8c329b1a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_8c329b1a(p0, p1, p2, p3), opts)
  end

  def decode_log_8c329b1a_call(<<140, 50, 155, 26>> <> calldata) do
    _signature = hex!("0x8c329b1a")
    ABI.decode(log_8c329b1a_selector(), calldata)
  end

  def exec_vm_log_8c329b1a(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_8c329b1a(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_8c329b1a_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_8c329b1a_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_8c329b1a(p0, p1, p2, p3), exec_opts)
  end

  def log_8c4e5de6_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :bool},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_8c4e5de6(p0, p1, p2, p3) do
    ABI.encode(log_8c4e5de6_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_8c4e5de6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_8c4e5de6(p0, p1, p2, p3), opts)
  end

  def build_trx_log_8c4e5de6(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_8c4e5de6(p0, p1, p2, p3)}
  end

  def call_log_8c4e5de6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_8c4e5de6(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_8c4e5de6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_8c4e5de6(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_8c4e5de6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_8c4e5de6(p0, p1, p2, p3), opts)
  end

  def decode_log_8c4e5de6_call(<<140, 78, 93, 230>> <> calldata) do
    _signature = hex!("0x8c4e5de6")
    ABI.decode(log_8c4e5de6_selector(), calldata)
  end

  def exec_vm_log_8c4e5de6(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_8c4e5de6(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_8c4e5de6_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_8c4e5de6_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_8c4e5de6(p0, p1, p2, p3), exec_opts)
  end

  def log_8da6def5_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :address},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_8da6def5(p0, p1, p2, p3) do
    ABI.encode(log_8da6def5_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_8da6def5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_8da6def5(p0, p1, p2, p3), opts)
  end

  def build_trx_log_8da6def5(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_8da6def5(p0, p1, p2, p3)}
  end

  def call_log_8da6def5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_8da6def5(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_8da6def5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_8da6def5(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_8da6def5(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_8da6def5(p0, p1, p2, p3), opts)
  end

  def decode_log_8da6def5_call(<<141, 166, 222, 245>> <> calldata) do
    _signature = hex!("0x8da6def5")
    ABI.decode(log_8da6def5_selector(), calldata)
  end

  def exec_vm_log_8da6def5(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_8da6def5(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_8da6def5_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_8da6def5_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_8da6def5(p0, p1, p2, p3), exec_opts)
  end

  def log_8e3f78a9_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :bool},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_8e3f78a9(p0, p1, p2, p3) do
    ABI.encode(log_8e3f78a9_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_8e3f78a9(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_8e3f78a9(p0, p1, p2, p3), opts)
  end

  def build_trx_log_8e3f78a9(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_8e3f78a9(p0, p1, p2, p3)}
  end

  def call_log_8e3f78a9(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_8e3f78a9(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_8e3f78a9(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_8e3f78a9(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_8e3f78a9(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_8e3f78a9(p0, p1, p2, p3), opts)
  end

  def decode_log_8e3f78a9_call(<<142, 63, 120, 169>> <> calldata) do
    _signature = hex!("0x8e3f78a9")
    ABI.decode(log_8e3f78a9_selector(), calldata)
  end

  def exec_vm_log_8e3f78a9(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_8e3f78a9(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_8e3f78a9_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_8e3f78a9_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_8e3f78a9(p0, p1, p2, p3), exec_opts)
  end

  def log_8e69fb5d_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_8e69fb5d(p0, p1, p2, p3) do
    ABI.encode(log_8e69fb5d_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_8e69fb5d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_8e69fb5d(p0, p1, p2, p3), opts)
  end

  def build_trx_log_8e69fb5d(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_8e69fb5d(p0, p1, p2, p3)}
  end

  def call_log_8e69fb5d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_8e69fb5d(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_8e69fb5d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_8e69fb5d(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_8e69fb5d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_8e69fb5d(p0, p1, p2, p3), opts)
  end

  def decode_log_8e69fb5d_call(<<142, 105, 251, 93>> <> calldata) do
    _signature = hex!("0x8e69fb5d")
    ABI.decode(log_8e69fb5d_selector(), calldata)
  end

  def exec_vm_log_8e69fb5d(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_8e69fb5d(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_8e69fb5d_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_8e69fb5d_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_8e69fb5d(p0, p1, p2, p3), exec_opts)
  end

  def log_8eafb02b_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :string},
        %{name: "p2", type: :string},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_8eafb02b(p0, p1, p2, p3) do
    ABI.encode(log_8eafb02b_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_8eafb02b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_8eafb02b(p0, p1, p2, p3), opts)
  end

  def build_trx_log_8eafb02b(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_8eafb02b(p0, p1, p2, p3)}
  end

  def call_log_8eafb02b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_8eafb02b(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_8eafb02b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_8eafb02b(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_8eafb02b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_8eafb02b(p0, p1, p2, p3), opts)
  end

  def decode_log_8eafb02b_call(<<142, 175, 176, 43>> <> calldata) do
    _signature = hex!("0x8eafb02b")
    ABI.decode(log_8eafb02b_selector(), calldata)
  end

  def exec_vm_log_8eafb02b(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_8eafb02b(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_8eafb02b_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_8eafb02b_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_8eafb02b(p0, p1, p2, p3), exec_opts)
  end

  def log_8ef3f399_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :address},
        %{name: "p2", type: :address},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_8ef3f399(p0, p1, p2, p3) do
    ABI.encode(log_8ef3f399_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_8ef3f399(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_8ef3f399(p0, p1, p2, p3), opts)
  end

  def build_trx_log_8ef3f399(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_8ef3f399(p0, p1, p2, p3)}
  end

  def call_log_8ef3f399(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_8ef3f399(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_8ef3f399(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_8ef3f399(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_8ef3f399(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_8ef3f399(p0, p1, p2, p3), opts)
  end

  def decode_log_8ef3f399_call(<<142, 243, 243, 153>> <> calldata) do
    _signature = hex!("0x8ef3f399")
    ABI.decode(log_8ef3f399_selector(), calldata)
  end

  def exec_vm_log_8ef3f399(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_8ef3f399(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_8ef3f399_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_8ef3f399_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_8ef3f399(p0, p1, p2, p3), exec_opts)
  end

  def log_8f736d16_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :address},
        %{name: "p2", type: :string},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_8f736d16(p0, p1, p2, p3) do
    ABI.encode(log_8f736d16_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_8f736d16(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_8f736d16(p0, p1, p2, p3), opts)
  end

  def build_trx_log_8f736d16(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_8f736d16(p0, p1, p2, p3)}
  end

  def call_log_8f736d16(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_8f736d16(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_8f736d16(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_8f736d16(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_8f736d16(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_8f736d16(p0, p1, p2, p3), opts)
  end

  def decode_log_8f736d16_call(<<143, 115, 109, 22>> <> calldata) do
    _signature = hex!("0x8f736d16")
    ABI.decode(log_8f736d16_selector(), calldata)
  end

  def exec_vm_log_8f736d16(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_8f736d16(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_8f736d16_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_8f736d16_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_8f736d16(p0, p1, p2, p3), exec_opts)
  end

  def log_8feac525_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: :bool}, %{name: "p1", type: :string}]
    }
  end

  def encode_log_8feac525(p0, p1) do
    ABI.encode(log_8feac525_selector(), [p0, p1])
  end

  def prepare_log_8feac525(contract, p0, p1, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_8feac525(p0, p1), opts)
  end

  def build_trx_log_8feac525(contract, p0, p1) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_8feac525(p0, p1)}
  end

  def call_log_8feac525(contract, p0, p1, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_8feac525(contract, p0, p1), opts)
  end

  def estimate_gas_log_8feac525(contract, p0, p1, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_8feac525(contract, p0, p1), opts)
  end

  def execute_log_8feac525(contract, p0, p1, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_8feac525(p0, p1), opts)
  end

  def decode_log_8feac525_call(<<143, 234, 197, 37>> <> calldata) do
    _signature = hex!("0x8feac525")
    ABI.decode(log_8feac525_selector(), calldata)
  end

  def exec_vm_log_8feac525(p0, p1, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_8feac525(p0, p1), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_8feac525_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_8feac525_raw(p0, p1, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_8feac525(p0, p1), exec_opts)
  end

  def log_90c30a56_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :string},
        %{name: "p2", type: :address},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_90c30a56(p0, p1, p2, p3) do
    ABI.encode(log_90c30a56_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_90c30a56(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_90c30a56(p0, p1, p2, p3), opts)
  end

  def build_trx_log_90c30a56(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_90c30a56(p0, p1, p2, p3)}
  end

  def call_log_90c30a56(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_90c30a56(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_90c30a56(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_90c30a56(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_90c30a56(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_90c30a56(p0, p1, p2, p3), opts)
  end

  def decode_log_90c30a56_call(<<144, 195, 10, 86>> <> calldata) do
    _signature = hex!("0x90c30a56")
    ABI.decode(log_90c30a56_selector(), calldata)
  end

  def exec_vm_log_90c30a56(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_90c30a56(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_90c30a56_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_90c30a56_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_90c30a56(p0, p1, p2, p3), exec_opts)
  end

  def log_90fb06aa_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :address},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_90fb06aa(p0, p1, p2, p3) do
    ABI.encode(log_90fb06aa_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_90fb06aa(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_90fb06aa(p0, p1, p2, p3), opts)
  end

  def build_trx_log_90fb06aa(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_90fb06aa(p0, p1, p2, p3)}
  end

  def call_log_90fb06aa(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_90fb06aa(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_90fb06aa(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_90fb06aa(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_90fb06aa(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_90fb06aa(p0, p1, p2, p3), opts)
  end

  def decode_log_90fb06aa_call(<<144, 251, 6, 170>> <> calldata) do
    _signature = hex!("0x90fb06aa")
    ABI.decode(log_90fb06aa_selector(), calldata)
  end

  def exec_vm_log_90fb06aa(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_90fb06aa(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_90fb06aa_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_90fb06aa_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_90fb06aa(p0, p1, p2, p3), exec_opts)
  end

  def log_9143dbb1_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_9143dbb1(p0, p1, p2, p3) do
    ABI.encode(log_9143dbb1_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_9143dbb1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_9143dbb1(p0, p1, p2, p3), opts)
  end

  def build_trx_log_9143dbb1(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_9143dbb1(p0, p1, p2, p3)}
  end

  def call_log_9143dbb1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_9143dbb1(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_9143dbb1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_9143dbb1(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_9143dbb1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_9143dbb1(p0, p1, p2, p3), opts)
  end

  def decode_log_9143dbb1_call(<<145, 67, 219, 177>> <> calldata) do
    _signature = hex!("0x9143dbb1")
    ABI.decode(log_9143dbb1_selector(), calldata)
  end

  def exec_vm_log_9143dbb1(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_9143dbb1(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_9143dbb1_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_9143dbb1_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_9143dbb1(p0, p1, p2, p3), exec_opts)
  end

  def log_91a02e2a_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :bool},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_91a02e2a(p0, p1, p2, p3) do
    ABI.encode(log_91a02e2a_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_91a02e2a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_91a02e2a(p0, p1, p2, p3), opts)
  end

  def build_trx_log_91a02e2a(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_91a02e2a(p0, p1, p2, p3)}
  end

  def call_log_91a02e2a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_91a02e2a(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_91a02e2a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_91a02e2a(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_91a02e2a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_91a02e2a(p0, p1, p2, p3), opts)
  end

  def decode_log_91a02e2a_call(<<145, 160, 46, 42>> <> calldata) do
    _signature = hex!("0x91a02e2a")
    ABI.decode(log_91a02e2a_selector(), calldata)
  end

  def exec_vm_log_91a02e2a(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_91a02e2a(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_91a02e2a_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_91a02e2a_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_91a02e2a(p0, p1, p2, p3), exec_opts)
  end

  def log_91d1112e_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :address},
        %{name: "p2", type: :string},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_91d1112e(p0, p1, p2, p3) do
    ABI.encode(log_91d1112e_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_91d1112e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_91d1112e(p0, p1, p2, p3), opts)
  end

  def build_trx_log_91d1112e(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_91d1112e(p0, p1, p2, p3)}
  end

  def call_log_91d1112e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_91d1112e(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_91d1112e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_91d1112e(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_91d1112e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_91d1112e(p0, p1, p2, p3), opts)
  end

  def decode_log_91d1112e_call(<<145, 209, 17, 46>> <> calldata) do
    _signature = hex!("0x91d1112e")
    ABI.decode(log_91d1112e_selector(), calldata)
  end

  def exec_vm_log_91d1112e(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_91d1112e(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_91d1112e_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_91d1112e_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_91d1112e(p0, p1, p2, p3), exec_opts)
  end

  def log_932bbb38_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :address}
      ]
    }
  end

  def encode_log_932bbb38(p0, p1, p2) do
    ABI.encode(log_932bbb38_selector(), [p0, p1, p2])
  end

  def prepare_log_932bbb38(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_932bbb38(p0, p1, p2), opts)
  end

  def build_trx_log_932bbb38(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_932bbb38(p0, p1, p2)}
  end

  def call_log_932bbb38(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_932bbb38(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_932bbb38(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_932bbb38(contract, p0, p1, p2), opts)
  end

  def execute_log_932bbb38(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_932bbb38(p0, p1, p2), opts)
  end

  def decode_log_932bbb38_call(<<147, 43, 187, 56>> <> calldata) do
    _signature = hex!("0x932bbb38")
    ABI.decode(log_932bbb38_selector(), calldata)
  end

  def exec_vm_log_932bbb38(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_932bbb38(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_932bbb38_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_932bbb38_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_932bbb38(p0, p1, p2), exec_opts)
  end

  def log_935e09bf_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :bool},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_935e09bf(p0, p1, p2, p3) do
    ABI.encode(log_935e09bf_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_935e09bf(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_935e09bf(p0, p1, p2, p3), opts)
  end

  def build_trx_log_935e09bf(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_935e09bf(p0, p1, p2, p3)}
  end

  def call_log_935e09bf(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_935e09bf(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_935e09bf(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_935e09bf(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_935e09bf(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_935e09bf(p0, p1, p2, p3), opts)
  end

  def decode_log_935e09bf_call(<<147, 94, 9, 191>> <> calldata) do
    _signature = hex!("0x935e09bf")
    ABI.decode(log_935e09bf_selector(), calldata)
  end

  def exec_vm_log_935e09bf(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_935e09bf(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_935e09bf_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_935e09bf_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_935e09bf(p0, p1, p2, p3), exec_opts)
  end

  def log_94250d77_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :address},
        %{name: "p2", type: :address},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_94250d77(p0, p1, p2, p3) do
    ABI.encode(log_94250d77_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_94250d77(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_94250d77(p0, p1, p2, p3), opts)
  end

  def build_trx_log_94250d77(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_94250d77(p0, p1, p2, p3)}
  end

  def call_log_94250d77(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_94250d77(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_94250d77(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_94250d77(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_94250d77(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_94250d77(p0, p1, p2, p3), opts)
  end

  def decode_log_94250d77_call(<<148, 37, 13, 119>> <> calldata) do
    _signature = hex!("0x94250d77")
    ABI.decode(log_94250d77_selector(), calldata)
  end

  def exec_vm_log_94250d77(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_94250d77(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_94250d77_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_94250d77_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_94250d77(p0, p1, p2, p3), exec_opts)
  end

  def log_958c28c6_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :address},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_958c28c6(p0, p1, p2, p3) do
    ABI.encode(log_958c28c6_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_958c28c6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_958c28c6(p0, p1, p2, p3), opts)
  end

  def build_trx_log_958c28c6(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_958c28c6(p0, p1, p2, p3)}
  end

  def call_log_958c28c6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_958c28c6(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_958c28c6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_958c28c6(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_958c28c6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_958c28c6(p0, p1, p2, p3), opts)
  end

  def decode_log_958c28c6_call(<<149, 140, 40, 198>> <> calldata) do
    _signature = hex!("0x958c28c6")
    ABI.decode(log_958c28c6_selector(), calldata)
  end

  def exec_vm_log_958c28c6(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_958c28c6(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_958c28c6_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_958c28c6_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_958c28c6(p0, p1, p2, p3), exec_opts)
  end

  def log_9591b953_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :string},
        %{name: "p2", type: :address}
      ]
    }
  end

  def encode_log_9591b953(p0, p1, p2) do
    ABI.encode(log_9591b953_selector(), [p0, p1, p2])
  end

  def prepare_log_9591b953(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_9591b953(p0, p1, p2), opts)
  end

  def build_trx_log_9591b953(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_9591b953(p0, p1, p2)}
  end

  def call_log_9591b953(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_9591b953(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_9591b953(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_9591b953(contract, p0, p1, p2), opts)
  end

  def execute_log_9591b953(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_9591b953(p0, p1, p2), opts)
  end

  def decode_log_9591b953_call(<<149, 145, 185, 83>> <> calldata) do
    _signature = hex!("0x9591b953")
    ABI.decode(log_9591b953_selector(), calldata)
  end

  def exec_vm_log_9591b953(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_9591b953(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_9591b953_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_9591b953_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_9591b953(p0, p1, p2), exec_opts)
  end

  def log_95ed0195_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :string},
        %{name: "p2", type: :address}
      ]
    }
  end

  def encode_log_95ed0195(p0, p1, p2) do
    ABI.encode(log_95ed0195_selector(), [p0, p1, p2])
  end

  def prepare_log_95ed0195(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_95ed0195(p0, p1, p2), opts)
  end

  def build_trx_log_95ed0195(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_95ed0195(p0, p1, p2)}
  end

  def call_log_95ed0195(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_95ed0195(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_95ed0195(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_95ed0195(contract, p0, p1, p2), opts)
  end

  def execute_log_95ed0195(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_95ed0195(p0, p1, p2), opts)
  end

  def decode_log_95ed0195_call(<<149, 237, 1, 149>> <> calldata) do
    _signature = hex!("0x95ed0195")
    ABI.decode(log_95ed0195_selector(), calldata)
  end

  def exec_vm_log_95ed0195(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_95ed0195(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_95ed0195_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_95ed0195_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_95ed0195(p0, p1, p2), exec_opts)
  end

  def log_97d394d8_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :string},
        %{name: "p2", type: :string},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_97d394d8(p0, p1, p2, p3) do
    ABI.encode(log_97d394d8_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_97d394d8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_97d394d8(p0, p1, p2, p3), opts)
  end

  def build_trx_log_97d394d8(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_97d394d8(p0, p1, p2, p3)}
  end

  def call_log_97d394d8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_97d394d8(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_97d394d8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_97d394d8(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_97d394d8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_97d394d8(p0, p1, p2, p3), opts)
  end

  def decode_log_97d394d8_call(<<151, 211, 148, 216>> <> calldata) do
    _signature = hex!("0x97d394d8")
    ABI.decode(log_97d394d8_selector(), calldata)
  end

  def exec_vm_log_97d394d8(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_97d394d8(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_97d394d8_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_97d394d8_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_97d394d8(p0, p1, p2, p3), exec_opts)
  end

  def log_9a816a83_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_9a816a83(p0, p1, p2, p3) do
    ABI.encode(log_9a816a83_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_9a816a83(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_9a816a83(p0, p1, p2, p3), opts)
  end

  def build_trx_log_9a816a83(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_9a816a83(p0, p1, p2, p3)}
  end

  def call_log_9a816a83(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_9a816a83(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_9a816a83(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_9a816a83(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_9a816a83(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_9a816a83(p0, p1, p2, p3), opts)
  end

  def decode_log_9a816a83_call(<<154, 129, 106, 131>> <> calldata) do
    _signature = hex!("0x9a816a83")
    ABI.decode(log_9a816a83_selector(), calldata)
  end

  def exec_vm_log_9a816a83(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_9a816a83(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_9a816a83_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_9a816a83_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_9a816a83(p0, p1, p2, p3), exec_opts)
  end

  def log_9acd3616_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_9acd3616(p0, p1, p2, p3) do
    ABI.encode(log_9acd3616_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_9acd3616(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_9acd3616(p0, p1, p2, p3), opts)
  end

  def build_trx_log_9acd3616(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_9acd3616(p0, p1, p2, p3)}
  end

  def call_log_9acd3616(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_9acd3616(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_9acd3616(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_9acd3616(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_9acd3616(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_9acd3616(p0, p1, p2, p3), opts)
  end

  def decode_log_9acd3616_call(<<154, 205, 54, 22>> <> calldata) do
    _signature = hex!("0x9acd3616")
    ABI.decode(log_9acd3616_selector(), calldata)
  end

  def exec_vm_log_9acd3616(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_9acd3616(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_9acd3616_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_9acd3616_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_9acd3616(p0, p1, p2, p3), exec_opts)
  end

  def log_9b4254e2_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :address},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_9b4254e2(p0, p1, p2, p3) do
    ABI.encode(log_9b4254e2_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_9b4254e2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_9b4254e2(p0, p1, p2, p3), opts)
  end

  def build_trx_log_9b4254e2(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_9b4254e2(p0, p1, p2, p3)}
  end

  def call_log_9b4254e2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_9b4254e2(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_9b4254e2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_9b4254e2(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_9b4254e2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_9b4254e2(p0, p1, p2, p3), opts)
  end

  def decode_log_9b4254e2_call(<<155, 66, 84, 226>> <> calldata) do
    _signature = hex!("0x9b4254e2")
    ABI.decode(log_9b4254e2_selector(), calldata)
  end

  def exec_vm_log_9b4254e2(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_9b4254e2(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_9b4254e2_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_9b4254e2_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_9b4254e2(p0, p1, p2, p3), exec_opts)
  end

  def log_9b6ec042_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :address},
        %{name: "p2", type: :bool}
      ]
    }
  end

  def encode_log_9b6ec042(p0, p1, p2) do
    ABI.encode(log_9b6ec042_selector(), [p0, p1, p2])
  end

  def prepare_log_9b6ec042(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_9b6ec042(p0, p1, p2), opts)
  end

  def build_trx_log_9b6ec042(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_9b6ec042(p0, p1, p2)}
  end

  def call_log_9b6ec042(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_9b6ec042(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_9b6ec042(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_9b6ec042(contract, p0, p1, p2), opts)
  end

  def execute_log_9b6ec042(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_9b6ec042(p0, p1, p2), opts)
  end

  def decode_log_9b6ec042_call(<<155, 110, 192, 66>> <> calldata) do
    _signature = hex!("0x9b6ec042")
    ABI.decode(log_9b6ec042_selector(), calldata)
  end

  def exec_vm_log_9b6ec042(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_9b6ec042(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_9b6ec042_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_9b6ec042_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_9b6ec042(p0, p1, p2), exec_opts)
  end

  def log_9c3adfa1_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :string},
        %{name: "p2", type: :address},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_9c3adfa1(p0, p1, p2, p3) do
    ABI.encode(log_9c3adfa1_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_9c3adfa1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_9c3adfa1(p0, p1, p2, p3), opts)
  end

  def build_trx_log_9c3adfa1(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_9c3adfa1(p0, p1, p2, p3)}
  end

  def call_log_9c3adfa1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_9c3adfa1(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_9c3adfa1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_9c3adfa1(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_9c3adfa1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_9c3adfa1(p0, p1, p2, p3), opts)
  end

  def decode_log_9c3adfa1_call(<<156, 58, 223, 161>> <> calldata) do
    _signature = hex!("0x9c3adfa1")
    ABI.decode(log_9c3adfa1_selector(), calldata)
  end

  def exec_vm_log_9c3adfa1(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_9c3adfa1(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_9c3adfa1_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_9c3adfa1_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_9c3adfa1(p0, p1, p2, p3), exec_opts)
  end

  def log_9c4f99fb_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :bool},
        %{name: "p2", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_9c4f99fb(p0, p1, p2) do
    ABI.encode(log_9c4f99fb_selector(), [p0, p1, p2])
  end

  def prepare_log_9c4f99fb(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_9c4f99fb(p0, p1, p2), opts)
  end

  def build_trx_log_9c4f99fb(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_9c4f99fb(p0, p1, p2)}
  end

  def call_log_9c4f99fb(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_9c4f99fb(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_9c4f99fb(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_9c4f99fb(contract, p0, p1, p2), opts)
  end

  def execute_log_9c4f99fb(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_9c4f99fb(p0, p1, p2), opts)
  end

  def decode_log_9c4f99fb_call(<<156, 79, 153, 251>> <> calldata) do
    _signature = hex!("0x9c4f99fb")
    ABI.decode(log_9c4f99fb_selector(), calldata)
  end

  def exec_vm_log_9c4f99fb(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_9c4f99fb(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_9c4f99fb_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_9c4f99fb_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_9c4f99fb(p0, p1, p2), exec_opts)
  end

  def log_9cba8fff_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :address},
        %{name: "p2", type: :string},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_9cba8fff(p0, p1, p2, p3) do
    ABI.encode(log_9cba8fff_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_9cba8fff(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_9cba8fff(p0, p1, p2, p3), opts)
  end

  def build_trx_log_9cba8fff(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_9cba8fff(p0, p1, p2, p3)}
  end

  def call_log_9cba8fff(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_9cba8fff(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_9cba8fff(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_9cba8fff(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_9cba8fff(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_9cba8fff(p0, p1, p2, p3), opts)
  end

  def decode_log_9cba8fff_call(<<156, 186, 143, 255>> <> calldata) do
    _signature = hex!("0x9cba8fff")
    ABI.decode(log_9cba8fff_selector(), calldata)
  end

  def exec_vm_log_9cba8fff(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_9cba8fff(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_9cba8fff_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_9cba8fff_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_9cba8fff(p0, p1, p2, p3), exec_opts)
  end

  def log_9d22d5dd_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_9d22d5dd(p0, p1, p2, p3) do
    ABI.encode(log_9d22d5dd_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_9d22d5dd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_9d22d5dd(p0, p1, p2, p3), opts)
  end

  def build_trx_log_9d22d5dd(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_9d22d5dd(p0, p1, p2, p3)}
  end

  def call_log_9d22d5dd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_9d22d5dd(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_9d22d5dd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_9d22d5dd(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_9d22d5dd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_9d22d5dd(p0, p1, p2, p3), opts)
  end

  def decode_log_9d22d5dd_call(<<157, 34, 213, 221>> <> calldata) do
    _signature = hex!("0x9d22d5dd")
    ABI.decode(log_9d22d5dd_selector(), calldata)
  end

  def exec_vm_log_9d22d5dd(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_9d22d5dd(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_9d22d5dd_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_9d22d5dd_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_9d22d5dd(p0, p1, p2, p3), exec_opts)
  end

  def log_9f1bc36e_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :address},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_9f1bc36e(p0, p1, p2, p3) do
    ABI.encode(log_9f1bc36e_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_9f1bc36e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_9f1bc36e(p0, p1, p2, p3), opts)
  end

  def build_trx_log_9f1bc36e(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_9f1bc36e(p0, p1, p2, p3)}
  end

  def call_log_9f1bc36e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_9f1bc36e(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_9f1bc36e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_9f1bc36e(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_9f1bc36e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_9f1bc36e(p0, p1, p2, p3), opts)
  end

  def decode_log_9f1bc36e_call(<<159, 27, 195, 110>> <> calldata) do
    _signature = hex!("0x9f1bc36e")
    ABI.decode(log_9f1bc36e_selector(), calldata)
  end

  def exec_vm_log_9f1bc36e(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_9f1bc36e(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_9f1bc36e_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_9f1bc36e_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_9f1bc36e(p0, p1, p2, p3), exec_opts)
  end

  def log_9ffb2f93_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :address},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_9ffb2f93(p0, p1, p2, p3) do
    ABI.encode(log_9ffb2f93_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_9ffb2f93(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_9ffb2f93(p0, p1, p2, p3), opts)
  end

  def build_trx_log_9ffb2f93(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_9ffb2f93(p0, p1, p2, p3)}
  end

  def call_log_9ffb2f93(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_9ffb2f93(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_9ffb2f93(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_9ffb2f93(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_9ffb2f93(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_9ffb2f93(p0, p1, p2, p3), opts)
  end

  def decode_log_9ffb2f93_call(<<159, 251, 47, 147>> <> calldata) do
    _signature = hex!("0x9ffb2f93")
    ABI.decode(log_9ffb2f93_selector(), calldata)
  end

  def exec_vm_log_9ffb2f93(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_9ffb2f93(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_9ffb2f93_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_9ffb2f93_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_9ffb2f93(p0, p1, p2, p3), exec_opts)
  end

  def log_a04e2f87_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :string},
        %{name: "p2", type: :string},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_a04e2f87(p0, p1, p2, p3) do
    ABI.encode(log_a04e2f87_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_a04e2f87(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_a04e2f87(p0, p1, p2, p3), opts)
  end

  def build_trx_log_a04e2f87(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_a04e2f87(p0, p1, p2, p3)}
  end

  def call_log_a04e2f87(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_a04e2f87(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_a04e2f87(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_a04e2f87(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_a04e2f87(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_a04e2f87(p0, p1, p2, p3), opts)
  end

  def decode_log_a04e2f87_call(<<160, 78, 47, 135>> <> calldata) do
    _signature = hex!("0xa04e2f87")
    ABI.decode(log_a04e2f87_selector(), calldata)
  end

  def exec_vm_log_a04e2f87(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_a04e2f87(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_a04e2f87_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_a04e2f87_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_a04e2f87(p0, p1, p2, p3), exec_opts)
  end

  def log_a0a47963_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :address},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_a0a47963(p0, p1, p2, p3) do
    ABI.encode(log_a0a47963_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_a0a47963(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_a0a47963(p0, p1, p2, p3), opts)
  end

  def build_trx_log_a0a47963(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_a0a47963(p0, p1, p2, p3)}
  end

  def call_log_a0a47963(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_a0a47963(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_a0a47963(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_a0a47963(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_a0a47963(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_a0a47963(p0, p1, p2, p3), opts)
  end

  def decode_log_a0a47963_call(<<160, 164, 121, 99>> <> calldata) do
    _signature = hex!("0xa0a47963")
    ABI.decode(log_a0a47963_selector(), calldata)
  end

  def exec_vm_log_a0a47963(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_a0a47963(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_a0a47963_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_a0a47963_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_a0a47963(p0, p1, p2, p3), exec_opts)
  end

  def log_a1bcc9b3_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :address},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_a1bcc9b3(p0, p1, p2, p3) do
    ABI.encode(log_a1bcc9b3_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_a1bcc9b3(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_a1bcc9b3(p0, p1, p2, p3), opts)
  end

  def build_trx_log_a1bcc9b3(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_a1bcc9b3(p0, p1, p2, p3)}
  end

  def call_log_a1bcc9b3(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_a1bcc9b3(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_a1bcc9b3(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_a1bcc9b3(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_a1bcc9b3(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_a1bcc9b3(p0, p1, p2, p3), opts)
  end

  def decode_log_a1bcc9b3_call(<<161, 188, 201, 179>> <> calldata) do
    _signature = hex!("0xa1bcc9b3")
    ABI.decode(log_a1bcc9b3_selector(), calldata)
  end

  def exec_vm_log_a1bcc9b3(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_a1bcc9b3(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_a1bcc9b3_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_a1bcc9b3_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_a1bcc9b3(p0, p1, p2, p3), exec_opts)
  end

  def log_a1ef4cbb_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :address},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_a1ef4cbb(p0, p1, p2, p3) do
    ABI.encode(log_a1ef4cbb_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_a1ef4cbb(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_a1ef4cbb(p0, p1, p2, p3), opts)
  end

  def build_trx_log_a1ef4cbb(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_a1ef4cbb(p0, p1, p2, p3)}
  end

  def call_log_a1ef4cbb(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_a1ef4cbb(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_a1ef4cbb(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_a1ef4cbb(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_a1ef4cbb(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_a1ef4cbb(p0, p1, p2, p3), opts)
  end

  def decode_log_a1ef4cbb_call(<<161, 239, 76, 187>> <> calldata) do
    _signature = hex!("0xa1ef4cbb")
    ABI.decode(log_a1ef4cbb_selector(), calldata)
  end

  def exec_vm_log_a1ef4cbb(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_a1ef4cbb(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_a1ef4cbb_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_a1ef4cbb_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_a1ef4cbb(p0, p1, p2, p3), exec_opts)
  end

  def log_a1f2e8aa_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :string}
      ]
    }
  end

  def encode_log_a1f2e8aa(p0, p1, p2) do
    ABI.encode(log_a1f2e8aa_selector(), [p0, p1, p2])
  end

  def prepare_log_a1f2e8aa(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_a1f2e8aa(p0, p1, p2), opts)
  end

  def build_trx_log_a1f2e8aa(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_a1f2e8aa(p0, p1, p2)}
  end

  def call_log_a1f2e8aa(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_a1f2e8aa(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_a1f2e8aa(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_a1f2e8aa(contract, p0, p1, p2), opts)
  end

  def execute_log_a1f2e8aa(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_a1f2e8aa(p0, p1, p2), opts)
  end

  def decode_log_a1f2e8aa_call(<<161, 242, 232, 170>> <> calldata) do
    _signature = hex!("0xa1f2e8aa")
    ABI.decode(log_a1f2e8aa_selector(), calldata)
  end

  def exec_vm_log_a1f2e8aa(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_a1f2e8aa(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_a1f2e8aa_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_a1f2e8aa_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_a1f2e8aa(p0, p1, p2), exec_opts)
  end

  def log_a31bfdcc_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_a31bfdcc(p0, p1, p2, p3) do
    ABI.encode(log_a31bfdcc_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_a31bfdcc(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_a31bfdcc(p0, p1, p2, p3), opts)
  end

  def build_trx_log_a31bfdcc(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_a31bfdcc(p0, p1, p2, p3)}
  end

  def call_log_a31bfdcc(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_a31bfdcc(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_a31bfdcc(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_a31bfdcc(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_a31bfdcc(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_a31bfdcc(p0, p1, p2, p3), opts)
  end

  def decode_log_a31bfdcc_call(<<163, 27, 253, 204>> <> calldata) do
    _signature = hex!("0xa31bfdcc")
    ABI.decode(log_a31bfdcc_selector(), calldata)
  end

  def exec_vm_log_a31bfdcc(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_a31bfdcc(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_a31bfdcc_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_a31bfdcc_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_a31bfdcc(p0, p1, p2, p3), exec_opts)
  end

  def log_a5b4fc99_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_a5b4fc99(p0, p1, p2, p3) do
    ABI.encode(log_a5b4fc99_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_a5b4fc99(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_a5b4fc99(p0, p1, p2, p3), opts)
  end

  def build_trx_log_a5b4fc99(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_a5b4fc99(p0, p1, p2, p3)}
  end

  def call_log_a5b4fc99(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_a5b4fc99(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_a5b4fc99(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_a5b4fc99(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_a5b4fc99(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_a5b4fc99(p0, p1, p2, p3), opts)
  end

  def decode_log_a5b4fc99_call(<<165, 180, 252, 153>> <> calldata) do
    _signature = hex!("0xa5b4fc99")
    ABI.decode(log_a5b4fc99_selector(), calldata)
  end

  def exec_vm_log_a5b4fc99(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_a5b4fc99(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_a5b4fc99_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_a5b4fc99_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_a5b4fc99(p0, p1, p2, p3), exec_opts)
  end

  def log_a5cada94_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :string},
        %{name: "p2", type: :address},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_a5cada94(p0, p1, p2, p3) do
    ABI.encode(log_a5cada94_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_a5cada94(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_a5cada94(p0, p1, p2, p3), opts)
  end

  def build_trx_log_a5cada94(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_a5cada94(p0, p1, p2, p3)}
  end

  def call_log_a5cada94(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_a5cada94(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_a5cada94(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_a5cada94(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_a5cada94(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_a5cada94(p0, p1, p2, p3), opts)
  end

  def decode_log_a5cada94_call(<<165, 202, 218, 148>> <> calldata) do
    _signature = hex!("0xa5cada94")
    ABI.decode(log_a5cada94_selector(), calldata)
  end

  def exec_vm_log_a5cada94(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_a5cada94(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_a5cada94_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_a5cada94_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_a5cada94(p0, p1, p2, p3), exec_opts)
  end

  def log_a6f50b0f_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :address},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_a6f50b0f(p0, p1, p2, p3) do
    ABI.encode(log_a6f50b0f_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_a6f50b0f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_a6f50b0f(p0, p1, p2, p3), opts)
  end

  def build_trx_log_a6f50b0f(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_a6f50b0f(p0, p1, p2, p3)}
  end

  def call_log_a6f50b0f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_a6f50b0f(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_a6f50b0f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_a6f50b0f(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_a6f50b0f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_a6f50b0f(p0, p1, p2, p3), opts)
  end

  def decode_log_a6f50b0f_call(<<166, 245, 11, 15>> <> calldata) do
    _signature = hex!("0xa6f50b0f")
    ABI.decode(log_a6f50b0f_selector(), calldata)
  end

  def exec_vm_log_a6f50b0f(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_a6f50b0f(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_a6f50b0f_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_a6f50b0f_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_a6f50b0f(p0, p1, p2, p3), exec_opts)
  end

  def log_a73c1db6_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :address},
        %{name: "p2", type: :string},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_a73c1db6(p0, p1, p2, p3) do
    ABI.encode(log_a73c1db6_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_a73c1db6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_a73c1db6(p0, p1, p2, p3), opts)
  end

  def build_trx_log_a73c1db6(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_a73c1db6(p0, p1, p2, p3)}
  end

  def call_log_a73c1db6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_a73c1db6(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_a73c1db6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_a73c1db6(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_a73c1db6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_a73c1db6(p0, p1, p2, p3), opts)
  end

  def decode_log_a73c1db6_call(<<167, 60, 29, 182>> <> calldata) do
    _signature = hex!("0xa73c1db6")
    ABI.decode(log_a73c1db6_selector(), calldata)
  end

  def exec_vm_log_a73c1db6(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_a73c1db6(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_a73c1db6_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_a73c1db6_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_a73c1db6(p0, p1, p2, p3), exec_opts)
  end

  def log_a75c59de_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :address},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_a75c59de(p0, p1, p2, p3) do
    ABI.encode(log_a75c59de_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_a75c59de(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_a75c59de(p0, p1, p2, p3), opts)
  end

  def build_trx_log_a75c59de(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_a75c59de(p0, p1, p2, p3)}
  end

  def call_log_a75c59de(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_a75c59de(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_a75c59de(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_a75c59de(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_a75c59de(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_a75c59de(p0, p1, p2, p3), opts)
  end

  def decode_log_a75c59de_call(<<167, 92, 89, 222>> <> calldata) do
    _signature = hex!("0xa75c59de")
    ABI.decode(log_a75c59de_selector(), calldata)
  end

  def exec_vm_log_a75c59de(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_a75c59de(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_a75c59de_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_a75c59de_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_a75c59de(p0, p1, p2, p3), exec_opts)
  end

  def log_a7a87853_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_a7a87853(p0, p1, p2, p3) do
    ABI.encode(log_a7a87853_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_a7a87853(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_a7a87853(p0, p1, p2, p3), opts)
  end

  def build_trx_log_a7a87853(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_a7a87853(p0, p1, p2, p3)}
  end

  def call_log_a7a87853(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_a7a87853(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_a7a87853(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_a7a87853(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_a7a87853(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_a7a87853(p0, p1, p2, p3), opts)
  end

  def decode_log_a7a87853_call(<<167, 168, 120, 83>> <> calldata) do
    _signature = hex!("0xa7a87853")
    ABI.decode(log_a7a87853_selector(), calldata)
  end

  def exec_vm_log_a7a87853(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_a7a87853(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_a7a87853_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_a7a87853_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_a7a87853(p0, p1, p2, p3), exec_opts)
  end

  def log_a826caeb_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :string},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_a826caeb(p0, p1, p2, p3) do
    ABI.encode(log_a826caeb_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_a826caeb(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_a826caeb(p0, p1, p2, p3), opts)
  end

  def build_trx_log_a826caeb(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_a826caeb(p0, p1, p2, p3)}
  end

  def call_log_a826caeb(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_a826caeb(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_a826caeb(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_a826caeb(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_a826caeb(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_a826caeb(p0, p1, p2, p3), opts)
  end

  def decode_log_a826caeb_call(<<168, 38, 202, 235>> <> calldata) do
    _signature = hex!("0xa826caeb")
    ABI.decode(log_a826caeb_selector(), calldata)
  end

  def exec_vm_log_a826caeb(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_a826caeb(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_a826caeb_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_a826caeb_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_a826caeb(p0, p1, p2, p3), exec_opts)
  end

  def log_aa6540c8_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :address},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_aa6540c8(p0, p1, p2, p3) do
    ABI.encode(log_aa6540c8_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_aa6540c8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_aa6540c8(p0, p1, p2, p3), opts)
  end

  def build_trx_log_aa6540c8(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_aa6540c8(p0, p1, p2, p3)}
  end

  def call_log_aa6540c8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_aa6540c8(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_aa6540c8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_aa6540c8(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_aa6540c8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_aa6540c8(p0, p1, p2, p3), opts)
  end

  def decode_log_aa6540c8_call(<<170, 101, 64, 200>> <> calldata) do
    _signature = hex!("0xaa6540c8")
    ABI.decode(log_aa6540c8_selector(), calldata)
  end

  def exec_vm_log_aa6540c8(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_aa6540c8(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_aa6540c8_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_aa6540c8_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_aa6540c8(p0, p1, p2, p3), exec_opts)
  end

  def log_aabc9a31_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :address},
        %{name: "p2", type: :string},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_aabc9a31(p0, p1, p2, p3) do
    ABI.encode(log_aabc9a31_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_aabc9a31(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_aabc9a31(p0, p1, p2, p3), opts)
  end

  def build_trx_log_aabc9a31(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_aabc9a31(p0, p1, p2, p3)}
  end

  def call_log_aabc9a31(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_aabc9a31(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_aabc9a31(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_aabc9a31(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_aabc9a31(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_aabc9a31(p0, p1, p2, p3), opts)
  end

  def decode_log_aabc9a31_call(<<170, 188, 154, 49>> <> calldata) do
    _signature = hex!("0xaabc9a31")
    ABI.decode(log_aabc9a31_selector(), calldata)
  end

  def exec_vm_log_aabc9a31(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_aabc9a31(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_aabc9a31_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_aabc9a31_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_aabc9a31(p0, p1, p2, p3), exec_opts)
  end

  def log_ab085ae6_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_ab085ae6(p0, p1, p2, p3) do
    ABI.encode(log_ab085ae6_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_ab085ae6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_ab085ae6(p0, p1, p2, p3), opts)
  end

  def build_trx_log_ab085ae6(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_ab085ae6(p0, p1, p2, p3)}
  end

  def call_log_ab085ae6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_ab085ae6(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_ab085ae6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_ab085ae6(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_ab085ae6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_ab085ae6(p0, p1, p2, p3), opts)
  end

  def decode_log_ab085ae6_call(<<171, 8, 90, 230>> <> calldata) do
    _signature = hex!("0xab085ae6")
    ABI.decode(log_ab085ae6_selector(), calldata)
  end

  def exec_vm_log_ab085ae6(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_ab085ae6(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_ab085ae6_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_ab085ae6_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_ab085ae6(p0, p1, p2, p3), exec_opts)
  end

  def log_abf73a98_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_abf73a98(p0, p1, p2, p3) do
    ABI.encode(log_abf73a98_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_abf73a98(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_abf73a98(p0, p1, p2, p3), opts)
  end

  def build_trx_log_abf73a98(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_abf73a98(p0, p1, p2, p3)}
  end

  def call_log_abf73a98(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_abf73a98(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_abf73a98(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_abf73a98(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_abf73a98(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_abf73a98(p0, p1, p2, p3), opts)
  end

  def decode_log_abf73a98_call(<<171, 247, 58, 152>> <> calldata) do
    _signature = hex!("0xabf73a98")
    ABI.decode(log_abf73a98_selector(), calldata)
  end

  def exec_vm_log_abf73a98(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_abf73a98(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_abf73a98_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_abf73a98_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_abf73a98(p0, p1, p2, p3), exec_opts)
  end

  def log_ade052c7_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :address},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_ade052c7(p0, p1, p2, p3) do
    ABI.encode(log_ade052c7_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_ade052c7(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_ade052c7(p0, p1, p2, p3), opts)
  end

  def build_trx_log_ade052c7(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_ade052c7(p0, p1, p2, p3)}
  end

  def call_log_ade052c7(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_ade052c7(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_ade052c7(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_ade052c7(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_ade052c7(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_ade052c7(p0, p1, p2, p3), opts)
  end

  def decode_log_ade052c7_call(<<173, 224, 82, 199>> <> calldata) do
    _signature = hex!("0xade052c7")
    ABI.decode(log_ade052c7_selector(), calldata)
  end

  def exec_vm_log_ade052c7(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_ade052c7(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_ade052c7_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_ade052c7_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_ade052c7(p0, p1, p2, p3), exec_opts)
  end

  def log_ae2ec581_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :string},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_ae2ec581(p0, p1, p2, p3) do
    ABI.encode(log_ae2ec581_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_ae2ec581(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_ae2ec581(p0, p1, p2, p3), opts)
  end

  def build_trx_log_ae2ec581(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_ae2ec581(p0, p1, p2, p3)}
  end

  def call_log_ae2ec581(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_ae2ec581(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_ae2ec581(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_ae2ec581(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_ae2ec581(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_ae2ec581(p0, p1, p2, p3), opts)
  end

  def decode_log_ae2ec581_call(<<174, 46, 197, 129>> <> calldata) do
    _signature = hex!("0xae2ec581")
    ABI.decode(log_ae2ec581_selector(), calldata)
  end

  def exec_vm_log_ae2ec581(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_ae2ec581(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_ae2ec581_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_ae2ec581_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_ae2ec581(p0, p1, p2, p3), exec_opts)
  end

  def log_b028c9bd_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :string},
        %{name: "p2", type: :string},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_b028c9bd(p0, p1, p2, p3) do
    ABI.encode(log_b028c9bd_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_b028c9bd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_b028c9bd(p0, p1, p2, p3), opts)
  end

  def build_trx_log_b028c9bd(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_b028c9bd(p0, p1, p2, p3)}
  end

  def call_log_b028c9bd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_b028c9bd(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_b028c9bd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_b028c9bd(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_b028c9bd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_b028c9bd(p0, p1, p2, p3), opts)
  end

  def decode_log_b028c9bd_call(<<176, 40, 201, 189>> <> calldata) do
    _signature = hex!("0xb028c9bd")
    ABI.decode(log_b028c9bd_selector(), calldata)
  end

  def exec_vm_log_b028c9bd(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_b028c9bd(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_b028c9bd_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_b028c9bd_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_b028c9bd(p0, p1, p2, p3), exec_opts)
  end

  def log_b076847f_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :string},
        %{name: "p2", type: :string}
      ]
    }
  end

  def encode_log_b076847f(p0, p1, p2) do
    ABI.encode(log_b076847f_selector(), [p0, p1, p2])
  end

  def prepare_log_b076847f(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_b076847f(p0, p1, p2), opts)
  end

  def build_trx_log_b076847f(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_b076847f(p0, p1, p2)}
  end

  def call_log_b076847f(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_b076847f(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_b076847f(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_b076847f(contract, p0, p1, p2), opts)
  end

  def execute_log_b076847f(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_b076847f(p0, p1, p2), opts)
  end

  def decode_log_b076847f_call(<<176, 118, 132, 127>> <> calldata) do
    _signature = hex!("0xb076847f")
    ABI.decode(log_b076847f_selector(), calldata)
  end

  def exec_vm_log_b076847f(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_b076847f(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_b076847f_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_b076847f_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_b076847f(p0, p1, p2), exec_opts)
  end

  def log_b0e0f9b5_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :string},
        %{name: "p2", type: :bool}
      ]
    }
  end

  def encode_log_b0e0f9b5(p0, p1, p2) do
    ABI.encode(log_b0e0f9b5_selector(), [p0, p1, p2])
  end

  def prepare_log_b0e0f9b5(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_b0e0f9b5(p0, p1, p2), opts)
  end

  def build_trx_log_b0e0f9b5(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_b0e0f9b5(p0, p1, p2)}
  end

  def call_log_b0e0f9b5(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_b0e0f9b5(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_b0e0f9b5(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_b0e0f9b5(contract, p0, p1, p2), opts)
  end

  def execute_log_b0e0f9b5(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_b0e0f9b5(p0, p1, p2), opts)
  end

  def decode_log_b0e0f9b5_call(<<176, 224, 249, 181>> <> calldata) do
    _signature = hex!("0xb0e0f9b5")
    ABI.decode(log_b0e0f9b5_selector(), calldata)
  end

  def exec_vm_log_b0e0f9b5(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_b0e0f9b5(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_b0e0f9b5_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_b0e0f9b5_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_b0e0f9b5(p0, p1, p2), exec_opts)
  end

  def log_b115611f_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :string},
        %{name: "p2", type: :string}
      ]
    }
  end

  def encode_log_b115611f(p0, p1, p2) do
    ABI.encode(log_b115611f_selector(), [p0, p1, p2])
  end

  def prepare_log_b115611f(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_b115611f(p0, p1, p2), opts)
  end

  def build_trx_log_b115611f(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_b115611f(p0, p1, p2)}
  end

  def call_log_b115611f(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_b115611f(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_b115611f(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_b115611f(contract, p0, p1, p2), opts)
  end

  def execute_log_b115611f(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_b115611f(p0, p1, p2), opts)
  end

  def decode_log_b115611f_call(<<177, 21, 97, 31>> <> calldata) do
    _signature = hex!("0xb115611f")
    ABI.decode(log_b115611f_selector(), calldata)
  end

  def exec_vm_log_b115611f(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_b115611f(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_b115611f_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_b115611f_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_b115611f(p0, p1, p2), exec_opts)
  end

  def log_b3a6b6bd_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :string},
        %{name: "p2", type: :string},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_b3a6b6bd(p0, p1, p2, p3) do
    ABI.encode(log_b3a6b6bd_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_b3a6b6bd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_b3a6b6bd(p0, p1, p2, p3), opts)
  end

  def build_trx_log_b3a6b6bd(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_b3a6b6bd(p0, p1, p2, p3)}
  end

  def call_log_b3a6b6bd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_b3a6b6bd(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_b3a6b6bd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_b3a6b6bd(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_b3a6b6bd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_b3a6b6bd(p0, p1, p2, p3), opts)
  end

  def decode_log_b3a6b6bd_call(<<179, 166, 182, 189>> <> calldata) do
    _signature = hex!("0xb3a6b6bd")
    ABI.decode(log_b3a6b6bd_selector(), calldata)
  end

  def exec_vm_log_b3a6b6bd(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_b3a6b6bd(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_b3a6b6bd_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_b3a6b6bd_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_b3a6b6bd(p0, p1, p2, p3), exec_opts)
  end

  def log_b4c314ff_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :address},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_b4c314ff(p0, p1, p2, p3) do
    ABI.encode(log_b4c314ff_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_b4c314ff(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_b4c314ff(p0, p1, p2, p3), opts)
  end

  def build_trx_log_b4c314ff(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_b4c314ff(p0, p1, p2, p3)}
  end

  def call_log_b4c314ff(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_b4c314ff(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_b4c314ff(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_b4c314ff(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_b4c314ff(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_b4c314ff(p0, p1, p2, p3), opts)
  end

  def decode_log_b4c314ff_call(<<180, 195, 20, 255>> <> calldata) do
    _signature = hex!("0xb4c314ff")
    ABI.decode(log_b4c314ff_selector(), calldata)
  end

  def exec_vm_log_b4c314ff(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_b4c314ff(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_b4c314ff_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_b4c314ff_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_b4c314ff(p0, p1, p2, p3), exec_opts)
  end

  def log_b59dbd60_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :address},
        %{name: "p2", type: :address},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_b59dbd60(p0, p1, p2, p3) do
    ABI.encode(log_b59dbd60_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_b59dbd60(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_b59dbd60(p0, p1, p2, p3), opts)
  end

  def build_trx_log_b59dbd60(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_b59dbd60(p0, p1, p2, p3)}
  end

  def call_log_b59dbd60(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_b59dbd60(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_b59dbd60(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_b59dbd60(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_b59dbd60(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_b59dbd60(p0, p1, p2, p3), opts)
  end

  def decode_log_b59dbd60_call(<<181, 157, 189, 96>> <> calldata) do
    _signature = hex!("0xb59dbd60")
    ABI.decode(log_b59dbd60_selector(), calldata)
  end

  def exec_vm_log_b59dbd60(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_b59dbd60(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_b59dbd60_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_b59dbd60_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_b59dbd60(p0, p1, p2, p3), exec_opts)
  end

  def log_b60e72cc_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: :string}, %{name: "p1", type: {:uint, 256}}]
    }
  end

  def encode_log_b60e72cc(p0, p1) do
    ABI.encode(log_b60e72cc_selector(), [p0, p1])
  end

  def prepare_log_b60e72cc(contract, p0, p1, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_b60e72cc(p0, p1), opts)
  end

  def build_trx_log_b60e72cc(contract, p0, p1) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_b60e72cc(p0, p1)}
  end

  def call_log_b60e72cc(contract, p0, p1, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_b60e72cc(contract, p0, p1), opts)
  end

  def estimate_gas_log_b60e72cc(contract, p0, p1, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_b60e72cc(contract, p0, p1), opts)
  end

  def execute_log_b60e72cc(contract, p0, p1, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_b60e72cc(p0, p1), opts)
  end

  def decode_log_b60e72cc_call(<<182, 14, 114, 204>> <> calldata) do
    _signature = hex!("0xb60e72cc")
    ABI.decode(log_b60e72cc_selector(), calldata)
  end

  def exec_vm_log_b60e72cc(p0, p1, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_b60e72cc(p0, p1), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_b60e72cc_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_b60e72cc_raw(p0, p1, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_b60e72cc(p0, p1), exec_opts)
  end

  def log_b69bcaf6_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_b69bcaf6(p0, p1, p2) do
    ABI.encode(log_b69bcaf6_selector(), [p0, p1, p2])
  end

  def prepare_log_b69bcaf6(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_b69bcaf6(p0, p1, p2), opts)
  end

  def build_trx_log_b69bcaf6(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_b69bcaf6(p0, p1, p2)}
  end

  def call_log_b69bcaf6(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_b69bcaf6(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_b69bcaf6(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_b69bcaf6(contract, p0, p1, p2), opts)
  end

  def execute_log_b69bcaf6(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_b69bcaf6(p0, p1, p2), opts)
  end

  def decode_log_b69bcaf6_call(<<182, 155, 202, 246>> <> calldata) do
    _signature = hex!("0xb69bcaf6")
    ABI.decode(log_b69bcaf6_selector(), calldata)
  end

  def exec_vm_log_b69bcaf6(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_b69bcaf6(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_b69bcaf6_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_b69bcaf6_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_b69bcaf6(p0, p1, p2), exec_opts)
  end

  def log_b6f577a1_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_b6f577a1(p0, p1, p2, p3) do
    ABI.encode(log_b6f577a1_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_b6f577a1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_b6f577a1(p0, p1, p2, p3), opts)
  end

  def build_trx_log_b6f577a1(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_b6f577a1(p0, p1, p2, p3)}
  end

  def call_log_b6f577a1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_b6f577a1(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_b6f577a1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_b6f577a1(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_b6f577a1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_b6f577a1(p0, p1, p2, p3), opts)
  end

  def decode_log_b6f577a1_call(<<182, 245, 119, 161>> <> calldata) do
    _signature = hex!("0xb6f577a1")
    ABI.decode(log_b6f577a1_selector(), calldata)
  end

  def exec_vm_log_b6f577a1(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_b6f577a1(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_b6f577a1_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_b6f577a1_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_b6f577a1(p0, p1, p2, p3), exec_opts)
  end

  def log_b7b914ca_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :string},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_b7b914ca(p0, p1, p2, p3) do
    ABI.encode(log_b7b914ca_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_b7b914ca(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_b7b914ca(p0, p1, p2, p3), opts)
  end

  def build_trx_log_b7b914ca(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_b7b914ca(p0, p1, p2, p3)}
  end

  def call_log_b7b914ca(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_b7b914ca(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_b7b914ca(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_b7b914ca(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_b7b914ca(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_b7b914ca(p0, p1, p2, p3), opts)
  end

  def decode_log_b7b914ca_call(<<183, 185, 20, 202>> <> calldata) do
    _signature = hex!("0xb7b914ca")
    ABI.decode(log_b7b914ca_selector(), calldata)
  end

  def exec_vm_log_b7b914ca(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_b7b914ca(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_b7b914ca_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_b7b914ca_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_b7b914ca(p0, p1, p2, p3), exec_opts)
  end

  def log_b857163a_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :string},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_b857163a(p0, p1, p2, p3) do
    ABI.encode(log_b857163a_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_b857163a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_b857163a(p0, p1, p2, p3), opts)
  end

  def build_trx_log_b857163a(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_b857163a(p0, p1, p2, p3)}
  end

  def call_log_b857163a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_b857163a(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_b857163a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_b857163a(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_b857163a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_b857163a(p0, p1, p2, p3), opts)
  end

  def decode_log_b857163a_call(<<184, 87, 22, 58>> <> calldata) do
    _signature = hex!("0xb857163a")
    ABI.decode(log_b857163a_selector(), calldata)
  end

  def exec_vm_log_b857163a(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_b857163a(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_b857163a_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_b857163a_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_b857163a(p0, p1, p2, p3), exec_opts)
  end

  def log_ba535d9c_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :string},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_ba535d9c(p0, p1, p2, p3) do
    ABI.encode(log_ba535d9c_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_ba535d9c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_ba535d9c(p0, p1, p2, p3), opts)
  end

  def build_trx_log_ba535d9c(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_ba535d9c(p0, p1, p2, p3)}
  end

  def call_log_ba535d9c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_ba535d9c(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_ba535d9c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_ba535d9c(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_ba535d9c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_ba535d9c(p0, p1, p2, p3), opts)
  end

  def decode_log_ba535d9c_call(<<186, 83, 93, 156>> <> calldata) do
    _signature = hex!("0xba535d9c")
    ABI.decode(log_ba535d9c_selector(), calldata)
  end

  def exec_vm_log_ba535d9c(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_ba535d9c(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_ba535d9c_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_ba535d9c_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_ba535d9c(p0, p1, p2, p3), exec_opts)
  end

  def log_bc0b61fe_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :string},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_bc0b61fe(p0, p1, p2, p3) do
    ABI.encode(log_bc0b61fe_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_bc0b61fe(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bc0b61fe(p0, p1, p2, p3), opts)
  end

  def build_trx_log_bc0b61fe(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bc0b61fe(p0, p1, p2, p3)}
  end

  def call_log_bc0b61fe(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bc0b61fe(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_bc0b61fe(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bc0b61fe(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_bc0b61fe(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bc0b61fe(p0, p1, p2, p3), opts)
  end

  def decode_log_bc0b61fe_call(<<188, 11, 97, 254>> <> calldata) do
    _signature = hex!("0xbc0b61fe")
    ABI.decode(log_bc0b61fe_selector(), calldata)
  end

  def exec_vm_log_bc0b61fe(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bc0b61fe(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_bc0b61fe_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bc0b61fe_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bc0b61fe(p0, p1, p2, p3), exec_opts)
  end

  def log_bcfd9be0_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :address},
        %{name: "p2", type: :address}
      ]
    }
  end

  def encode_log_bcfd9be0(p0, p1, p2) do
    ABI.encode(log_bcfd9be0_selector(), [p0, p1, p2])
  end

  def prepare_log_bcfd9be0(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bcfd9be0(p0, p1, p2), opts)
  end

  def build_trx_log_bcfd9be0(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bcfd9be0(p0, p1, p2)}
  end

  def call_log_bcfd9be0(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bcfd9be0(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_bcfd9be0(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bcfd9be0(contract, p0, p1, p2), opts)
  end

  def execute_log_bcfd9be0(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bcfd9be0(p0, p1, p2), opts)
  end

  def decode_log_bcfd9be0_call(<<188, 253, 155, 224>> <> calldata) do
    _signature = hex!("0xbcfd9be0")
    ABI.decode(log_bcfd9be0_selector(), calldata)
  end

  def exec_vm_log_bcfd9be0(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bcfd9be0(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_bcfd9be0_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bcfd9be0_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bcfd9be0(p0, p1, p2), exec_opts)
  end

  def log_be553481_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :address},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_be553481(p0, p1, p2, p3) do
    ABI.encode(log_be553481_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_be553481(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_be553481(p0, p1, p2, p3), opts)
  end

  def build_trx_log_be553481(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_be553481(p0, p1, p2, p3)}
  end

  def call_log_be553481(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_be553481(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_be553481(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_be553481(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_be553481(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_be553481(p0, p1, p2, p3), opts)
  end

  def decode_log_be553481_call(<<190, 85, 52, 129>> <> calldata) do
    _signature = hex!("0xbe553481")
    ABI.decode(log_be553481_selector(), calldata)
  end

  def exec_vm_log_be553481(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_be553481(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_be553481_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_be553481_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_be553481(p0, p1, p2, p3), exec_opts)
  end

  def log_be984353_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_be984353(p0, p1, p2, p3) do
    ABI.encode(log_be984353_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_be984353(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_be984353(p0, p1, p2, p3), opts)
  end

  def build_trx_log_be984353(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_be984353(p0, p1, p2, p3)}
  end

  def call_log_be984353(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_be984353(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_be984353(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_be984353(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_be984353(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_be984353(p0, p1, p2, p3), opts)
  end

  def decode_log_be984353_call(<<190, 152, 67, 83>> <> calldata) do
    _signature = hex!("0xbe984353")
    ABI.decode(log_be984353_selector(), calldata)
  end

  def exec_vm_log_be984353(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_be984353(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_be984353_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_be984353_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_be984353(p0, p1, p2, p3), exec_opts)
  end

  def log_bf01f891_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :string},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_bf01f891(p0, p1, p2, p3) do
    ABI.encode(log_bf01f891_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_bf01f891(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bf01f891(p0, p1, p2, p3), opts)
  end

  def build_trx_log_bf01f891(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bf01f891(p0, p1, p2, p3)}
  end

  def call_log_bf01f891(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bf01f891(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_bf01f891(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bf01f891(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_bf01f891(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bf01f891(p0, p1, p2, p3), opts)
  end

  def decode_log_bf01f891_call(<<191, 1, 248, 145>> <> calldata) do
    _signature = hex!("0xbf01f891")
    ABI.decode(log_bf01f891_selector(), calldata)
  end

  def exec_vm_log_bf01f891(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bf01f891(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_bf01f891_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bf01f891_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bf01f891(p0, p1, p2, p3), exec_opts)
  end

  def log_c0a302d8_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :address},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_c0a302d8(p0, p1, p2, p3) do
    ABI.encode(log_c0a302d8_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_c0a302d8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_c0a302d8(p0, p1, p2, p3), opts)
  end

  def build_trx_log_c0a302d8(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_c0a302d8(p0, p1, p2, p3)}
  end

  def call_log_c0a302d8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_c0a302d8(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_c0a302d8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_c0a302d8(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_c0a302d8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_c0a302d8(p0, p1, p2, p3), opts)
  end

  def decode_log_c0a302d8_call(<<192, 163, 2, 216>> <> calldata) do
    _signature = hex!("0xc0a302d8")
    ABI.decode(log_c0a302d8_selector(), calldata)
  end

  def exec_vm_log_c0a302d8(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_c0a302d8(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_c0a302d8_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_c0a302d8_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_c0a302d8(p0, p1, p2, p3), exec_opts)
  end

  def log_c21f64c7_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :address},
        %{name: "p2", type: :string},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_c21f64c7(p0, p1, p2, p3) do
    ABI.encode(log_c21f64c7_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_c21f64c7(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_c21f64c7(p0, p1, p2, p3), opts)
  end

  def build_trx_log_c21f64c7(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_c21f64c7(p0, p1, p2, p3)}
  end

  def call_log_c21f64c7(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_c21f64c7(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_c21f64c7(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_c21f64c7(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_c21f64c7(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_c21f64c7(p0, p1, p2, p3), opts)
  end

  def decode_log_c21f64c7_call(<<194, 31, 100, 199>> <> calldata) do
    _signature = hex!("0xc21f64c7")
    ABI.decode(log_c21f64c7_selector(), calldata)
  end

  def exec_vm_log_c21f64c7(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_c21f64c7(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_c21f64c7_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_c21f64c7_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_c21f64c7(p0, p1, p2, p3), exec_opts)
  end

  def log_c371c7db_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :string},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_c371c7db(p0, p1, p2, p3) do
    ABI.encode(log_c371c7db_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_c371c7db(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_c371c7db(p0, p1, p2, p3), opts)
  end

  def build_trx_log_c371c7db(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_c371c7db(p0, p1, p2, p3)}
  end

  def call_log_c371c7db(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_c371c7db(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_c371c7db(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_c371c7db(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_c371c7db(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_c371c7db(p0, p1, p2, p3), opts)
  end

  def decode_log_c371c7db_call(<<195, 113, 199, 219>> <> calldata) do
    _signature = hex!("0xc371c7db")
    ABI.decode(log_c371c7db_selector(), calldata)
  end

  def exec_vm_log_c371c7db(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_c371c7db(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_c371c7db_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_c371c7db_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_c371c7db(p0, p1, p2, p3), exec_opts)
  end

  def log_c3a8a654_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :string},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_c3a8a654(p0, p1, p2, p3) do
    ABI.encode(log_c3a8a654_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_c3a8a654(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_c3a8a654(p0, p1, p2, p3), opts)
  end

  def build_trx_log_c3a8a654(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_c3a8a654(p0, p1, p2, p3)}
  end

  def call_log_c3a8a654(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_c3a8a654(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_c3a8a654(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_c3a8a654(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_c3a8a654(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_c3a8a654(p0, p1, p2, p3), opts)
  end

  def decode_log_c3a8a654_call(<<195, 168, 166, 84>> <> calldata) do
    _signature = hex!("0xc3a8a654")
    ABI.decode(log_c3a8a654_selector(), calldata)
  end

  def exec_vm_log_c3a8a654(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_c3a8a654(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_c3a8a654_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_c3a8a654_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_c3a8a654(p0, p1, p2, p3), exec_opts)
  end

  def log_c3b55635_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: :string}, %{name: "p1", type: :bool}]
    }
  end

  def encode_log_c3b55635(p0, p1) do
    ABI.encode(log_c3b55635_selector(), [p0, p1])
  end

  def prepare_log_c3b55635(contract, p0, p1, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_c3b55635(p0, p1), opts)
  end

  def build_trx_log_c3b55635(contract, p0, p1) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_c3b55635(p0, p1)}
  end

  def call_log_c3b55635(contract, p0, p1, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_c3b55635(contract, p0, p1), opts)
  end

  def estimate_gas_log_c3b55635(contract, p0, p1, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_c3b55635(contract, p0, p1), opts)
  end

  def execute_log_c3b55635(contract, p0, p1, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_c3b55635(p0, p1), opts)
  end

  def decode_log_c3b55635_call(<<195, 181, 86, 53>> <> calldata) do
    _signature = hex!("0xc3b55635")
    ABI.decode(log_c3b55635_selector(), calldata)
  end

  def exec_vm_log_c3b55635(p0, p1, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_c3b55635(p0, p1), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_c3b55635_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_c3b55635_raw(p0, p1, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_c3b55635(p0, p1), exec_opts)
  end

  def log_c3fc3970_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :string}
      ]
    }
  end

  def encode_log_c3fc3970(p0, p1, p2) do
    ABI.encode(log_c3fc3970_selector(), [p0, p1, p2])
  end

  def prepare_log_c3fc3970(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_c3fc3970(p0, p1, p2), opts)
  end

  def build_trx_log_c3fc3970(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_c3fc3970(p0, p1, p2)}
  end

  def call_log_c3fc3970(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_c3fc3970(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_c3fc3970(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_c3fc3970(contract, p0, p1, p2), opts)
  end

  def execute_log_c3fc3970(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_c3fc3970(p0, p1, p2), opts)
  end

  def decode_log_c3fc3970_call(<<195, 252, 57, 112>> <> calldata) do
    _signature = hex!("0xc3fc3970")
    ABI.decode(log_c3fc3970_selector(), calldata)
  end

  def exec_vm_log_c3fc3970(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_c3fc3970(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_c3fc3970_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_c3fc3970_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_c3fc3970(p0, p1, p2), exec_opts)
  end

  def log_c4643e20_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :bool},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_c4643e20(p0, p1, p2, p3) do
    ABI.encode(log_c4643e20_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_c4643e20(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_c4643e20(p0, p1, p2, p3), opts)
  end

  def build_trx_log_c4643e20(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_c4643e20(p0, p1, p2, p3)}
  end

  def call_log_c4643e20(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_c4643e20(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_c4643e20(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_c4643e20(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_c4643e20(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_c4643e20(p0, p1, p2, p3), opts)
  end

  def decode_log_c4643e20_call(<<196, 100, 62, 32>> <> calldata) do
    _signature = hex!("0xc4643e20")
    ABI.decode(log_c4643e20_selector(), calldata)
  end

  def exec_vm_log_c4643e20(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_c4643e20(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_c4643e20_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_c4643e20_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_c4643e20(p0, p1, p2, p3), exec_opts)
  end

  def log_c598d185_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_c598d185(p0, p1, p2, p3) do
    ABI.encode(log_c598d185_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_c598d185(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_c598d185(p0, p1, p2, p3), opts)
  end

  def build_trx_log_c598d185(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_c598d185(p0, p1, p2, p3)}
  end

  def call_log_c598d185(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_c598d185(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_c598d185(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_c598d185(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_c598d185(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_c598d185(p0, p1, p2, p3), opts)
  end

  def decode_log_c598d185_call(<<197, 152, 209, 133>> <> calldata) do
    _signature = hex!("0xc598d185")
    ABI.decode(log_c598d185_selector(), calldata)
  end

  def exec_vm_log_c598d185(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_c598d185(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_c598d185_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_c598d185_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_c598d185(p0, p1, p2, p3), exec_opts)
  end

  def log_c5ad85f9_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_c5ad85f9(p0, p1, p2, p3) do
    ABI.encode(log_c5ad85f9_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_c5ad85f9(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_c5ad85f9(p0, p1, p2, p3), opts)
  end

  def build_trx_log_c5ad85f9(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_c5ad85f9(p0, p1, p2, p3)}
  end

  def call_log_c5ad85f9(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_c5ad85f9(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_c5ad85f9(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_c5ad85f9(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_c5ad85f9(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_c5ad85f9(p0, p1, p2, p3), opts)
  end

  def decode_log_c5ad85f9_call(<<197, 173, 133, 249>> <> calldata) do
    _signature = hex!("0xc5ad85f9")
    ABI.decode(log_c5ad85f9_selector(), calldata)
  end

  def exec_vm_log_c5ad85f9(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_c5ad85f9(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_c5ad85f9_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_c5ad85f9_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_c5ad85f9(p0, p1, p2, p3), exec_opts)
  end

  def log_c67ea9d1_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :string},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_c67ea9d1(p0, p1, p2, p3) do
    ABI.encode(log_c67ea9d1_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_c67ea9d1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_c67ea9d1(p0, p1, p2, p3), opts)
  end

  def build_trx_log_c67ea9d1(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_c67ea9d1(p0, p1, p2, p3)}
  end

  def call_log_c67ea9d1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_c67ea9d1(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_c67ea9d1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_c67ea9d1(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_c67ea9d1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_c67ea9d1(p0, p1, p2, p3), opts)
  end

  def decode_log_c67ea9d1_call(<<198, 126, 169, 209>> <> calldata) do
    _signature = hex!("0xc67ea9d1")
    ABI.decode(log_c67ea9d1_selector(), calldata)
  end

  def exec_vm_log_c67ea9d1(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_c67ea9d1(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_c67ea9d1_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_c67ea9d1_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_c67ea9d1(p0, p1, p2, p3), exec_opts)
  end

  def log_c6acc7a8_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :bool},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_c6acc7a8(p0, p1, p2, p3) do
    ABI.encode(log_c6acc7a8_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_c6acc7a8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_c6acc7a8(p0, p1, p2, p3), opts)
  end

  def build_trx_log_c6acc7a8(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_c6acc7a8(p0, p1, p2, p3)}
  end

  def call_log_c6acc7a8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_c6acc7a8(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_c6acc7a8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_c6acc7a8(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_c6acc7a8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_c6acc7a8(p0, p1, p2, p3), opts)
  end

  def decode_log_c6acc7a8_call(<<198, 172, 199, 168>> <> calldata) do
    _signature = hex!("0xc6acc7a8")
    ABI.decode(log_c6acc7a8_selector(), calldata)
  end

  def exec_vm_log_c6acc7a8(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_c6acc7a8(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_c6acc7a8_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_c6acc7a8_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_c6acc7a8(p0, p1, p2, p3), exec_opts)
  end

  def log_c91d5ed4_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :address},
        %{name: "p2", type: :bool}
      ]
    }
  end

  def encode_log_c91d5ed4(p0, p1, p2) do
    ABI.encode(log_c91d5ed4_selector(), [p0, p1, p2])
  end

  def prepare_log_c91d5ed4(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_c91d5ed4(p0, p1, p2), opts)
  end

  def build_trx_log_c91d5ed4(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_c91d5ed4(p0, p1, p2)}
  end

  def call_log_c91d5ed4(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_c91d5ed4(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_c91d5ed4(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_c91d5ed4(contract, p0, p1, p2), opts)
  end

  def execute_log_c91d5ed4(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_c91d5ed4(p0, p1, p2), opts)
  end

  def decode_log_c91d5ed4_call(<<201, 29, 94, 212>> <> calldata) do
    _signature = hex!("0xc91d5ed4")
    ABI.decode(log_c91d5ed4_selector(), calldata)
  end

  def exec_vm_log_c91d5ed4(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_c91d5ed4(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_c91d5ed4_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_c91d5ed4_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_c91d5ed4(p0, p1, p2), exec_opts)
  end

  def log_c95958d6_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :bool},
        %{name: "p2", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_c95958d6(p0, p1, p2) do
    ABI.encode(log_c95958d6_selector(), [p0, p1, p2])
  end

  def prepare_log_c95958d6(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_c95958d6(p0, p1, p2), opts)
  end

  def build_trx_log_c95958d6(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_c95958d6(p0, p1, p2)}
  end

  def call_log_c95958d6(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_c95958d6(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_c95958d6(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_c95958d6(contract, p0, p1, p2), opts)
  end

  def execute_log_c95958d6(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_c95958d6(p0, p1, p2), opts)
  end

  def decode_log_c95958d6_call(<<201, 89, 88, 214>> <> calldata) do
    _signature = hex!("0xc95958d6")
    ABI.decode(log_c95958d6_selector(), calldata)
  end

  def exec_vm_log_c95958d6(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_c95958d6(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_c95958d6_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_c95958d6_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_c95958d6(p0, p1, p2), exec_opts)
  end

  def log_ca47c4eb_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_ca47c4eb(p0, p1, p2) do
    ABI.encode(log_ca47c4eb_selector(), [p0, p1, p2])
  end

  def prepare_log_ca47c4eb(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_ca47c4eb(p0, p1, p2), opts)
  end

  def build_trx_log_ca47c4eb(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_ca47c4eb(p0, p1, p2)}
  end

  def call_log_ca47c4eb(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_ca47c4eb(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_ca47c4eb(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_ca47c4eb(contract, p0, p1, p2), opts)
  end

  def execute_log_ca47c4eb(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_ca47c4eb(p0, p1, p2), opts)
  end

  def decode_log_ca47c4eb_call(<<202, 71, 196, 235>> <> calldata) do
    _signature = hex!("0xca47c4eb")
    ABI.decode(log_ca47c4eb_selector(), calldata)
  end

  def exec_vm_log_ca47c4eb(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_ca47c4eb(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_ca47c4eb_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_ca47c4eb_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_ca47c4eb(p0, p1, p2), exec_opts)
  end

  def log_ca7733b1_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :bool}
      ]
    }
  end

  def encode_log_ca7733b1(p0, p1, p2) do
    ABI.encode(log_ca7733b1_selector(), [p0, p1, p2])
  end

  def prepare_log_ca7733b1(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_ca7733b1(p0, p1, p2), opts)
  end

  def build_trx_log_ca7733b1(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_ca7733b1(p0, p1, p2)}
  end

  def call_log_ca7733b1(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_ca7733b1(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_ca7733b1(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_ca7733b1(contract, p0, p1, p2), opts)
  end

  def execute_log_ca7733b1(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_ca7733b1(p0, p1, p2), opts)
  end

  def decode_log_ca7733b1_call(<<202, 119, 51, 177>> <> calldata) do
    _signature = hex!("0xca7733b1")
    ABI.decode(log_ca7733b1_selector(), calldata)
  end

  def exec_vm_log_ca7733b1(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_ca7733b1(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_ca7733b1_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_ca7733b1_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_ca7733b1(p0, p1, p2), exec_opts)
  end

  def log_cac43479_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_cac43479(p0, p1, p2, p3) do
    ABI.encode(log_cac43479_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_cac43479(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_cac43479(p0, p1, p2, p3), opts)
  end

  def build_trx_log_cac43479(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_cac43479(p0, p1, p2, p3)}
  end

  def call_log_cac43479(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_cac43479(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_cac43479(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_cac43479(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_cac43479(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_cac43479(p0, p1, p2, p3), opts)
  end

  def decode_log_cac43479_call(<<202, 196, 52, 121>> <> calldata) do
    _signature = hex!("0xcac43479")
    ABI.decode(log_cac43479_selector(), calldata)
  end

  def exec_vm_log_cac43479(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_cac43479(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_cac43479_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_cac43479_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_cac43479(p0, p1, p2, p3), exec_opts)
  end

  def log_cc32ab07_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :address},
        %{name: "p2", type: :string},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_cc32ab07(p0, p1, p2, p3) do
    ABI.encode(log_cc32ab07_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_cc32ab07(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_cc32ab07(p0, p1, p2, p3), opts)
  end

  def build_trx_log_cc32ab07(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_cc32ab07(p0, p1, p2, p3)}
  end

  def call_log_cc32ab07(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_cc32ab07(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_cc32ab07(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_cc32ab07(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_cc32ab07(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_cc32ab07(p0, p1, p2, p3), opts)
  end

  def decode_log_cc32ab07_call(<<204, 50, 171, 7>> <> calldata) do
    _signature = hex!("0xcc32ab07")
    ABI.decode(log_cc32ab07_selector(), calldata)
  end

  def exec_vm_log_cc32ab07(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_cc32ab07(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_cc32ab07_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_cc32ab07_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_cc32ab07(p0, p1, p2, p3), exec_opts)
  end

  def log_ccf790a1_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :bool},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_ccf790a1(p0, p1, p2, p3) do
    ABI.encode(log_ccf790a1_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_ccf790a1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_ccf790a1(p0, p1, p2, p3), opts)
  end

  def build_trx_log_ccf790a1(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_ccf790a1(p0, p1, p2, p3)}
  end

  def call_log_ccf790a1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_ccf790a1(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_ccf790a1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_ccf790a1(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_ccf790a1(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_ccf790a1(p0, p1, p2, p3), opts)
  end

  def decode_log_ccf790a1_call(<<204, 247, 144, 161>> <> calldata) do
    _signature = hex!("0xccf790a1")
    ABI.decode(log_ccf790a1_selector(), calldata)
  end

  def exec_vm_log_ccf790a1(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_ccf790a1(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_ccf790a1_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_ccf790a1_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_ccf790a1(p0, p1, p2, p3), exec_opts)
  end

  def log_ceb5f4d7_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_ceb5f4d7(p0, p1, p2, p3) do
    ABI.encode(log_ceb5f4d7_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_ceb5f4d7(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_ceb5f4d7(p0, p1, p2, p3), opts)
  end

  def build_trx_log_ceb5f4d7(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_ceb5f4d7(p0, p1, p2, p3)}
  end

  def call_log_ceb5f4d7(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_ceb5f4d7(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_ceb5f4d7(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_ceb5f4d7(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_ceb5f4d7(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_ceb5f4d7(p0, p1, p2, p3), opts)
  end

  def decode_log_ceb5f4d7_call(<<206, 181, 244, 215>> <> calldata) do
    _signature = hex!("0xceb5f4d7")
    ABI.decode(log_ceb5f4d7_selector(), calldata)
  end

  def exec_vm_log_ceb5f4d7(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_ceb5f4d7(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_ceb5f4d7_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_ceb5f4d7_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_ceb5f4d7(p0, p1, p2, p3), exec_opts)
  end

  def log_cf009880_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :string},
        %{name: "p2", type: :bool},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_cf009880(p0, p1, p2, p3) do
    ABI.encode(log_cf009880_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_cf009880(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_cf009880(p0, p1, p2, p3), opts)
  end

  def build_trx_log_cf009880(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_cf009880(p0, p1, p2, p3)}
  end

  def call_log_cf009880(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_cf009880(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_cf009880(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_cf009880(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_cf009880(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_cf009880(p0, p1, p2, p3), opts)
  end

  def decode_log_cf009880_call(<<207, 0, 152, 128>> <> calldata) do
    _signature = hex!("0xcf009880")
    ABI.decode(log_cf009880_selector(), calldata)
  end

  def exec_vm_log_cf009880(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_cf009880(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_cf009880_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_cf009880_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_cf009880(p0, p1, p2, p3), exec_opts)
  end

  def log_cf020fb1_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :string},
        %{name: "p2", type: :bool}
      ]
    }
  end

  def encode_log_cf020fb1(p0, p1, p2) do
    ABI.encode(log_cf020fb1_selector(), [p0, p1, p2])
  end

  def prepare_log_cf020fb1(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_cf020fb1(p0, p1, p2), opts)
  end

  def build_trx_log_cf020fb1(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_cf020fb1(p0, p1, p2)}
  end

  def call_log_cf020fb1(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_cf020fb1(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_cf020fb1(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_cf020fb1(contract, p0, p1, p2), opts)
  end

  def execute_log_cf020fb1(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_cf020fb1(p0, p1, p2), opts)
  end

  def decode_log_cf020fb1_call(<<207, 2, 15, 177>> <> calldata) do
    _signature = hex!("0xcf020fb1")
    ABI.decode(log_cf020fb1_selector(), calldata)
  end

  def exec_vm_log_cf020fb1(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_cf020fb1(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_cf020fb1_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_cf020fb1_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_cf020fb1(p0, p1, p2), exec_opts)
  end

  def log_cf18105c_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :string},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_cf18105c(p0, p1, p2, p3) do
    ABI.encode(log_cf18105c_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_cf18105c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_cf18105c(p0, p1, p2, p3), opts)
  end

  def build_trx_log_cf18105c(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_cf18105c(p0, p1, p2, p3)}
  end

  def call_log_cf18105c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_cf18105c(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_cf18105c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_cf18105c(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_cf18105c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_cf18105c(p0, p1, p2, p3), opts)
  end

  def decode_log_cf18105c_call(<<207, 24, 16, 92>> <> calldata) do
    _signature = hex!("0xcf18105c")
    ABI.decode(log_cf18105c_selector(), calldata)
  end

  def exec_vm_log_cf18105c(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_cf18105c(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_cf18105c_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_cf18105c_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_cf18105c(p0, p1, p2, p3), exec_opts)
  end

  def log_cf394485_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_cf394485(p0, p1, p2, p3) do
    ABI.encode(log_cf394485_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_cf394485(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_cf394485(p0, p1, p2, p3), opts)
  end

  def build_trx_log_cf394485(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_cf394485(p0, p1, p2, p3)}
  end

  def call_log_cf394485(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_cf394485(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_cf394485(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_cf394485(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_cf394485(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_cf394485(p0, p1, p2, p3), opts)
  end

  def decode_log_cf394485_call(<<207, 57, 68, 133>> <> calldata) do
    _signature = hex!("0xcf394485")
    ABI.decode(log_cf394485_selector(), calldata)
  end

  def exec_vm_log_cf394485(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_cf394485(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_cf394485_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_cf394485_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_cf394485(p0, p1, p2, p3), exec_opts)
  end

  def log_d1ed7a3c_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_d1ed7a3c(p0, p1, p2) do
    ABI.encode(log_d1ed7a3c_selector(), [p0, p1, p2])
  end

  def prepare_log_d1ed7a3c(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_d1ed7a3c(p0, p1, p2), opts)
  end

  def build_trx_log_d1ed7a3c(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_d1ed7a3c(p0, p1, p2)}
  end

  def call_log_d1ed7a3c(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_d1ed7a3c(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_d1ed7a3c(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_d1ed7a3c(contract, p0, p1, p2), opts)
  end

  def execute_log_d1ed7a3c(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_d1ed7a3c(p0, p1, p2), opts)
  end

  def decode_log_d1ed7a3c_call(<<209, 237, 122, 60>> <> calldata) do
    _signature = hex!("0xd1ed7a3c")
    ABI.decode(log_d1ed7a3c_selector(), calldata)
  end

  def exec_vm_log_d1ed7a3c(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_d1ed7a3c(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_d1ed7a3c_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_d1ed7a3c_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_d1ed7a3c(p0, p1, p2), exec_opts)
  end

  def log_d2763667_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :address},
        %{name: "p2", type: :address}
      ]
    }
  end

  def encode_log_d2763667(p0, p1, p2) do
    ABI.encode(log_d2763667_selector(), [p0, p1, p2])
  end

  def prepare_log_d2763667(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_d2763667(p0, p1, p2), opts)
  end

  def build_trx_log_d2763667(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_d2763667(p0, p1, p2)}
  end

  def call_log_d2763667(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_d2763667(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_d2763667(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_d2763667(contract, p0, p1, p2), opts)
  end

  def execute_log_d2763667(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_d2763667(p0, p1, p2), opts)
  end

  def decode_log_d2763667_call(<<210, 118, 54, 103>> <> calldata) do
    _signature = hex!("0xd2763667")
    ABI.decode(log_d2763667_selector(), calldata)
  end

  def exec_vm_log_d2763667(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_d2763667(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_d2763667_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_d2763667_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_d2763667(p0, p1, p2), exec_opts)
  end

  def log_d2d423cd_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :string},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_d2d423cd(p0, p1, p2, p3) do
    ABI.encode(log_d2d423cd_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_d2d423cd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_d2d423cd(p0, p1, p2, p3), opts)
  end

  def build_trx_log_d2d423cd(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_d2d423cd(p0, p1, p2, p3)}
  end

  def call_log_d2d423cd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_d2d423cd(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_d2d423cd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_d2d423cd(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_d2d423cd(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_d2d423cd(p0, p1, p2, p3), opts)
  end

  def decode_log_d2d423cd_call(<<210, 212, 35, 205>> <> calldata) do
    _signature = hex!("0xd2d423cd")
    ABI.decode(log_d2d423cd_selector(), calldata)
  end

  def exec_vm_log_d2d423cd(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_d2d423cd(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_d2d423cd_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_d2d423cd_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_d2d423cd(p0, p1, p2, p3), exec_opts)
  end

  def log_d583c602_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :string},
        %{name: "p2", type: :string},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_d583c602(p0, p1, p2, p3) do
    ABI.encode(log_d583c602_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_d583c602(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_d583c602(p0, p1, p2, p3), opts)
  end

  def build_trx_log_d583c602(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_d583c602(p0, p1, p2, p3)}
  end

  def call_log_d583c602(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_d583c602(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_d583c602(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_d583c602(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_d583c602(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_d583c602(p0, p1, p2, p3), opts)
  end

  def decode_log_d583c602_call(<<213, 131, 198, 2>> <> calldata) do
    _signature = hex!("0xd583c602")
    ABI.decode(log_d583c602_selector(), calldata)
  end

  def exec_vm_log_d583c602(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_d583c602(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_d583c602_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_d583c602_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_d583c602(p0, p1, p2, p3), exec_opts)
  end

  def log_d6019f1c_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :address},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_d6019f1c(p0, p1, p2, p3) do
    ABI.encode(log_d6019f1c_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_d6019f1c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_d6019f1c(p0, p1, p2, p3), opts)
  end

  def build_trx_log_d6019f1c(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_d6019f1c(p0, p1, p2, p3)}
  end

  def call_log_d6019f1c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_d6019f1c(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_d6019f1c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_d6019f1c(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_d6019f1c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_d6019f1c(p0, p1, p2, p3), opts)
  end

  def decode_log_d6019f1c_call(<<214, 1, 159, 28>> <> calldata) do
    _signature = hex!("0xd6019f1c")
    ABI.decode(log_d6019f1c_selector(), calldata)
  end

  def exec_vm_log_d6019f1c(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_d6019f1c(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_d6019f1c_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_d6019f1c_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_d6019f1c(p0, p1, p2, p3), exec_opts)
  end

  def log_d6aefad2_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :string},
        %{name: "p2", type: :bool},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_d6aefad2(p0, p1, p2, p3) do
    ABI.encode(log_d6aefad2_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_d6aefad2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_d6aefad2(p0, p1, p2, p3), opts)
  end

  def build_trx_log_d6aefad2(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_d6aefad2(p0, p1, p2, p3)}
  end

  def call_log_d6aefad2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_d6aefad2(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_d6aefad2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_d6aefad2(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_d6aefad2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_d6aefad2(p0, p1, p2, p3), opts)
  end

  def decode_log_d6aefad2_call(<<214, 174, 250, 210>> <> calldata) do
    _signature = hex!("0xd6aefad2")
    ABI.decode(log_d6aefad2_selector(), calldata)
  end

  def exec_vm_log_d6aefad2(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_d6aefad2(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_d6aefad2_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_d6aefad2_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_d6aefad2(p0, p1, p2, p3), exec_opts)
  end

  def log_d812a167_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :address},
        %{name: "p2", type: :address},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_d812a167(p0, p1, p2, p3) do
    ABI.encode(log_d812a167_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_d812a167(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_d812a167(p0, p1, p2, p3), opts)
  end

  def build_trx_log_d812a167(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_d812a167(p0, p1, p2, p3)}
  end

  def call_log_d812a167(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_d812a167(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_d812a167(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_d812a167(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_d812a167(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_d812a167(p0, p1, p2, p3), opts)
  end

  def decode_log_d812a167_call(<<216, 18, 161, 103>> <> calldata) do
    _signature = hex!("0xd812a167")
    ABI.decode(log_d812a167_selector(), calldata)
  end

  def exec_vm_log_d812a167(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_d812a167(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_d812a167_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_d812a167_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_d812a167(p0, p1, p2, p3), exec_opts)
  end

  def log_daf0d4aa_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: :address}, %{name: "p1", type: :address}]
    }
  end

  def encode_log_daf0d4aa(p0, p1) do
    ABI.encode(log_daf0d4aa_selector(), [p0, p1])
  end

  def prepare_log_daf0d4aa(contract, p0, p1, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_daf0d4aa(p0, p1), opts)
  end

  def build_trx_log_daf0d4aa(contract, p0, p1) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_daf0d4aa(p0, p1)}
  end

  def call_log_daf0d4aa(contract, p0, p1, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_daf0d4aa(contract, p0, p1), opts)
  end

  def estimate_gas_log_daf0d4aa(contract, p0, p1, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_daf0d4aa(contract, p0, p1), opts)
  end

  def execute_log_daf0d4aa(contract, p0, p1, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_daf0d4aa(p0, p1), opts)
  end

  def decode_log_daf0d4aa_call(<<218, 240, 212, 170>> <> calldata) do
    _signature = hex!("0xdaf0d4aa")
    ABI.decode(log_daf0d4aa_selector(), calldata)
  end

  def exec_vm_log_daf0d4aa(p0, p1, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_daf0d4aa(p0, p1), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_daf0d4aa_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_daf0d4aa_raw(p0, p1, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_daf0d4aa(p0, p1), exec_opts)
  end

  def log_dbb4c247_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :string},
        %{name: "p2", type: :bool}
      ]
    }
  end

  def encode_log_dbb4c247(p0, p1, p2) do
    ABI.encode(log_dbb4c247_selector(), [p0, p1, p2])
  end

  def prepare_log_dbb4c247(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_dbb4c247(p0, p1, p2), opts)
  end

  def build_trx_log_dbb4c247(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_dbb4c247(p0, p1, p2)}
  end

  def call_log_dbb4c247(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_dbb4c247(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_dbb4c247(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_dbb4c247(contract, p0, p1, p2), opts)
  end

  def execute_log_dbb4c247(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_dbb4c247(p0, p1, p2), opts)
  end

  def decode_log_dbb4c247_call(<<219, 180, 194, 71>> <> calldata) do
    _signature = hex!("0xdbb4c247")
    ABI.decode(log_dbb4c247_selector(), calldata)
  end

  def exec_vm_log_dbb4c247(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_dbb4c247(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_dbb4c247_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_dbb4c247_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_dbb4c247(p0, p1, p2), exec_opts)
  end

  def log_dc5e935b_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :string},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_dc5e935b(p0, p1, p2, p3) do
    ABI.encode(log_dc5e935b_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_dc5e935b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_dc5e935b(p0, p1, p2, p3), opts)
  end

  def build_trx_log_dc5e935b(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_dc5e935b(p0, p1, p2, p3)}
  end

  def call_log_dc5e935b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_dc5e935b(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_dc5e935b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_dc5e935b(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_dc5e935b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_dc5e935b(p0, p1, p2, p3), opts)
  end

  def decode_log_dc5e935b_call(<<220, 94, 147, 91>> <> calldata) do
    _signature = hex!("0xdc5e935b")
    ABI.decode(log_dc5e935b_selector(), calldata)
  end

  def exec_vm_log_dc5e935b(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_dc5e935b(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_dc5e935b_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_dc5e935b_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_dc5e935b(p0, p1, p2, p3), exec_opts)
  end

  def log_ddb06521_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :address},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_ddb06521(p0, p1, p2, p3) do
    ABI.encode(log_ddb06521_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_ddb06521(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_ddb06521(p0, p1, p2, p3), opts)
  end

  def build_trx_log_ddb06521(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_ddb06521(p0, p1, p2, p3)}
  end

  def call_log_ddb06521(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_ddb06521(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_ddb06521(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_ddb06521(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_ddb06521(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_ddb06521(p0, p1, p2, p3), opts)
  end

  def decode_log_ddb06521_call(<<221, 176, 101, 33>> <> calldata) do
    _signature = hex!("0xddb06521")
    ABI.decode(log_ddb06521_selector(), calldata)
  end

  def exec_vm_log_ddb06521(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_ddb06521(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_ddb06521_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_ddb06521_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_ddb06521(p0, p1, p2, p3), exec_opts)
  end

  def log_dddb9561_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_dddb9561(p0, p1, p2, p3) do
    ABI.encode(log_dddb9561_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_dddb9561(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_dddb9561(p0, p1, p2, p3), opts)
  end

  def build_trx_log_dddb9561(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_dddb9561(p0, p1, p2, p3)}
  end

  def call_log_dddb9561(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_dddb9561(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_dddb9561(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_dddb9561(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_dddb9561(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_dddb9561(p0, p1, p2, p3), opts)
  end

  def decode_log_dddb9561_call(<<221, 219, 149, 97>> <> calldata) do
    _signature = hex!("0xdddb9561")
    ABI.decode(log_dddb9561_selector(), calldata)
  end

  def exec_vm_log_dddb9561(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_dddb9561(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_dddb9561_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_dddb9561_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_dddb9561(p0, p1, p2, p3), exec_opts)
  end

  def log_de03e774_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :bool},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_de03e774(p0, p1, p2, p3) do
    ABI.encode(log_de03e774_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_de03e774(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_de03e774(p0, p1, p2, p3), opts)
  end

  def build_trx_log_de03e774(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_de03e774(p0, p1, p2, p3)}
  end

  def call_log_de03e774(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_de03e774(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_de03e774(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_de03e774(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_de03e774(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_de03e774(p0, p1, p2, p3), opts)
  end

  def decode_log_de03e774_call(<<222, 3, 231, 116>> <> calldata) do
    _signature = hex!("0xde03e774")
    ABI.decode(log_de03e774_selector(), calldata)
  end

  def exec_vm_log_de03e774(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_de03e774(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_de03e774_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_de03e774_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_de03e774(p0, p1, p2, p3), exec_opts)
  end

  def log_de68f20a_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :string},
        %{name: "p2", type: :string},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_de68f20a(p0, p1, p2, p3) do
    ABI.encode(log_de68f20a_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_de68f20a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_de68f20a(p0, p1, p2, p3), opts)
  end

  def build_trx_log_de68f20a(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_de68f20a(p0, p1, p2, p3)}
  end

  def call_log_de68f20a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_de68f20a(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_de68f20a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_de68f20a(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_de68f20a(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_de68f20a(p0, p1, p2, p3), opts)
  end

  def decode_log_de68f20a_call(<<222, 104, 242, 10>> <> calldata) do
    _signature = hex!("0xde68f20a")
    ABI.decode(log_de68f20a_selector(), calldata)
  end

  def exec_vm_log_de68f20a(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_de68f20a(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_de68f20a_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_de68f20a_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_de68f20a(p0, p1, p2, p3), exec_opts)
  end

  def log_de9a9270_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :address},
        %{name: "p2", type: :string}
      ]
    }
  end

  def encode_log_de9a9270(p0, p1, p2) do
    ABI.encode(log_de9a9270_selector(), [p0, p1, p2])
  end

  def prepare_log_de9a9270(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_de9a9270(p0, p1, p2), opts)
  end

  def build_trx_log_de9a9270(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_de9a9270(p0, p1, p2)}
  end

  def call_log_de9a9270(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_de9a9270(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_de9a9270(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_de9a9270(contract, p0, p1, p2), opts)
  end

  def execute_log_de9a9270(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_de9a9270(p0, p1, p2), opts)
  end

  def decode_log_de9a9270_call(<<222, 154, 146, 112>> <> calldata) do
    _signature = hex!("0xde9a9270")
    ABI.decode(log_de9a9270_selector(), calldata)
  end

  def exec_vm_log_de9a9270(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_de9a9270(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_de9a9270_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_de9a9270_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_de9a9270(p0, p1, p2), exec_opts)
  end

  def log_dfc4a2e8_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_dfc4a2e8(p0, p1, p2, p3) do
    ABI.encode(log_dfc4a2e8_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_dfc4a2e8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_dfc4a2e8(p0, p1, p2, p3), opts)
  end

  def build_trx_log_dfc4a2e8(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_dfc4a2e8(p0, p1, p2, p3)}
  end

  def call_log_dfc4a2e8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_dfc4a2e8(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_dfc4a2e8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_dfc4a2e8(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_dfc4a2e8(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_dfc4a2e8(p0, p1, p2, p3), opts)
  end

  def decode_log_dfc4a2e8_call(<<223, 196, 162, 232>> <> calldata) do
    _signature = hex!("0xdfc4a2e8")
    ABI.decode(log_dfc4a2e8_selector(), calldata)
  end

  def exec_vm_log_dfc4a2e8(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_dfc4a2e8(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_dfc4a2e8_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_dfc4a2e8_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_dfc4a2e8(p0, p1, p2, p3), exec_opts)
  end

  def log_e0625b29_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :string},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_e0625b29(p0, p1, p2, p3) do
    ABI.encode(log_e0625b29_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_e0625b29(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_e0625b29(p0, p1, p2, p3), opts)
  end

  def build_trx_log_e0625b29(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_e0625b29(p0, p1, p2, p3)}
  end

  def call_log_e0625b29(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_e0625b29(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_e0625b29(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_e0625b29(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_e0625b29(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_e0625b29(p0, p1, p2, p3), opts)
  end

  def decode_log_e0625b29_call(<<224, 98, 91, 41>> <> calldata) do
    _signature = hex!("0xe0625b29")
    ABI.decode(log_e0625b29_selector(), calldata)
  end

  def exec_vm_log_e0625b29(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_e0625b29(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_e0625b29_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_e0625b29_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_e0625b29(p0, p1, p2, p3), exec_opts)
  end

  def log_e0e95b98_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_e0e95b98(p0, p1, p2, p3) do
    ABI.encode(log_e0e95b98_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_e0e95b98(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_e0e95b98(p0, p1, p2, p3), opts)
  end

  def build_trx_log_e0e95b98(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_e0e95b98(p0, p1, p2, p3)}
  end

  def call_log_e0e95b98(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_e0e95b98(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_e0e95b98(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_e0e95b98(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_e0e95b98(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_e0e95b98(p0, p1, p2, p3), opts)
  end

  def decode_log_e0e95b98_call(<<224, 233, 91, 152>> <> calldata) do
    _signature = hex!("0xe0e95b98")
    ABI.decode(log_e0e95b98_selector(), calldata)
  end

  def exec_vm_log_e0e95b98(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_e0e95b98(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_e0e95b98_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_e0e95b98_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_e0e95b98(p0, p1, p2, p3), exec_opts)
  end

  def log_e0e9ad4f_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :address},
        %{name: "p2", type: :string}
      ]
    }
  end

  def encode_log_e0e9ad4f(p0, p1, p2) do
    ABI.encode(log_e0e9ad4f_selector(), [p0, p1, p2])
  end

  def prepare_log_e0e9ad4f(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_e0e9ad4f(p0, p1, p2), opts)
  end

  def build_trx_log_e0e9ad4f(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_e0e9ad4f(p0, p1, p2)}
  end

  def call_log_e0e9ad4f(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_e0e9ad4f(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_e0e9ad4f(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_e0e9ad4f(contract, p0, p1, p2), opts)
  end

  def execute_log_e0e9ad4f(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_e0e9ad4f(p0, p1, p2), opts)
  end

  def decode_log_e0e9ad4f_call(<<224, 233, 173, 79>> <> calldata) do
    _signature = hex!("0xe0e9ad4f")
    ABI.decode(log_e0e9ad4f_selector(), calldata)
  end

  def exec_vm_log_e0e9ad4f(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_e0e9ad4f(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_e0e9ad4f_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_e0e9ad4f_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_e0e9ad4f(p0, p1, p2), exec_opts)
  end

  def log_e21de278_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_e21de278(p0, p1, p2, p3) do
    ABI.encode(log_e21de278_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_e21de278(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_e21de278(p0, p1, p2, p3), opts)
  end

  def build_trx_log_e21de278(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_e21de278(p0, p1, p2, p3)}
  end

  def call_log_e21de278(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_e21de278(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_e21de278(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_e21de278(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_e21de278(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_e21de278(p0, p1, p2, p3), opts)
  end

  def decode_log_e21de278_call(<<226, 29, 226, 120>> <> calldata) do
    _signature = hex!("0xe21de278")
    ABI.decode(log_e21de278_selector(), calldata)
  end

  def exec_vm_log_e21de278(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_e21de278(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_e21de278_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_e21de278_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_e21de278(p0, p1, p2, p3), exec_opts)
  end

  def log_e298f47d_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :string}
      ]
    }
  end

  def encode_log_e298f47d(p0, p1, p2) do
    ABI.encode(log_e298f47d_selector(), [p0, p1, p2])
  end

  def prepare_log_e298f47d(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_e298f47d(p0, p1, p2), opts)
  end

  def build_trx_log_e298f47d(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_e298f47d(p0, p1, p2)}
  end

  def call_log_e298f47d(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_e298f47d(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_e298f47d(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_e298f47d(contract, p0, p1, p2), opts)
  end

  def execute_log_e298f47d(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_e298f47d(p0, p1, p2), opts)
  end

  def decode_log_e298f47d_call(<<226, 152, 244, 125>> <> calldata) do
    _signature = hex!("0xe298f47d")
    ABI.decode(log_e298f47d_selector(), calldata)
  end

  def exec_vm_log_e298f47d(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_e298f47d(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_e298f47d_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_e298f47d_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_e298f47d(p0, p1, p2), exec_opts)
  end

  def log_e2bfd60b_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :address},
        %{name: "p2", type: :string},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_e2bfd60b(p0, p1, p2, p3) do
    ABI.encode(log_e2bfd60b_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_e2bfd60b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_e2bfd60b(p0, p1, p2, p3), opts)
  end

  def build_trx_log_e2bfd60b(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_e2bfd60b(p0, p1, p2, p3)}
  end

  def call_log_e2bfd60b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_e2bfd60b(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_e2bfd60b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_e2bfd60b(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_e2bfd60b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_e2bfd60b(p0, p1, p2, p3), opts)
  end

  def decode_log_e2bfd60b_call(<<226, 191, 214, 11>> <> calldata) do
    _signature = hex!("0xe2bfd60b")
    ABI.decode(log_e2bfd60b_selector(), calldata)
  end

  def exec_vm_log_e2bfd60b(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_e2bfd60b(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_e2bfd60b_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_e2bfd60b_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_e2bfd60b(p0, p1, p2, p3), exec_opts)
  end

  def log_e351140f_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :address},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_e351140f(p0, p1, p2, p3) do
    ABI.encode(log_e351140f_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_e351140f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_e351140f(p0, p1, p2, p3), opts)
  end

  def build_trx_log_e351140f(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_e351140f(p0, p1, p2, p3)}
  end

  def call_log_e351140f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_e351140f(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_e351140f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_e351140f(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_e351140f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_e351140f(p0, p1, p2, p3), opts)
  end

  def decode_log_e351140f_call(<<227, 81, 20, 15>> <> calldata) do
    _signature = hex!("0xe351140f")
    ABI.decode(log_e351140f_selector(), calldata)
  end

  def exec_vm_log_e351140f(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_e351140f(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_e351140f_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_e351140f_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_e351140f(p0, p1, p2, p3), exec_opts)
  end

  def log_e3a9ca2f_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :string},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_e3a9ca2f(p0, p1, p2, p3) do
    ABI.encode(log_e3a9ca2f_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_e3a9ca2f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_e3a9ca2f(p0, p1, p2, p3), opts)
  end

  def build_trx_log_e3a9ca2f(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_e3a9ca2f(p0, p1, p2, p3)}
  end

  def call_log_e3a9ca2f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_e3a9ca2f(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_e3a9ca2f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_e3a9ca2f(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_e3a9ca2f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_e3a9ca2f(p0, p1, p2, p3), opts)
  end

  def decode_log_e3a9ca2f_call(<<227, 169, 202, 47>> <> calldata) do
    _signature = hex!("0xe3a9ca2f")
    ABI.decode(log_e3a9ca2f_selector(), calldata)
  end

  def exec_vm_log_e3a9ca2f(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_e3a9ca2f(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_e3a9ca2f_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_e3a9ca2f_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_e3a9ca2f(p0, p1, p2, p3), exec_opts)
  end

  def log_e41b6f6f_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :bool},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_e41b6f6f(p0, p1, p2, p3) do
    ABI.encode(log_e41b6f6f_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_e41b6f6f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_e41b6f6f(p0, p1, p2, p3), opts)
  end

  def build_trx_log_e41b6f6f(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_e41b6f6f(p0, p1, p2, p3)}
  end

  def call_log_e41b6f6f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_e41b6f6f(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_e41b6f6f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_e41b6f6f(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_e41b6f6f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_e41b6f6f(p0, p1, p2, p3), opts)
  end

  def decode_log_e41b6f6f_call(<<228, 27, 111, 111>> <> calldata) do
    _signature = hex!("0xe41b6f6f")
    ABI.decode(log_e41b6f6f_selector(), calldata)
  end

  def exec_vm_log_e41b6f6f(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_e41b6f6f(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_e41b6f6f_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_e41b6f6f_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_e41b6f6f(p0, p1, p2, p3), exec_opts)
  end

  def log_e5e70b2b_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :string},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_e5e70b2b(p0, p1, p2, p3) do
    ABI.encode(log_e5e70b2b_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_e5e70b2b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_e5e70b2b(p0, p1, p2, p3), opts)
  end

  def build_trx_log_e5e70b2b(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_e5e70b2b(p0, p1, p2, p3)}
  end

  def call_log_e5e70b2b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_e5e70b2b(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_e5e70b2b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_e5e70b2b(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_e5e70b2b(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_e5e70b2b(p0, p1, p2, p3), opts)
  end

  def decode_log_e5e70b2b_call(<<229, 231, 11, 43>> <> calldata) do
    _signature = hex!("0xe5e70b2b")
    ABI.decode(log_e5e70b2b_selector(), calldata)
  end

  def exec_vm_log_e5e70b2b(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_e5e70b2b(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_e5e70b2b_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_e5e70b2b_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_e5e70b2b(p0, p1, p2, p3), exec_opts)
  end

  def log_e8d3018d_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :string},
        %{name: "p2", type: :address},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_e8d3018d(p0, p1, p2, p3) do
    ABI.encode(log_e8d3018d_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_e8d3018d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_e8d3018d(p0, p1, p2, p3), opts)
  end

  def build_trx_log_e8d3018d(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_e8d3018d(p0, p1, p2, p3)}
  end

  def call_log_e8d3018d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_e8d3018d(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_e8d3018d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_e8d3018d(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_e8d3018d(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_e8d3018d(p0, p1, p2, p3), opts)
  end

  def decode_log_e8d3018d_call(<<232, 211, 1, 141>> <> calldata) do
    _signature = hex!("0xe8d3018d")
    ABI.decode(log_e8d3018d_selector(), calldata)
  end

  def exec_vm_log_e8d3018d(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_e8d3018d(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_e8d3018d_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_e8d3018d_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_e8d3018d(p0, p1, p2, p3), exec_opts)
  end

  def log_e8defba9_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :bool}
      ]
    }
  end

  def encode_log_e8defba9(p0, p1, p2) do
    ABI.encode(log_e8defba9_selector(), [p0, p1, p2])
  end

  def prepare_log_e8defba9(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_e8defba9(p0, p1, p2), opts)
  end

  def build_trx_log_e8defba9(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_e8defba9(p0, p1, p2)}
  end

  def call_log_e8defba9(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_e8defba9(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_e8defba9(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_e8defba9(contract, p0, p1, p2), opts)
  end

  def execute_log_e8defba9(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_e8defba9(p0, p1, p2), opts)
  end

  def decode_log_e8defba9_call(<<232, 222, 251, 169>> <> calldata) do
    _signature = hex!("0xe8defba9")
    ABI.decode(log_e8defba9_selector(), calldata)
  end

  def exec_vm_log_e8defba9(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_e8defba9(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_e8defba9_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_e8defba9_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_e8defba9(p0, p1, p2), exec_opts)
  end

  def log_eb1bff80_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :string},
        %{name: "p2", type: :address},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_eb1bff80(p0, p1, p2, p3) do
    ABI.encode(log_eb1bff80_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_eb1bff80(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_eb1bff80(p0, p1, p2, p3), opts)
  end

  def build_trx_log_eb1bff80(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_eb1bff80(p0, p1, p2, p3)}
  end

  def call_log_eb1bff80(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_eb1bff80(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_eb1bff80(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_eb1bff80(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_eb1bff80(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_eb1bff80(p0, p1, p2, p3), opts)
  end

  def decode_log_eb1bff80_call(<<235, 27, 255, 128>> <> calldata) do
    _signature = hex!("0xeb1bff80")
    ABI.decode(log_eb1bff80_selector(), calldata)
  end

  def exec_vm_log_eb1bff80(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_eb1bff80(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_eb1bff80_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_eb1bff80_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_eb1bff80(p0, p1, p2, p3), exec_opts)
  end

  def log_eb7f6fd2_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :bool},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_eb7f6fd2(p0, p1, p2, p3) do
    ABI.encode(log_eb7f6fd2_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_eb7f6fd2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_eb7f6fd2(p0, p1, p2, p3), opts)
  end

  def build_trx_log_eb7f6fd2(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_eb7f6fd2(p0, p1, p2, p3)}
  end

  def call_log_eb7f6fd2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_eb7f6fd2(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_eb7f6fd2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_eb7f6fd2(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_eb7f6fd2(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_eb7f6fd2(p0, p1, p2, p3), opts)
  end

  def decode_log_eb7f6fd2_call(<<235, 127, 111, 210>> <> calldata) do
    _signature = hex!("0xeb7f6fd2")
    ABI.decode(log_eb7f6fd2_selector(), calldata)
  end

  def exec_vm_log_eb7f6fd2(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_eb7f6fd2(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_eb7f6fd2_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_eb7f6fd2_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_eb7f6fd2(p0, p1, p2, p3), exec_opts)
  end

  def log_eb830c92_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :bool}
      ]
    }
  end

  def encode_log_eb830c92(p0, p1, p2) do
    ABI.encode(log_eb830c92_selector(), [p0, p1, p2])
  end

  def prepare_log_eb830c92(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_eb830c92(p0, p1, p2), opts)
  end

  def build_trx_log_eb830c92(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_eb830c92(p0, p1, p2)}
  end

  def call_log_eb830c92(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_eb830c92(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_eb830c92(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_eb830c92(contract, p0, p1, p2), opts)
  end

  def execute_log_eb830c92(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_eb830c92(p0, p1, p2), opts)
  end

  def decode_log_eb830c92_call(<<235, 131, 12, 146>> <> calldata) do
    _signature = hex!("0xeb830c92")
    ABI.decode(log_eb830c92_selector(), calldata)
  end

  def exec_vm_log_eb830c92(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_eb830c92(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_eb830c92_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_eb830c92_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_eb830c92(p0, p1, p2), exec_opts)
  end

  def log_eb928d7f_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :string},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_eb928d7f(p0, p1, p2, p3) do
    ABI.encode(log_eb928d7f_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_eb928d7f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_eb928d7f(p0, p1, p2, p3), opts)
  end

  def build_trx_log_eb928d7f(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_eb928d7f(p0, p1, p2, p3)}
  end

  def call_log_eb928d7f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_eb928d7f(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_eb928d7f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_eb928d7f(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_eb928d7f(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_eb928d7f(p0, p1, p2, p3), opts)
  end

  def decode_log_eb928d7f_call(<<235, 146, 141, 127>> <> calldata) do
    _signature = hex!("0xeb928d7f")
    ABI.decode(log_eb928d7f_selector(), calldata)
  end

  def exec_vm_log_eb928d7f(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_eb928d7f(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_eb928d7f_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_eb928d7f_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_eb928d7f(p0, p1, p2, p3), exec_opts)
  end

  def log_ed8f28f6_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :address},
        %{name: "p2", type: :address},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_ed8f28f6(p0, p1, p2, p3) do
    ABI.encode(log_ed8f28f6_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_ed8f28f6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_ed8f28f6(p0, p1, p2, p3), opts)
  end

  def build_trx_log_ed8f28f6(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_ed8f28f6(p0, p1, p2, p3)}
  end

  def call_log_ed8f28f6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_ed8f28f6(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_ed8f28f6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_ed8f28f6(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_ed8f28f6(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_ed8f28f6(p0, p1, p2, p3), opts)
  end

  def decode_log_ed8f28f6_call(<<237, 143, 40, 246>> <> calldata) do
    _signature = hex!("0xed8f28f6")
    ABI.decode(log_ed8f28f6_selector(), calldata)
  end

  def exec_vm_log_ed8f28f6(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_ed8f28f6(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_ed8f28f6_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_ed8f28f6_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_ed8f28f6(p0, p1, p2, p3), exec_opts)
  end

  def log_ef1cefe7_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :address},
        %{name: "p2", type: :string},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_ef1cefe7(p0, p1, p2, p3) do
    ABI.encode(log_ef1cefe7_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_ef1cefe7(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_ef1cefe7(p0, p1, p2, p3), opts)
  end

  def build_trx_log_ef1cefe7(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_ef1cefe7(p0, p1, p2, p3)}
  end

  def call_log_ef1cefe7(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_ef1cefe7(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_ef1cefe7(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_ef1cefe7(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_ef1cefe7(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_ef1cefe7(p0, p1, p2, p3), opts)
  end

  def decode_log_ef1cefe7_call(<<239, 28, 239, 231>> <> calldata) do
    _signature = hex!("0xef1cefe7")
    ABI.decode(log_ef1cefe7_selector(), calldata)
  end

  def exec_vm_log_ef1cefe7(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_ef1cefe7(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_ef1cefe7_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_ef1cefe7_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_ef1cefe7(p0, p1, p2, p3), exec_opts)
  end

  def log_ef529018_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :string},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_ef529018(p0, p1, p2, p3) do
    ABI.encode(log_ef529018_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_ef529018(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_ef529018(p0, p1, p2, p3), opts)
  end

  def build_trx_log_ef529018(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_ef529018(p0, p1, p2, p3)}
  end

  def call_log_ef529018(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_ef529018(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_ef529018(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_ef529018(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_ef529018(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_ef529018(p0, p1, p2, p3), opts)
  end

  def decode_log_ef529018_call(<<239, 82, 144, 24>> <> calldata) do
    _signature = hex!("0xef529018")
    ABI.decode(log_ef529018_selector(), calldata)
  end

  def exec_vm_log_ef529018(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_ef529018(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_ef529018_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_ef529018_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_ef529018(p0, p1, p2, p3), exec_opts)
  end

  def log_ef72c513_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: :address},
        %{name: "p2", type: :bool},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_ef72c513(p0, p1, p2, p3) do
    ABI.encode(log_ef72c513_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_ef72c513(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_ef72c513(p0, p1, p2, p3), opts)
  end

  def build_trx_log_ef72c513(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_ef72c513(p0, p1, p2, p3)}
  end

  def call_log_ef72c513(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_ef72c513(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_ef72c513(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_ef72c513(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_ef72c513(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_ef72c513(p0, p1, p2, p3), opts)
  end

  def decode_log_ef72c513_call(<<239, 114, 197, 19>> <> calldata) do
    _signature = hex!("0xef72c513")
    ABI.decode(log_ef72c513_selector(), calldata)
  end

  def exec_vm_log_ef72c513(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_ef72c513(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_ef72c513_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_ef72c513_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_ef72c513(p0, p1, p2, p3), exec_opts)
  end

  def log_f08744e8_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :string},
        %{name: "p2", type: :address}
      ]
    }
  end

  def encode_log_f08744e8(p0, p1, p2) do
    ABI.encode(log_f08744e8_selector(), [p0, p1, p2])
  end

  def prepare_log_f08744e8(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_f08744e8(p0, p1, p2), opts)
  end

  def build_trx_log_f08744e8(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_f08744e8(p0, p1, p2)}
  end

  def call_log_f08744e8(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_f08744e8(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_f08744e8(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_f08744e8(contract, p0, p1, p2), opts)
  end

  def execute_log_f08744e8(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_f08744e8(p0, p1, p2), opts)
  end

  def decode_log_f08744e8_call(<<240, 135, 68, 232>> <> calldata) do
    _signature = hex!("0xf08744e8")
    ABI.decode(log_f08744e8_selector(), calldata)
  end

  def exec_vm_log_f08744e8(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_f08744e8(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_f08744e8_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_f08744e8_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_f08744e8(p0, p1, p2), exec_opts)
  end

  def log_f11699ed_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :address}
      ]
    }
  end

  def encode_log_f11699ed(p0, p1, p2) do
    ABI.encode(log_f11699ed_selector(), [p0, p1, p2])
  end

  def prepare_log_f11699ed(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_f11699ed(p0, p1, p2), opts)
  end

  def build_trx_log_f11699ed(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_f11699ed(p0, p1, p2)}
  end

  def call_log_f11699ed(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_f11699ed(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_f11699ed(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_f11699ed(contract, p0, p1, p2), opts)
  end

  def execute_log_f11699ed(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_f11699ed(p0, p1, p2), opts)
  end

  def decode_log_f11699ed_call(<<241, 22, 153, 237>> <> calldata) do
    _signature = hex!("0xf11699ed")
    ABI.decode(log_f11699ed_selector(), calldata)
  end

  def exec_vm_log_f11699ed(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_f11699ed(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_f11699ed_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_f11699ed_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_f11699ed(p0, p1, p2), exec_opts)
  end

  def log_f2a66286_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :address},
        %{name: "p2", type: :bool}
      ]
    }
  end

  def encode_log_f2a66286(p0, p1, p2) do
    ABI.encode(log_f2a66286_selector(), [p0, p1, p2])
  end

  def prepare_log_f2a66286(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_f2a66286(p0, p1, p2), opts)
  end

  def build_trx_log_f2a66286(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_f2a66286(p0, p1, p2)}
  end

  def call_log_f2a66286(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_f2a66286(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_f2a66286(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_f2a66286(contract, p0, p1, p2), opts)
  end

  def execute_log_f2a66286(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_f2a66286(p0, p1, p2), opts)
  end

  def decode_log_f2a66286_call(<<242, 166, 98, 134>> <> calldata) do
    _signature = hex!("0xf2a66286")
    ABI.decode(log_f2a66286_selector(), calldata)
  end

  def exec_vm_log_f2a66286(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_f2a66286(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_f2a66286_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_f2a66286_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_f2a66286(p0, p1, p2), exec_opts)
  end

  def log_f45d7d2c_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :string},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_f45d7d2c(p0, p1, p2, p3) do
    ABI.encode(log_f45d7d2c_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_f45d7d2c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_f45d7d2c(p0, p1, p2, p3), opts)
  end

  def build_trx_log_f45d7d2c(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_f45d7d2c(p0, p1, p2, p3)}
  end

  def call_log_f45d7d2c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_f45d7d2c(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_f45d7d2c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_f45d7d2c(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_f45d7d2c(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_f45d7d2c(p0, p1, p2, p3), opts)
  end

  def decode_log_f45d7d2c_call(<<244, 93, 125, 44>> <> calldata) do
    _signature = hex!("0xf45d7d2c")
    ABI.decode(log_f45d7d2c_selector(), calldata)
  end

  def exec_vm_log_f45d7d2c(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_f45d7d2c(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_f45d7d2c_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_f45d7d2c_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_f45d7d2c(p0, p1, p2, p3), exec_opts)
  end

  def log_f4880ea4_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :address},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_f4880ea4(p0, p1, p2, p3) do
    ABI.encode(log_f4880ea4_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_f4880ea4(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_f4880ea4(p0, p1, p2, p3), opts)
  end

  def build_trx_log_f4880ea4(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_f4880ea4(p0, p1, p2, p3)}
  end

  def call_log_f4880ea4(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_f4880ea4(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_f4880ea4(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_f4880ea4(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_f4880ea4(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_f4880ea4(p0, p1, p2, p3), opts)
  end

  def decode_log_f4880ea4_call(<<244, 136, 14, 164>> <> calldata) do
    _signature = hex!("0xf4880ea4")
    ABI.decode(log_f4880ea4_selector(), calldata)
  end

  def exec_vm_log_f4880ea4(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_f4880ea4(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_f4880ea4_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_f4880ea4_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_f4880ea4(p0, p1, p2, p3), exec_opts)
  end

  def log_f5bc2249_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :string},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_f5bc2249(p0, p1, p2, p3) do
    ABI.encode(log_f5bc2249_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_f5bc2249(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_f5bc2249(p0, p1, p2, p3), opts)
  end

  def build_trx_log_f5bc2249(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_f5bc2249(p0, p1, p2, p3)}
  end

  def call_log_f5bc2249(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_f5bc2249(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_f5bc2249(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_f5bc2249(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_f5bc2249(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_f5bc2249(p0, p1, p2, p3), opts)
  end

  def decode_log_f5bc2249_call(<<245, 188, 34, 73>> <> calldata) do
    _signature = hex!("0xf5bc2249")
    ABI.decode(log_f5bc2249_selector(), calldata)
  end

  def exec_vm_log_f5bc2249(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_f5bc2249(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_f5bc2249_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_f5bc2249_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_f5bc2249(p0, p1, p2, p3), exec_opts)
  end

  def log_f666715a_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:uint, 256}}, %{name: "p1", type: {:uint, 256}}]
    }
  end

  def encode_log_f666715a(p0, p1) do
    ABI.encode(log_f666715a_selector(), [p0, p1])
  end

  def prepare_log_f666715a(contract, p0, p1, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_f666715a(p0, p1), opts)
  end

  def build_trx_log_f666715a(contract, p0, p1) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_f666715a(p0, p1)}
  end

  def call_log_f666715a(contract, p0, p1, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_f666715a(contract, p0, p1), opts)
  end

  def estimate_gas_log_f666715a(contract, p0, p1, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_f666715a(contract, p0, p1), opts)
  end

  def execute_log_f666715a(contract, p0, p1, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_f666715a(p0, p1), opts)
  end

  def decode_log_f666715a_call(<<246, 102, 113, 90>> <> calldata) do
    _signature = hex!("0xf666715a")
    ABI.decode(log_f666715a_selector(), calldata)
  end

  def exec_vm_log_f666715a(p0, p1, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_f666715a(p0, p1), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_f666715a_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_f666715a_raw(p0, p1, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_f666715a(p0, p1), exec_opts)
  end

  def log_f7e36245_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :string},
        %{name: "p2", type: :address},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_f7e36245(p0, p1, p2, p3) do
    ABI.encode(log_f7e36245_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_f7e36245(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_f7e36245(p0, p1, p2, p3), opts)
  end

  def build_trx_log_f7e36245(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_f7e36245(p0, p1, p2, p3)}
  end

  def call_log_f7e36245(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_f7e36245(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_f7e36245(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_f7e36245(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_f7e36245(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_f7e36245(p0, p1, p2, p3), opts)
  end

  def decode_log_f7e36245_call(<<247, 227, 98, 69>> <> calldata) do
    _signature = hex!("0xf7e36245")
    ABI.decode(log_f7e36245_selector(), calldata)
  end

  def exec_vm_log_f7e36245(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_f7e36245(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_f7e36245_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_f7e36245_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_f7e36245(p0, p1, p2, p3), exec_opts)
  end

  def log_f808da20_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :address},
        %{name: "p2", type: :address},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_f808da20(p0, p1, p2, p3) do
    ABI.encode(log_f808da20_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_f808da20(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_f808da20(p0, p1, p2, p3), opts)
  end

  def build_trx_log_f808da20(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_f808da20(p0, p1, p2, p3)}
  end

  def call_log_f808da20(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_f808da20(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_f808da20(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_f808da20(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_f808da20(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_f808da20(p0, p1, p2, p3), opts)
  end

  def decode_log_f808da20_call(<<248, 8, 218, 32>> <> calldata) do
    _signature = hex!("0xf808da20")
    ABI.decode(log_f808da20_selector(), calldata)
  end

  def exec_vm_log_f808da20(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_f808da20(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_f808da20_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_f808da20_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_f808da20(p0, p1, p2, p3), exec_opts)
  end

  def log_f82c50f1_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:uint, 256}}]
    }
  end

  def encode_log_f82c50f1(p0) do
    ABI.encode(log_f82c50f1_selector(), [p0])
  end

  def prepare_log_f82c50f1(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_f82c50f1(p0), opts)
  end

  def build_trx_log_f82c50f1(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_f82c50f1(p0)}
  end

  def call_log_f82c50f1(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_f82c50f1(contract, p0), opts)
  end

  def estimate_gas_log_f82c50f1(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_f82c50f1(contract, p0), opts)
  end

  def execute_log_f82c50f1(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_f82c50f1(p0), opts)
  end

  def decode_log_f82c50f1_call(<<248, 44, 80, 241>> <> calldata) do
    _signature = hex!("0xf82c50f1")
    ABI.decode(log_f82c50f1_selector(), calldata)
  end

  def exec_vm_log_f82c50f1(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_f82c50f1(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_f82c50f1_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_f82c50f1_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_f82c50f1(p0), exec_opts)
  end

  def log_f8f51b1e_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :address},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: {:uint, 256}}
      ]
    }
  end

  def encode_log_f8f51b1e(p0, p1, p2, p3) do
    ABI.encode(log_f8f51b1e_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_f8f51b1e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_f8f51b1e(p0, p1, p2, p3), opts)
  end

  def build_trx_log_f8f51b1e(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_f8f51b1e(p0, p1, p2, p3)}
  end

  def call_log_f8f51b1e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_f8f51b1e(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_f8f51b1e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_f8f51b1e(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_f8f51b1e(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_f8f51b1e(p0, p1, p2, p3), opts)
  end

  def decode_log_f8f51b1e_call(<<248, 245, 27, 30>> <> calldata) do
    _signature = hex!("0xf8f51b1e")
    ABI.decode(log_f8f51b1e_selector(), calldata)
  end

  def exec_vm_log_f8f51b1e(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_f8f51b1e(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_f8f51b1e_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_f8f51b1e_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_f8f51b1e(p0, p1, p2, p3), exec_opts)
  end

  def log_f9ad2b89_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: :bool},
        %{name: "p2", type: :string},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_f9ad2b89(p0, p1, p2, p3) do
    ABI.encode(log_f9ad2b89_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_f9ad2b89(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_f9ad2b89(p0, p1, p2, p3), opts)
  end

  def build_trx_log_f9ad2b89(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_f9ad2b89(p0, p1, p2, p3)}
  end

  def call_log_f9ad2b89(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_f9ad2b89(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_f9ad2b89(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_f9ad2b89(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_f9ad2b89(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_f9ad2b89(p0, p1, p2, p3), opts)
  end

  def decode_log_f9ad2b89_call(<<249, 173, 43, 137>> <> calldata) do
    _signature = hex!("0xf9ad2b89")
    ABI.decode(log_f9ad2b89_selector(), calldata)
  end

  def exec_vm_log_f9ad2b89(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_f9ad2b89(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_f9ad2b89_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_f9ad2b89_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_f9ad2b89(p0, p1, p2, p3), exec_opts)
  end

  def log_fa8185af_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: {:uint, 256}},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_fa8185af(p0, p1, p2, p3) do
    ABI.encode(log_fa8185af_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_fa8185af(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_fa8185af(p0, p1, p2, p3), opts)
  end

  def build_trx_log_fa8185af(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_fa8185af(p0, p1, p2, p3)}
  end

  def call_log_fa8185af(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_fa8185af(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_fa8185af(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_fa8185af(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_fa8185af(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_fa8185af(p0, p1, p2, p3), opts)
  end

  def decode_log_fa8185af_call(<<250, 129, 133, 175>> <> calldata) do
    _signature = hex!("0xfa8185af")
    ABI.decode(log_fa8185af_selector(), calldata)
  end

  def exec_vm_log_fa8185af(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_fa8185af(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_fa8185af_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_fa8185af_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_fa8185af(p0, p1, p2, p3), exec_opts)
  end

  def log_fb772265_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :string},
        %{name: "p2", type: :string}
      ]
    }
  end

  def encode_log_fb772265(p0, p1, p2) do
    ABI.encode(log_fb772265_selector(), [p0, p1, p2])
  end

  def prepare_log_fb772265(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_fb772265(p0, p1, p2), opts)
  end

  def build_trx_log_fb772265(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_fb772265(p0, p1, p2)}
  end

  def call_log_fb772265(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_fb772265(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_fb772265(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_fb772265(contract, p0, p1, p2), opts)
  end

  def execute_log_fb772265(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_fb772265(p0, p1, p2), opts)
  end

  def decode_log_fb772265_call(<<251, 119, 34, 101>> <> calldata) do
    _signature = hex!("0xfb772265")
    ABI.decode(log_fb772265_selector(), calldata)
  end

  def exec_vm_log_fb772265(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_fb772265(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_fb772265_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_fb772265_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_fb772265(p0, p1, p2), exec_opts)
  end

  def log_fc4845f0_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :address},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :bool}
      ]
    }
  end

  def encode_log_fc4845f0(p0, p1, p2, p3) do
    ABI.encode(log_fc4845f0_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_fc4845f0(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_fc4845f0(p0, p1, p2, p3), opts)
  end

  def build_trx_log_fc4845f0(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_fc4845f0(p0, p1, p2, p3)}
  end

  def call_log_fc4845f0(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_fc4845f0(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_fc4845f0(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_fc4845f0(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_fc4845f0(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_fc4845f0(p0, p1, p2, p3), opts)
  end

  def decode_log_fc4845f0_call(<<252, 72, 69, 240>> <> calldata) do
    _signature = hex!("0xfc4845f0")
    ABI.decode(log_fc4845f0_selector(), calldata)
  end

  def exec_vm_log_fc4845f0(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_fc4845f0(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_fc4845f0_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_fc4845f0_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_fc4845f0(p0, p1, p2, p3), exec_opts)
  end

  def log_fcec75e0_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :string},
        %{name: "p1", type: :address},
        %{name: "p2", type: :address}
      ]
    }
  end

  def encode_log_fcec75e0(p0, p1, p2) do
    ABI.encode(log_fcec75e0_selector(), [p0, p1, p2])
  end

  def prepare_log_fcec75e0(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_fcec75e0(p0, p1, p2), opts)
  end

  def build_trx_log_fcec75e0(contract, p0, p1, p2) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_fcec75e0(p0, p1, p2)}
  end

  def call_log_fcec75e0(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_fcec75e0(contract, p0, p1, p2), opts)
  end

  def estimate_gas_log_fcec75e0(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_fcec75e0(contract, p0, p1, p2), opts)
  end

  def execute_log_fcec75e0(contract, p0, p1, p2, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_fcec75e0(p0, p1, p2), opts)
  end

  def decode_log_fcec75e0_call(<<252, 236, 117, 224>> <> calldata) do
    _signature = hex!("0xfcec75e0")
    ABI.decode(log_fcec75e0_selector(), calldata)
  end

  def exec_vm_log_fcec75e0(p0, p1, p2, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_fcec75e0(p0, p1, p2), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_fcec75e0_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_fcec75e0_raw(p0, p1, p2, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_fcec75e0(p0, p1, p2), exec_opts)
  end

  def log_fdb4f990_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :address},
        %{name: "p1", type: :address},
        %{name: "p2", type: {:uint, 256}},
        %{name: "p3", type: :string}
      ]
    }
  end

  def encode_log_fdb4f990(p0, p1, p2, p3) do
    ABI.encode(log_fdb4f990_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_fdb4f990(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_fdb4f990(p0, p1, p2, p3), opts)
  end

  def build_trx_log_fdb4f990(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_fdb4f990(p0, p1, p2, p3)}
  end

  def call_log_fdb4f990(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_fdb4f990(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_fdb4f990(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_fdb4f990(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_fdb4f990(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_fdb4f990(p0, p1, p2, p3), opts)
  end

  def decode_log_fdb4f990_call(<<253, 180, 249, 144>> <> calldata) do
    _signature = hex!("0xfdb4f990")
    ABI.decode(log_fdb4f990_selector(), calldata)
  end

  def exec_vm_log_fdb4f990(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_fdb4f990(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_fdb4f990_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_fdb4f990_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_fdb4f990(p0, p1, p2, p3), exec_opts)
  end

  def log_fedd1fff_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "log",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [
        %{name: "p0", type: :bool},
        %{name: "p1", type: {:uint, 256}},
        %{name: "p2", type: :string},
        %{name: "p3", type: :address}
      ]
    }
  end

  def encode_log_fedd1fff(p0, p1, p2, p3) do
    ABI.encode(log_fedd1fff_selector(), [p0, p1, p2, p3])
  end

  def prepare_log_fedd1fff(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_fedd1fff(p0, p1, p2, p3), opts)
  end

  def build_trx_log_fedd1fff(contract, p0, p1, p2, p3) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_fedd1fff(p0, p1, p2, p3)}
  end

  def call_log_fedd1fff(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_fedd1fff(contract, p0, p1, p2, p3), opts)
  end

  def estimate_gas_log_fedd1fff(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_fedd1fff(contract, p0, p1, p2, p3), opts)
  end

  def execute_log_fedd1fff(contract, p0, p1, p2, p3, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_fedd1fff(p0, p1, p2, p3), opts)
  end

  def decode_log_fedd1fff_call(<<254, 221, 31, 255>> <> calldata) do
    _signature = hex!("0xfedd1fff")
    ABI.decode(log_fedd1fff_selector(), calldata)
  end

  def exec_vm_log_fedd1fff(p0, p1, p2, p3, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_fedd1fff(p0, p1, p2, p3), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(
               %ABI.FunctionSelector{types: log_fedd1fff_selector().returns},
               return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_fedd1fff_raw(p0, p1, p2, p3, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_fedd1fff(p0, p1, p2, p3), exec_opts)
  end

  def log_address_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logAddress",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: :address}]
    }
  end

  def encode_log_address(p0) do
    ABI.encode(log_address_selector(), [p0])
  end

  def prepare_log_address(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_address(p0), opts)
  end

  def build_trx_log_address(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_address(p0)}
  end

  def call_log_address(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_address(contract, p0), opts)
  end

  def estimate_gas_log_address(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_address(contract, p0), opts)
  end

  def execute_log_address(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_address(p0), opts)
  end

  def decode_log_address_call(<<95, 145, 176, 175>> <> calldata) do
    _signature = hex!("0x5f91b0af")
    ABI.decode(log_address_selector(), calldata)
  end

  def exec_vm_log_address(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_address(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_address_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_address_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_address(p0), exec_opts)
  end

  def log_bool_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBool",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: :bool}]
    }
  end

  def encode_log_bool(p0) do
    ABI.encode(log_bool_selector(), [p0])
  end

  def prepare_log_bool(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bool(p0), opts)
  end

  def build_trx_log_bool(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bool(p0)}
  end

  def call_log_bool(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bool(contract, p0), opts)
  end

  def estimate_gas_log_bool(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bool(contract, p0), opts)
  end

  def execute_log_bool(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bool(p0), opts)
  end

  def decode_log_bool_call(<<186, 122, 184, 78>> <> calldata) do
    _signature = hex!("0xba7ab84e")
    ABI.decode(log_bool_selector(), calldata)
  end

  def exec_vm_log_bool(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bool(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bool_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bool_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bool(p0), exec_opts)
  end

  def log_bytes_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: :bytes}]
    }
  end

  def encode_log_bytes(p0) do
    ABI.encode(log_bytes_selector(), [p0])
  end

  def prepare_log_bytes(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes(p0), opts)
  end

  def build_trx_log_bytes(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes(p0)}
  end

  def call_log_bytes(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes(contract, p0), opts)
  end

  def estimate_gas_log_bytes(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes(contract, p0), opts)
  end

  def execute_log_bytes(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes(p0), opts)
  end

  def decode_log_bytes_call(<<225, 123, 249, 86>> <> calldata) do
    _signature = hex!("0xe17bf956")
    ABI.decode(log_bytes_selector(), calldata)
  end

  def exec_vm_log_bytes(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes(p0), exec_opts)
  end

  def log_bytes1_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes1",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 1}}]
    }
  end

  def encode_log_bytes1(p0) do
    ABI.encode(log_bytes1_selector(), [p0])
  end

  def prepare_log_bytes1(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes1(p0), opts)
  end

  def build_trx_log_bytes1(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes1(p0)}
  end

  def call_log_bytes1(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes1(contract, p0), opts)
  end

  def estimate_gas_log_bytes1(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes1(contract, p0), opts)
  end

  def execute_log_bytes1(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes1(p0), opts)
  end

  def decode_log_bytes1_call(<<111, 65, 113, 201>> <> calldata) do
    _signature = hex!("0x6f4171c9")
    ABI.decode(log_bytes1_selector(), calldata)
  end

  def exec_vm_log_bytes1(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes1(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes1_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes1_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes1(p0), exec_opts)
  end

  def log_bytes10_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes10",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 10}}]
    }
  end

  def encode_log_bytes10(p0) do
    ABI.encode(log_bytes10_selector(), [p0])
  end

  def prepare_log_bytes10(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes10(p0), opts)
  end

  def build_trx_log_bytes10(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes10(p0)}
  end

  def call_log_bytes10(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes10(contract, p0), opts)
  end

  def estimate_gas_log_bytes10(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes10(contract, p0), opts)
  end

  def execute_log_bytes10(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes10(p0), opts)
  end

  def decode_log_bytes10_call(<<157, 194, 168, 151>> <> calldata) do
    _signature = hex!("0x9dc2a897")
    ABI.decode(log_bytes10_selector(), calldata)
  end

  def exec_vm_log_bytes10(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes10(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes10_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes10_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes10(p0), exec_opts)
  end

  def log_bytes11_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes11",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 11}}]
    }
  end

  def encode_log_bytes11(p0) do
    ABI.encode(log_bytes11_selector(), [p0])
  end

  def prepare_log_bytes11(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes11(p0), opts)
  end

  def build_trx_log_bytes11(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes11(p0)}
  end

  def call_log_bytes11(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes11(contract, p0), opts)
  end

  def estimate_gas_log_bytes11(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes11(contract, p0), opts)
  end

  def execute_log_bytes11(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes11(p0), opts)
  end

  def decode_log_bytes11_call(<<220, 8, 182, 167>> <> calldata) do
    _signature = hex!("0xdc08b6a7")
    ABI.decode(log_bytes11_selector(), calldata)
  end

  def exec_vm_log_bytes11(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes11(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes11_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes11_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes11(p0), exec_opts)
  end

  def log_bytes12_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes12",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 12}}]
    }
  end

  def encode_log_bytes12(p0) do
    ABI.encode(log_bytes12_selector(), [p0])
  end

  def prepare_log_bytes12(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes12(p0), opts)
  end

  def build_trx_log_bytes12(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes12(p0)}
  end

  def call_log_bytes12(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes12(contract, p0), opts)
  end

  def estimate_gas_log_bytes12(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes12(contract, p0), opts)
  end

  def execute_log_bytes12(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes12(p0), opts)
  end

  def decode_log_bytes12_call(<<118, 86, 214, 199>> <> calldata) do
    _signature = hex!("0x7656d6c7")
    ABI.decode(log_bytes12_selector(), calldata)
  end

  def exec_vm_log_bytes12(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes12(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes12_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes12_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes12(p0), exec_opts)
  end

  def log_bytes13_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes13",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 13}}]
    }
  end

  def encode_log_bytes13(p0) do
    ABI.encode(log_bytes13_selector(), [p0])
  end

  def prepare_log_bytes13(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes13(p0), opts)
  end

  def build_trx_log_bytes13(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes13(p0)}
  end

  def call_log_bytes13(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes13(contract, p0), opts)
  end

  def estimate_gas_log_bytes13(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes13(contract, p0), opts)
  end

  def execute_log_bytes13(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes13(p0), opts)
  end

  def decode_log_bytes13_call(<<52, 193, 216, 27>> <> calldata) do
    _signature = hex!("0x34c1d81b")
    ABI.decode(log_bytes13_selector(), calldata)
  end

  def exec_vm_log_bytes13(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes13(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes13_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes13_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes13(p0), exec_opts)
  end

  def log_bytes14_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes14",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 14}}]
    }
  end

  def encode_log_bytes14(p0) do
    ABI.encode(log_bytes14_selector(), [p0])
  end

  def prepare_log_bytes14(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes14(p0), opts)
  end

  def build_trx_log_bytes14(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes14(p0)}
  end

  def call_log_bytes14(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes14(contract, p0), opts)
  end

  def estimate_gas_log_bytes14(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes14(contract, p0), opts)
  end

  def execute_log_bytes14(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes14(p0), opts)
  end

  def decode_log_bytes14_call(<<60, 234, 186, 101>> <> calldata) do
    _signature = hex!("0x3ceaba65")
    ABI.decode(log_bytes14_selector(), calldata)
  end

  def exec_vm_log_bytes14(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes14(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes14_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes14_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes14(p0), exec_opts)
  end

  def log_bytes15_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes15",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 15}}]
    }
  end

  def encode_log_bytes15(p0) do
    ABI.encode(log_bytes15_selector(), [p0])
  end

  def prepare_log_bytes15(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes15(p0), opts)
  end

  def build_trx_log_bytes15(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes15(p0)}
  end

  def call_log_bytes15(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes15(contract, p0), opts)
  end

  def estimate_gas_log_bytes15(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes15(contract, p0), opts)
  end

  def execute_log_bytes15(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes15(p0), opts)
  end

  def decode_log_bytes15_call(<<89, 26, 61, 162>> <> calldata) do
    _signature = hex!("0x591a3da2")
    ABI.decode(log_bytes15_selector(), calldata)
  end

  def exec_vm_log_bytes15(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes15(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes15_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes15_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes15(p0), exec_opts)
  end

  def log_bytes16_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes16",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 16}}]
    }
  end

  def encode_log_bytes16(p0) do
    ABI.encode(log_bytes16_selector(), [p0])
  end

  def prepare_log_bytes16(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes16(p0), opts)
  end

  def build_trx_log_bytes16(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes16(p0)}
  end

  def call_log_bytes16(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes16(contract, p0), opts)
  end

  def estimate_gas_log_bytes16(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes16(contract, p0), opts)
  end

  def execute_log_bytes16(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes16(p0), opts)
  end

  def decode_log_bytes16_call(<<31, 141, 115, 18>> <> calldata) do
    _signature = hex!("0x1f8d7312")
    ABI.decode(log_bytes16_selector(), calldata)
  end

  def exec_vm_log_bytes16(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes16(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes16_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes16_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes16(p0), exec_opts)
  end

  def log_bytes17_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes17",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 17}}]
    }
  end

  def encode_log_bytes17(p0) do
    ABI.encode(log_bytes17_selector(), [p0])
  end

  def prepare_log_bytes17(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes17(p0), opts)
  end

  def build_trx_log_bytes17(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes17(p0)}
  end

  def call_log_bytes17(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes17(contract, p0), opts)
  end

  def estimate_gas_log_bytes17(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes17(contract, p0), opts)
  end

  def execute_log_bytes17(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes17(p0), opts)
  end

  def decode_log_bytes17_call(<<248, 154, 83, 47>> <> calldata) do
    _signature = hex!("0xf89a532f")
    ABI.decode(log_bytes17_selector(), calldata)
  end

  def exec_vm_log_bytes17(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes17(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes17_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes17_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes17(p0), exec_opts)
  end

  def log_bytes18_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes18",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 18}}]
    }
  end

  def encode_log_bytes18(p0) do
    ABI.encode(log_bytes18_selector(), [p0])
  end

  def prepare_log_bytes18(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes18(p0), opts)
  end

  def build_trx_log_bytes18(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes18(p0)}
  end

  def call_log_bytes18(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes18(contract, p0), opts)
  end

  def estimate_gas_log_bytes18(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes18(contract, p0), opts)
  end

  def execute_log_bytes18(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes18(p0), opts)
  end

  def decode_log_bytes18_call(<<216, 101, 38, 66>> <> calldata) do
    _signature = hex!("0xd8652642")
    ABI.decode(log_bytes18_selector(), calldata)
  end

  def exec_vm_log_bytes18(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes18(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes18_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes18_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes18(p0), exec_opts)
  end

  def log_bytes19_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes19",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 19}}]
    }
  end

  def encode_log_bytes19(p0) do
    ABI.encode(log_bytes19_selector(), [p0])
  end

  def prepare_log_bytes19(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes19(p0), opts)
  end

  def build_trx_log_bytes19(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes19(p0)}
  end

  def call_log_bytes19(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes19(contract, p0), opts)
  end

  def estimate_gas_log_bytes19(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes19(contract, p0), opts)
  end

  def execute_log_bytes19(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes19(p0), opts)
  end

  def decode_log_bytes19_call(<<0, 245, 107, 201>> <> calldata) do
    _signature = hex!("0x00f56bc9")
    ABI.decode(log_bytes19_selector(), calldata)
  end

  def exec_vm_log_bytes19(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes19(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes19_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes19_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes19(p0), exec_opts)
  end

  def log_bytes2_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes2",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 2}}]
    }
  end

  def encode_log_bytes2(p0) do
    ABI.encode(log_bytes2_selector(), [p0])
  end

  def prepare_log_bytes2(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes2(p0), opts)
  end

  def build_trx_log_bytes2(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes2(p0)}
  end

  def call_log_bytes2(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes2(contract, p0), opts)
  end

  def estimate_gas_log_bytes2(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes2(contract, p0), opts)
  end

  def execute_log_bytes2(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes2(p0), opts)
  end

  def decode_log_bytes2_call(<<155, 94, 148, 62>> <> calldata) do
    _signature = hex!("0x9b5e943e")
    ABI.decode(log_bytes2_selector(), calldata)
  end

  def exec_vm_log_bytes2(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes2(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes2_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes2_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes2(p0), exec_opts)
  end

  def log_bytes20_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes20",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 20}}]
    }
  end

  def encode_log_bytes20(p0) do
    ABI.encode(log_bytes20_selector(), [p0])
  end

  def prepare_log_bytes20(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes20(p0), opts)
  end

  def build_trx_log_bytes20(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes20(p0)}
  end

  def call_log_bytes20(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes20(contract, p0), opts)
  end

  def estimate_gas_log_bytes20(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes20(contract, p0), opts)
  end

  def execute_log_bytes20(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes20(p0), opts)
  end

  def decode_log_bytes20_call(<<236, 184, 86, 126>> <> calldata) do
    _signature = hex!("0xecb8567e")
    ABI.decode(log_bytes20_selector(), calldata)
  end

  def exec_vm_log_bytes20(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes20(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes20_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes20_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes20(p0), exec_opts)
  end

  def log_bytes21_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes21",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 21}}]
    }
  end

  def encode_log_bytes21(p0) do
    ABI.encode(log_bytes21_selector(), [p0])
  end

  def prepare_log_bytes21(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes21(p0), opts)
  end

  def build_trx_log_bytes21(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes21(p0)}
  end

  def call_log_bytes21(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes21(contract, p0), opts)
  end

  def estimate_gas_log_bytes21(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes21(contract, p0), opts)
  end

  def execute_log_bytes21(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes21(p0), opts)
  end

  def decode_log_bytes21_call(<<48, 82, 192, 143>> <> calldata) do
    _signature = hex!("0x3052c08f")
    ABI.decode(log_bytes21_selector(), calldata)
  end

  def exec_vm_log_bytes21(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes21(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes21_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes21_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes21(p0), exec_opts)
  end

  def log_bytes22_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes22",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 22}}]
    }
  end

  def encode_log_bytes22(p0) do
    ABI.encode(log_bytes22_selector(), [p0])
  end

  def prepare_log_bytes22(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes22(p0), opts)
  end

  def build_trx_log_bytes22(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes22(p0)}
  end

  def call_log_bytes22(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes22(contract, p0), opts)
  end

  def estimate_gas_log_bytes22(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes22(contract, p0), opts)
  end

  def execute_log_bytes22(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes22(p0), opts)
  end

  def decode_log_bytes22_call(<<128, 122, 180, 52>> <> calldata) do
    _signature = hex!("0x807ab434")
    ABI.decode(log_bytes22_selector(), calldata)
  end

  def exec_vm_log_bytes22(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes22(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes22_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes22_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes22(p0), exec_opts)
  end

  def log_bytes23_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes23",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 23}}]
    }
  end

  def encode_log_bytes23(p0) do
    ABI.encode(log_bytes23_selector(), [p0])
  end

  def prepare_log_bytes23(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes23(p0), opts)
  end

  def build_trx_log_bytes23(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes23(p0)}
  end

  def call_log_bytes23(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes23(contract, p0), opts)
  end

  def estimate_gas_log_bytes23(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes23(contract, p0), opts)
  end

  def execute_log_bytes23(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes23(p0), opts)
  end

  def decode_log_bytes23_call(<<73, 121, 176, 55>> <> calldata) do
    _signature = hex!("0x4979b037")
    ABI.decode(log_bytes23_selector(), calldata)
  end

  def exec_vm_log_bytes23(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes23(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes23_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes23_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes23(p0), exec_opts)
  end

  def log_bytes24_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes24",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 24}}]
    }
  end

  def encode_log_bytes24(p0) do
    ABI.encode(log_bytes24_selector(), [p0])
  end

  def prepare_log_bytes24(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes24(p0), opts)
  end

  def build_trx_log_bytes24(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes24(p0)}
  end

  def call_log_bytes24(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes24(contract, p0), opts)
  end

  def estimate_gas_log_bytes24(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes24(contract, p0), opts)
  end

  def execute_log_bytes24(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes24(p0), opts)
  end

  def decode_log_bytes24_call(<<9, 119, 174, 252>> <> calldata) do
    _signature = hex!("0x0977aefc")
    ABI.decode(log_bytes24_selector(), calldata)
  end

  def exec_vm_log_bytes24(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes24(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes24_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes24_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes24(p0), exec_opts)
  end

  def log_bytes25_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes25",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 25}}]
    }
  end

  def encode_log_bytes25(p0) do
    ABI.encode(log_bytes25_selector(), [p0])
  end

  def prepare_log_bytes25(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes25(p0), opts)
  end

  def build_trx_log_bytes25(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes25(p0)}
  end

  def call_log_bytes25(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes25(contract, p0), opts)
  end

  def estimate_gas_log_bytes25(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes25(contract, p0), opts)
  end

  def execute_log_bytes25(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes25(p0), opts)
  end

  def decode_log_bytes25_call(<<174, 169, 150, 63>> <> calldata) do
    _signature = hex!("0xaea9963f")
    ABI.decode(log_bytes25_selector(), calldata)
  end

  def exec_vm_log_bytes25(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes25(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes25_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes25_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes25(p0), exec_opts)
  end

  def log_bytes26_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes26",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 26}}]
    }
  end

  def encode_log_bytes26(p0) do
    ABI.encode(log_bytes26_selector(), [p0])
  end

  def prepare_log_bytes26(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes26(p0), opts)
  end

  def build_trx_log_bytes26(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes26(p0)}
  end

  def call_log_bytes26(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes26(contract, p0), opts)
  end

  def estimate_gas_log_bytes26(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes26(contract, p0), opts)
  end

  def execute_log_bytes26(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes26(p0), opts)
  end

  def decode_log_bytes26_call(<<211, 99, 86, 40>> <> calldata) do
    _signature = hex!("0xd3635628")
    ABI.decode(log_bytes26_selector(), calldata)
  end

  def exec_vm_log_bytes26(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes26(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes26_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes26_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes26(p0), exec_opts)
  end

  def log_bytes27_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes27",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 27}}]
    }
  end

  def encode_log_bytes27(p0) do
    ABI.encode(log_bytes27_selector(), [p0])
  end

  def prepare_log_bytes27(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes27(p0), opts)
  end

  def build_trx_log_bytes27(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes27(p0)}
  end

  def call_log_bytes27(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes27(contract, p0), opts)
  end

  def estimate_gas_log_bytes27(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes27(contract, p0), opts)
  end

  def execute_log_bytes27(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes27(p0), opts)
  end

  def decode_log_bytes27_call(<<252, 55, 47, 159>> <> calldata) do
    _signature = hex!("0xfc372f9f")
    ABI.decode(log_bytes27_selector(), calldata)
  end

  def exec_vm_log_bytes27(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes27(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes27_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes27_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes27(p0), exec_opts)
  end

  def log_bytes28_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes28",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 28}}]
    }
  end

  def encode_log_bytes28(p0) do
    ABI.encode(log_bytes28_selector(), [p0])
  end

  def prepare_log_bytes28(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes28(p0), opts)
  end

  def build_trx_log_bytes28(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes28(p0)}
  end

  def call_log_bytes28(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes28(contract, p0), opts)
  end

  def estimate_gas_log_bytes28(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes28(contract, p0), opts)
  end

  def execute_log_bytes28(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes28(p0), opts)
  end

  def decode_log_bytes28_call(<<56, 47, 154, 52>> <> calldata) do
    _signature = hex!("0x382f9a34")
    ABI.decode(log_bytes28_selector(), calldata)
  end

  def exec_vm_log_bytes28(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes28(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes28_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes28_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes28(p0), exec_opts)
  end

  def log_bytes29_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes29",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 29}}]
    }
  end

  def encode_log_bytes29(p0) do
    ABI.encode(log_bytes29_selector(), [p0])
  end

  def prepare_log_bytes29(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes29(p0), opts)
  end

  def build_trx_log_bytes29(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes29(p0)}
  end

  def call_log_bytes29(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes29(contract, p0), opts)
  end

  def estimate_gas_log_bytes29(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes29(contract, p0), opts)
  end

  def execute_log_bytes29(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes29(p0), opts)
  end

  def decode_log_bytes29_call(<<122, 24, 118, 65>> <> calldata) do
    _signature = hex!("0x7a187641")
    ABI.decode(log_bytes29_selector(), calldata)
  end

  def exec_vm_log_bytes29(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes29(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes29_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes29_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes29(p0), exec_opts)
  end

  def log_bytes3_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes3",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 3}}]
    }
  end

  def encode_log_bytes3(p0) do
    ABI.encode(log_bytes3_selector(), [p0])
  end

  def prepare_log_bytes3(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes3(p0), opts)
  end

  def build_trx_log_bytes3(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes3(p0)}
  end

  def call_log_bytes3(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes3(contract, p0), opts)
  end

  def estimate_gas_log_bytes3(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes3(contract, p0), opts)
  end

  def execute_log_bytes3(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes3(p0), opts)
  end

  def decode_log_bytes3_call(<<119, 130, 250, 45>> <> calldata) do
    _signature = hex!("0x7782fa2d")
    ABI.decode(log_bytes3_selector(), calldata)
  end

  def exec_vm_log_bytes3(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes3(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes3_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes3_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes3(p0), exec_opts)
  end

  def log_bytes30_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes30",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 30}}]
    }
  end

  def encode_log_bytes30(p0) do
    ABI.encode(log_bytes30_selector(), [p0])
  end

  def prepare_log_bytes30(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes30(p0), opts)
  end

  def build_trx_log_bytes30(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes30(p0)}
  end

  def call_log_bytes30(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes30(contract, p0), opts)
  end

  def estimate_gas_log_bytes30(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes30(contract, p0), opts)
  end

  def execute_log_bytes30(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes30(p0), opts)
  end

  def decode_log_bytes30_call(<<196, 52, 14, 246>> <> calldata) do
    _signature = hex!("0xc4340ef6")
    ABI.decode(log_bytes30_selector(), calldata)
  end

  def exec_vm_log_bytes30(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes30(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes30_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes30_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes30(p0), exec_opts)
  end

  def log_bytes31_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes31",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 31}}]
    }
  end

  def encode_log_bytes31(p0) do
    ABI.encode(log_bytes31_selector(), [p0])
  end

  def prepare_log_bytes31(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes31(p0), opts)
  end

  def build_trx_log_bytes31(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes31(p0)}
  end

  def call_log_bytes31(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes31(contract, p0), opts)
  end

  def estimate_gas_log_bytes31(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes31(contract, p0), opts)
  end

  def execute_log_bytes31(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes31(p0), opts)
  end

  def decode_log_bytes31_call(<<129, 252, 134, 72>> <> calldata) do
    _signature = hex!("0x81fc8648")
    ABI.decode(log_bytes31_selector(), calldata)
  end

  def exec_vm_log_bytes31(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes31(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes31_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes31_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes31(p0), exec_opts)
  end

  def log_bytes32_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes32",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 32}}]
    }
  end

  def encode_log_bytes32(p0) do
    ABI.encode(log_bytes32_selector(), [p0])
  end

  def prepare_log_bytes32(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes32(p0), opts)
  end

  def build_trx_log_bytes32(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes32(p0)}
  end

  def call_log_bytes32(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes32(contract, p0), opts)
  end

  def estimate_gas_log_bytes32(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes32(contract, p0), opts)
  end

  def execute_log_bytes32(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes32(p0), opts)
  end

  def decode_log_bytes32_call(<<45, 33, 214, 247>> <> calldata) do
    _signature = hex!("0x2d21d6f7")
    ABI.decode(log_bytes32_selector(), calldata)
  end

  def exec_vm_log_bytes32(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes32(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes32_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes32_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes32(p0), exec_opts)
  end

  def log_bytes4_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes4",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 4}}]
    }
  end

  def encode_log_bytes4(p0) do
    ABI.encode(log_bytes4_selector(), [p0])
  end

  def prepare_log_bytes4(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes4(p0), opts)
  end

  def build_trx_log_bytes4(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes4(p0)}
  end

  def call_log_bytes4(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes4(contract, p0), opts)
  end

  def estimate_gas_log_bytes4(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes4(contract, p0), opts)
  end

  def execute_log_bytes4(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes4(p0), opts)
  end

  def decode_log_bytes4_call(<<251, 163, 173, 57>> <> calldata) do
    _signature = hex!("0xfba3ad39")
    ABI.decode(log_bytes4_selector(), calldata)
  end

  def exec_vm_log_bytes4(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes4(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes4_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes4_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes4(p0), exec_opts)
  end

  def log_bytes5_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes5",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 5}}]
    }
  end

  def encode_log_bytes5(p0) do
    ABI.encode(log_bytes5_selector(), [p0])
  end

  def prepare_log_bytes5(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes5(p0), opts)
  end

  def build_trx_log_bytes5(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes5(p0)}
  end

  def call_log_bytes5(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes5(contract, p0), opts)
  end

  def estimate_gas_log_bytes5(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes5(contract, p0), opts)
  end

  def execute_log_bytes5(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes5(p0), opts)
  end

  def decode_log_bytes5_call(<<85, 131, 190, 46>> <> calldata) do
    _signature = hex!("0x5583be2e")
    ABI.decode(log_bytes5_selector(), calldata)
  end

  def exec_vm_log_bytes5(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes5(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes5_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes5_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes5(p0), exec_opts)
  end

  def log_bytes6_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes6",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 6}}]
    }
  end

  def encode_log_bytes6(p0) do
    ABI.encode(log_bytes6_selector(), [p0])
  end

  def prepare_log_bytes6(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes6(p0), opts)
  end

  def build_trx_log_bytes6(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes6(p0)}
  end

  def call_log_bytes6(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes6(contract, p0), opts)
  end

  def estimate_gas_log_bytes6(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes6(contract, p0), opts)
  end

  def execute_log_bytes6(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes6(p0), opts)
  end

  def decode_log_bytes6_call(<<73, 66, 173, 198>> <> calldata) do
    _signature = hex!("0x4942adc6")
    ABI.decode(log_bytes6_selector(), calldata)
  end

  def exec_vm_log_bytes6(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes6(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes6_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes6_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes6(p0), exec_opts)
  end

  def log_bytes7_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes7",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 7}}]
    }
  end

  def encode_log_bytes7(p0) do
    ABI.encode(log_bytes7_selector(), [p0])
  end

  def prepare_log_bytes7(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes7(p0), opts)
  end

  def build_trx_log_bytes7(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes7(p0)}
  end

  def call_log_bytes7(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes7(contract, p0), opts)
  end

  def estimate_gas_log_bytes7(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes7(contract, p0), opts)
  end

  def execute_log_bytes7(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes7(p0), opts)
  end

  def decode_log_bytes7_call(<<69, 116, 175, 171>> <> calldata) do
    _signature = hex!("0x4574afab")
    ABI.decode(log_bytes7_selector(), calldata)
  end

  def exec_vm_log_bytes7(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes7(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes7_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes7_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes7(p0), exec_opts)
  end

  def log_bytes8_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes8",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 8}}]
    }
  end

  def encode_log_bytes8(p0) do
    ABI.encode(log_bytes8_selector(), [p0])
  end

  def prepare_log_bytes8(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes8(p0), opts)
  end

  def build_trx_log_bytes8(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes8(p0)}
  end

  def call_log_bytes8(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes8(contract, p0), opts)
  end

  def estimate_gas_log_bytes8(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes8(contract, p0), opts)
  end

  def execute_log_bytes8(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes8(p0), opts)
  end

  def decode_log_bytes8_call(<<153, 2, 228, 127>> <> calldata) do
    _signature = hex!("0x9902e47f")
    ABI.decode(log_bytes8_selector(), calldata)
  end

  def exec_vm_log_bytes8(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes8(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes8_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes8_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes8(p0), exec_opts)
  end

  def log_bytes9_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logBytes9",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:bytes, 9}}]
    }
  end

  def encode_log_bytes9(p0) do
    ABI.encode(log_bytes9_selector(), [p0])
  end

  def prepare_log_bytes9(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_bytes9(p0), opts)
  end

  def build_trx_log_bytes9(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_bytes9(p0)}
  end

  def call_log_bytes9(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_bytes9(contract, p0), opts)
  end

  def estimate_gas_log_bytes9(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_bytes9(contract, p0), opts)
  end

  def execute_log_bytes9(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_bytes9(p0), opts)
  end

  def decode_log_bytes9_call(<<80, 161, 56, 223>> <> calldata) do
    _signature = hex!("0x50a138df")
    ABI.decode(log_bytes9_selector(), calldata)
  end

  def exec_vm_log_bytes9(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes9(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_bytes9_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_bytes9_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_bytes9(p0), exec_opts)
  end

  def log_int_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logInt",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:int, 256}}]
    }
  end

  def encode_log_int(p0) do
    ABI.encode(log_int_selector(), [p0])
  end

  def prepare_log_int(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_int(p0), opts)
  end

  def build_trx_log_int(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_int(p0)}
  end

  def call_log_int(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_int(contract, p0), opts)
  end

  def estimate_gas_log_int(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_int(contract, p0), opts)
  end

  def execute_log_int(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_int(p0), opts)
  end

  def decode_log_int_call(<<101, 37, 181, 245>> <> calldata) do
    _signature = hex!("0x6525b5f5")
    ABI.decode(log_int_selector(), calldata)
  end

  def exec_vm_log_int(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_int(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_int_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_int_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_int(p0), exec_opts)
  end

  def log_string_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logString",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: :string}]
    }
  end

  def encode_log_string(p0) do
    ABI.encode(log_string_selector(), [p0])
  end

  def prepare_log_string(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_string(p0), opts)
  end

  def build_trx_log_string(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_string(p0)}
  end

  def call_log_string(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_string(contract, p0), opts)
  end

  def estimate_gas_log_string(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_string(contract, p0), opts)
  end

  def execute_log_string(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_string(p0), opts)
  end

  def decode_log_string_call(<<11, 181, 99, 214>> <> calldata) do
    _signature = hex!("0x0bb563d6")
    ABI.decode(log_string_selector(), calldata)
  end

  def exec_vm_log_string(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_string(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_string_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_string_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_string(p0), exec_opts)
  end

  def log_uint_selector() do
    %{
      __struct__: ABI.FunctionSelector,
      function: "logUint",
      function_type: :function,
      returns: [],
      state_mutability: :pure,
      types: [%{name: "p0", type: {:uint, 256}}]
    }
  end

  def encode_log_uint(p0) do
    ABI.encode(log_uint_selector(), [p0])
  end

  def prepare_log_uint(contract, p0, opts \\ []) do
    Signet.RPC.prepare_trx(contract, encode_log_uint(p0), opts)
  end

  def build_trx_log_uint(contract, p0) do
    %Signet.Transaction.V2{destination: contract, data: encode_log_uint(p0)}
  end

  def call_log_uint(contract, p0, opts \\ []) do
    Signet.RPC.call_trx(build_trx_log_uint(contract, p0), opts)
  end

  def estimate_gas_log_uint(contract, p0, opts \\ []) do
    Signet.RPC.estimate_gas(build_trx_log_uint(contract, p0), opts)
  end

  def execute_log_uint(contract, p0, opts \\ []) do
    Signet.RPC.execute_trx(contract, encode_log_uint(p0), opts)
  end

  def decode_log_uint_call(<<153, 5, 183, 68>> <> calldata) do
    _signature = hex!("0x9905b744")
    ABI.decode(log_uint_selector(), calldata)
  end

  def exec_vm_log_uint(p0, exec_opts \\ []) do
    case Signet.VM.exec_call(deployed_bytecode(), encode_log_uint(p0), exec_opts) do
      {:ok, return_data} ->
        case ABI.decode(%ABI.FunctionSelector{types: log_uint_selector().returns}, return_data,
               decode_structs: true
             ) do
          m when is_map(m) -> {:ok, m}
          [decoded] -> {:ok, decoded}
          els -> {:ok, els}
        end

      {:revert, revert_data} ->
        case decode_error(revert_data) do
          {:ok, error, data} -> {:revert, error, data}
          :not_found -> {:revert, "Unknown", revert_data}
        end
    end
  end

  def exec_vm_log_uint_raw(p0, exec_opts \\ []) do
    Signet.VM.exec_call(deployed_bytecode(), encode_log_uint(p0), exec_opts)
  end

  def decode_call(calldata = <<0, 113, 80, 190>> <> _) do
    _signature = hex!("0x007150be")
    {:ok, "log", decode_log_call(calldata)}
  end

  def decode_call(calldata = <<0, 221, 135, 185>> <> _) do
    _signature = hex!("0x00dd87b9")
    {:ok, "log", decode_log_00dd87b9_call(calldata)}
  end

  def decode_call(calldata = <<1, 140, 132, 194>> <> _) do
    _signature = hex!("0x018c84c2")
    {:ok, "log", decode_log_018c84c2_call(calldata)}
  end

  def decode_call(calldata = <<3, 28, 111, 115>> <> _) do
    _signature = hex!("0x031c6f73")
    {:ok, "log", decode_log_031c6f73_call(calldata)}
  end

  def decode_call(calldata = <<4, 84, 192, 121>> <> _) do
    _signature = hex!("0x0454c079")
    {:ok, "log", decode_log_0454c079_call(calldata)}
  end

  def decode_call(calldata = <<7, 130, 135, 245>> <> _) do
    _signature = hex!("0x078287f5")
    {:ok, "log", decode_log_078287f5_call(calldata)}
  end

  def decode_call(calldata = <<7, 131, 21, 2>> <> _) do
    _signature = hex!("0x07831502")
    {:ok, "log", decode_log_07831502_call(calldata)}
  end

  def decode_call(calldata = <<8, 142, 249, 210>> <> _) do
    _signature = hex!("0x088ef9d2")
    {:ok, "log", decode_log_088ef9d2_call(calldata)}
  end

  def decode_call(calldata = <<9, 31, 250, 245>> <> _) do
    _signature = hex!("0x091ffaf5")
    {:ok, "log", decode_log_091ffaf5_call(calldata)}
  end

  def decode_call(calldata = <<10, 166, 207, 173>> <> _) do
    _signature = hex!("0x0aa6cfad")
    {:ok, "log", decode_log_0aa6cfad_call(calldata)}
  end

  def decode_call(calldata = <<11, 176, 14, 171>> <> _) do
    _signature = hex!("0x0bb00eab")
    {:ok, "log", decode_log_0bb00eab_call(calldata)}
  end

  def decode_call(calldata = <<12, 102, 209, 190>> <> _) do
    _signature = hex!("0x0c66d1be")
    {:ok, "log", decode_log_0c66d1be_call(calldata)}
  end

  def decode_call(calldata = <<12, 156, 217, 193>> <> _) do
    _signature = hex!("0x0c9cd9c1")
    {:ok, "log", decode_log_0c9cd9c1_call(calldata)}
  end

  def decode_call(calldata = <<13, 38, 185, 37>> <> _) do
    _signature = hex!("0x0d26b925")
    {:ok, "log", decode_log_0d26b925_call(calldata)}
  end

  def decode_call(calldata = <<13, 54, 250, 32>> <> _) do
    _signature = hex!("0x0d36fa20")
    {:ok, "log", decode_log_0d36fa20_call(calldata)}
  end

  def decode_call(calldata = <<13, 241, 43, 118>> <> _) do
    _signature = hex!("0x0df12b76")
    {:ok, "log", decode_log_0df12b76_call(calldata)}
  end

  def decode_call(calldata = <<14, 55, 137, 148>> <> _) do
    _signature = hex!("0x0e378994")
    {:ok, "log", decode_log_0e378994_call(calldata)}
  end

  def decode_call(calldata = <<14, 247, 224, 80>> <> _) do
    _signature = hex!("0x0ef7e050")
    {:ok, "log", decode_log_0ef7e050_call(calldata)}
  end

  def decode_call(calldata = <<16, 15, 101, 14>> <> _) do
    _signature = hex!("0x100f650e")
    {:ok, "log", decode_log_100f650e_call(calldata)}
  end

  def decode_call(calldata = <<16, 35, 247, 178>> <> _) do
    _signature = hex!("0x1023f7b2")
    {:ok, "log", decode_log_1023f7b2_call(calldata)}
  end

  def decode_call(calldata = <<16, 120, 246, 141>> <> _) do
    _signature = hex!("0x1078f68d")
    {:ok, "log", decode_log_1078f68d_call(calldata)}
  end

  def decode_call(calldata = <<16, 147, 238, 17>> <> _) do
    _signature = hex!("0x1093ee11")
    {:ok, "log", decode_log_1093ee11_call(calldata)}
  end

  def decode_call(calldata = <<18, 214, 199, 136>> <> _) do
    _signature = hex!("0x12d6c788")
    {:ok, "log", decode_log_12d6c788_call(calldata)}
  end

  def decode_call(calldata = <<18, 242, 22, 2>> <> _) do
    _signature = hex!("0x12f21602")
    {:ok, "log", decode_log_12f21602_call(calldata)}
  end

  def decode_call(calldata = <<19, 107, 5, 221>> <> _) do
    _signature = hex!("0x136b05dd")
    {:ok, "log", decode_log_136b05dd_call(calldata)}
  end

  def decode_call(calldata = <<21, 55, 220, 135>> <> _) do
    _signature = hex!("0x1537dc87")
    {:ok, "log", decode_log_1537dc87_call(calldata)}
  end

  def decode_call(calldata = <<21, 150, 161, 206>> <> _) do
    _signature = hex!("0x1596a1ce")
    {:ok, "log", decode_log_1596a1ce_call(calldata)}
  end

  def decode_call(calldata = <<21, 159, 137, 39>> <> _) do
    _signature = hex!("0x159f8927")
    {:ok, "log", decode_log_159f8927_call(calldata)}
  end

  def decode_call(calldata = <<21, 193, 39, 181>> <> _) do
    _signature = hex!("0x15c127b5")
    {:ok, "log", decode_log_15c127b5_call(calldata)}
  end

  def decode_call(calldata = <<21, 202, 196, 118>> <> _) do
    _signature = hex!("0x15cac476")
    {:ok, "log", decode_log_15cac476_call(calldata)}
  end

  def decode_call(calldata = <<22, 6, 163, 147>> <> _) do
    _signature = hex!("0x1606a393")
    {:ok, "log", decode_log_1606a393_call(calldata)}
  end

  def decode_call(calldata = <<23, 98, 227, 42>> <> _) do
    _signature = hex!("0x1762e32a")
    {:ok, "log", decode_log_1762e32a_call(calldata)}
  end

  def decode_call(calldata = <<23, 254, 97, 133>> <> _) do
    _signature = hex!("0x17fe6185")
    {:ok, "log", decode_log_17fe6185_call(calldata)}
  end

  def decode_call(calldata = <<24, 201, 199, 70>> <> _) do
    _signature = hex!("0x18c9c746")
    {:ok, "log", decode_log_18c9c746_call(calldata)}
  end

  def decode_call(calldata = <<25, 63, 184, 0>> <> _) do
    _signature = hex!("0x193fb800")
    {:ok, "log", decode_log_193fb800_call(calldata)}
  end

  def decode_call(calldata = <<25, 253, 73, 86>> <> _) do
    _signature = hex!("0x19fd4956")
    {:ok, "log", decode_log_19fd4956_call(calldata)}
  end

  def decode_call(calldata = <<26, 217, 109, 230>> <> _) do
    _signature = hex!("0x1ad96de6")
    {:ok, "log", decode_log_1ad96de6_call(calldata)}
  end

  def decode_call(calldata = <<27, 179, 176, 154>> <> _) do
    _signature = hex!("0x1bb3b09a")
    {:ok, "log", decode_log_1bb3b09a_call(calldata)}
  end

  def decode_call(calldata = <<28, 65, 163, 54>> <> _) do
    _signature = hex!("0x1c41a336")
    {:ok, "log", decode_log_1c41a336_call(calldata)}
  end

  def decode_call(calldata = <<28, 126, 196, 72>> <> _) do
    _signature = hex!("0x1c7ec448")
    {:ok, "log", decode_log_1c7ec448_call(calldata)}
  end

  def decode_call(calldata = <<28, 157, 126, 179>> <> _) do
    _signature = hex!("0x1c9d7eb3")
    {:ok, "log", decode_log_1c9d7eb3_call(calldata)}
  end

  def decode_call(calldata = <<29, 20, 208, 1>> <> _) do
    _signature = hex!("0x1d14d001")
    {:ok, "log", decode_log_1d14d001_call(calldata)}
  end

  def decode_call(calldata = <<29, 169, 134, 234>> <> _) do
    _signature = hex!("0x1da986ea")
    {:ok, "log", decode_log_1da986ea_call(calldata)}
  end

  def decode_call(calldata = <<29, 200, 225, 184>> <> _) do
    _signature = hex!("0x1dc8e1b8")
    {:ok, "log", decode_log_1dc8e1b8_call(calldata)}
  end

  def decode_call(calldata = <<30, 75, 135, 229>> <> _) do
    _signature = hex!("0x1e4b87e5")
    {:ok, "log", decode_log_1e4b87e5_call(calldata)}
  end

  def decode_call(calldata = <<32, 9, 128, 20>> <> _) do
    _signature = hex!("0x20098014")
    {:ok, "log", decode_log_20098014_call(calldata)}
  end

  def decode_call(calldata = <<32, 88, 113, 194>> <> _) do
    _signature = hex!("0x205871c2")
    {:ok, "log", decode_log_205871c2_call(calldata)}
  end

  def decode_call(calldata = <<32, 113, 134, 80>> <> _) do
    _signature = hex!("0x20718650")
    {:ok, "log", decode_log_20718650_call(calldata)}
  end

  def decode_call(calldata = <<32, 227, 152, 77>> <> _) do
    _signature = hex!("0x20e3984d")
    {:ok, "log", decode_log_20e3984d_call(calldata)}
  end

  def decode_call(calldata = <<33, 34, 85, 204>> <> _) do
    _signature = hex!("0x212255cc")
    {:ok, "log", decode_log_212255cc_call(calldata)}
  end

  def decode_call(calldata = <<33, 173, 6, 131>> <> _) do
    _signature = hex!("0x21ad0683")
    {:ok, "log", decode_log_21ad0683_call(calldata)}
  end

  def decode_call(calldata = <<33, 189, 175, 37>> <> _) do
    _signature = hex!("0x21bdaf25")
    {:ok, "log", decode_log_21bdaf25_call(calldata)}
  end

  def decode_call(calldata = <<34, 54, 3, 189>> <> _) do
    _signature = hex!("0x223603bd")
    {:ok, "log", decode_log_223603bd_call(calldata)}
  end

  def decode_call(calldata = <<34, 246, 185, 153>> <> _) do
    _signature = hex!("0x22f6b999")
    {:ok, "log", decode_log_22f6b999_call(calldata)}
  end

  def decode_call(calldata = <<36, 89, 134, 242>> <> _) do
    _signature = hex!("0x245986f2")
    {:ok, "log", decode_log_245986f2_call(calldata)}
  end

  def decode_call(calldata = <<36, 136, 180, 20>> <> _) do
    _signature = hex!("0x2488b414")
    {:ok, "log", decode_log_2488b414_call(calldata)}
  end

  def decode_call(calldata = <<36, 249, 20, 101>> <> _) do
    _signature = hex!("0x24f91465")
    {:ok, "log", decode_log_24f91465_call(calldata)}
  end

  def decode_call(calldata = <<37, 85, 250, 70>> <> _) do
    _signature = hex!("0x2555fa46")
    {:ok, "log", decode_log_2555fa46_call(calldata)}
  end

  def decode_call(calldata = <<38, 245, 96, 168>> <> _) do
    _signature = hex!("0x26f560a8")
    {:ok, "log", decode_log_26f560a8_call(calldata)}
  end

  def decode_call(calldata = <<39, 216, 175, 210>> <> _) do
    _signature = hex!("0x27d8afd2")
    {:ok, "log", decode_log_27d8afd2_call(calldata)}
  end

  def decode_call(calldata = <<40, 134, 63, 203>> <> _) do
    _signature = hex!("0x28863fcb")
    {:ok, "log", decode_log_28863fcb_call(calldata)}
  end

  def decode_call(calldata = <<42, 17, 14, 131>> <> _) do
    _signature = hex!("0x2a110e83")
    {:ok, "log", decode_log_2a110e83_call(calldata)}
  end

  def decode_call(calldata = <<42, 228, 8, 212>> <> _) do
    _signature = hex!("0x2ae408d4")
    {:ok, "log", decode_log_2ae408d4_call(calldata)}
  end

  def decode_call(calldata = <<43, 43, 24, 220>> <> _) do
    _signature = hex!("0x2b2b18dc")
    {:ok, "log", decode_log_2b2b18dc_call(calldata)}
  end

  def decode_call(calldata = <<44, 23, 84, 237>> <> _) do
    _signature = hex!("0x2c1754ed")
    {:ok, "log", decode_log_2c1754ed_call(calldata)}
  end

  def decode_call(calldata = <<44, 29, 7, 70>> <> _) do
    _signature = hex!("0x2c1d0746")
    {:ok, "log", decode_log_2c1d0746_call(calldata)}
  end

  def decode_call(calldata = <<44, 46, 203, 194>> <> _) do
    _signature = hex!("0x2c2ecbc2")
    {:ok, "log", decode_log_2c2ecbc2_call(calldata)}
  end

  def decode_call(calldata = <<44, 212, 19, 74>> <> _) do
    _signature = hex!("0x2cd4134a")
    {:ok, "log", decode_log_2cd4134a_call(calldata)}
  end

  def decode_call(calldata = <<44, 237, 124, 239>> <> _) do
    _signature = hex!("0x2ced7cef")
    {:ok, "log", decode_log_2ced7cef_call(calldata)}
  end

  def decode_call(calldata = <<45, 91, 108, 185>> <> _) do
    _signature = hex!("0x2d5b6cb9")
    {:ok, "log", decode_log_2d5b6cb9_call(calldata)}
  end

  def decode_call(calldata = <<45, 142, 51, 164>> <> _) do
    _signature = hex!("0x2d8e33a4")
    {:ok, "log", decode_log_2d8e33a4_call(calldata)}
  end

  def decode_call(calldata = <<45, 215, 120, 230>> <> _) do
    _signature = hex!("0x2dd778e6")
    {:ok, "log", decode_log_2dd778e6_call(calldata)}
  end

  def decode_call(calldata = <<49, 154, 243, 51>> <> _) do
    _signature = hex!("0x319af333")
    {:ok, "log", decode_log_319af333_call(calldata)}
  end

  def decode_call(calldata = <<50, 69, 142, 237>> <> _) do
    _signature = hex!("0x32458eed")
    {:ok, "log", decode_log_32458eed_call(calldata)}
  end

  def decode_call(calldata = <<51, 233, 221, 29>> <> _) do
    _signature = hex!("0x33e9dd1d")
    {:ok, "log", decode_log_33e9dd1d_call(calldata)}
  end

  def decode_call(calldata = <<52, 240, 230, 54>> <> _) do
    _signature = hex!("0x34f0e636")
    {:ok, "log", decode_log_34f0e636_call(calldata)}
  end

  def decode_call(calldata = <<53, 8, 95, 123>> <> _) do
    _signature = hex!("0x35085f7b")
    {:ok, "log", decode_log_35085f7b_call(calldata)}
  end

  def decode_call(calldata = <<53, 76, 54, 214>> <> _) do
    _signature = hex!("0x354c36d6")
    {:ok, "log", decode_log_354c36d6_call(calldata)}
  end

  def decode_call(calldata = <<53, 165, 7, 31>> <> _) do
    _signature = hex!("0x35a5071f")
    {:ok, "log", decode_log_35a5071f_call(calldata)}
  end

  def decode_call(calldata = <<55, 16, 51, 103>> <> _) do
    _signature = hex!("0x37103367")
    {:ok, "log", decode_log_37103367_call(calldata)}
  end

  def decode_call(calldata = <<55, 75, 180, 178>> <> _) do
    _signature = hex!("0x374bb4b2")
    {:ok, "log", decode_log_374bb4b2_call(calldata)}
  end

  def decode_call(calldata = <<55, 170, 125, 76>> <> _) do
    _signature = hex!("0x37aa7d4c")
    {:ok, "log", decode_log_37aa7d4c_call(calldata)}
  end

  def decode_call(calldata = <<56, 111, 245, 244>> <> _) do
    _signature = hex!("0x386ff5f4")
    {:ok, "log", decode_log_386ff5f4_call(calldata)}
  end

  def decode_call(calldata = <<57, 113, 231, 140>> <> _) do
    _signature = hex!("0x3971e78c")
    {:ok, "log", decode_log_3971e78c_call(calldata)}
  end

  def decode_call(calldata = <<57, 145, 116, 211>> <> _) do
    _signature = hex!("0x399174d3")
    {:ok, "log", decode_log_399174d3_call(calldata)}
  end

  def decode_call(calldata = <<59, 34, 121, 180>> <> _) do
    _signature = hex!("0x3b2279b4")
    {:ok, "log", decode_log_3b2279b4_call(calldata)}
  end

  def decode_call(calldata = <<59, 42, 92, 224>> <> _) do
    _signature = hex!("0x3b2a5ce0")
    {:ok, "log", decode_log_3b2a5ce0_call(calldata)}
  end

  def decode_call(calldata = <<59, 245, 229, 55>> <> _) do
    _signature = hex!("0x3bf5e537")
    {:ok, "log", decode_log_3bf5e537_call(calldata)}
  end

  def decode_call(calldata = <<60, 166, 38, 142>> <> _) do
    _signature = hex!("0x3ca6268e")
    {:ok, "log", decode_log_3ca6268e_call(calldata)}
  end

  def decode_call(calldata = <<62, 18, 140, 163>> <> _) do
    _signature = hex!("0x3e128ca3")
    {:ok, "log", decode_log_3e128ca3_call(calldata)}
  end

  def decode_call(calldata = <<62, 159, 134, 106>> <> _) do
    _signature = hex!("0x3e9f866a")
    {:ok, "log", decode_log_3e9f866a_call(calldata)}
  end

  def decode_call(calldata = <<63, 138, 112, 29>> <> _) do
    _signature = hex!("0x3f8a701d")
    {:ok, "log", decode_log_3f8a701d_call(calldata)}
  end

  def decode_call(calldata = <<64, 120, 88, 105>> <> _) do
    _signature = hex!("0x40785869")
    {:ok, "log", decode_log_40785869_call(calldata)}
  end

  def decode_call(calldata = <<65, 48, 79, 172>> <> _) do
    _signature = hex!("0x41304fac")
    {:ok, "log", decode_log_41304fac_call(calldata)}
  end

  def decode_call(calldata = <<66, 210, 29, 183>> <> _) do
    _signature = hex!("0x42d21db7")
    {:ok, "log", decode_log_42d21db7_call(calldata)}
  end

  def decode_call(calldata = <<67, 156, 123, 239>> <> _) do
    _signature = hex!("0x439c7bef")
    {:ok, "log", decode_log_439c7bef_call(calldata)}
  end

  def decode_call(calldata = <<68, 136, 48, 168>> <> _) do
    _signature = hex!("0x448830a8")
    {:ok, "log", decode_log_448830a8_call(calldata)}
  end

  def decode_call(calldata = <<69, 77, 84, 165>> <> _) do
    _signature = hex!("0x454d54a5")
    {:ok, "log", decode_log_454d54a5_call(calldata)}
  end

  def decode_call(calldata = <<69, 127, 227, 207>> <> _) do
    _signature = hex!("0x457fe3cf")
    {:ok, "log", decode_log_457fe3cf_call(calldata)}
  end

  def decode_call(calldata = <<70, 96, 11, 224>> <> _) do
    _signature = hex!("0x46600be0")
    {:ok, "log", decode_log_46600be0_call(calldata)}
  end

  def decode_call(calldata = <<70, 130, 107, 93>> <> _) do
    _signature = hex!("0x46826b5d")
    {:ok, "log", decode_log_46826b5d_call(calldata)}
  end

  def decode_call(calldata = <<71, 92, 92, 51>> <> _) do
    _signature = hex!("0x475c5c33")
    {:ok, "log", decode_log_475c5c33_call(calldata)}
  end

  def decode_call(calldata = <<71, 102, 218, 114>> <> _) do
    _signature = hex!("0x4766da72")
    {:ok, "log", decode_log_4766da72_call(calldata)}
  end

  def decode_call(calldata = <<71, 141, 28, 98>> <> _) do
    _signature = hex!("0x478d1c62")
    {:ok, "log", decode_log_478d1c62_call(calldata)}
  end

  def decode_call(calldata = <<72, 61, 4, 22>> <> _) do
    _signature = hex!("0x483d0416")
    {:ok, "log", decode_log_483d0416_call(calldata)}
  end

  def decode_call(calldata = <<74, 40, 192, 23>> <> _) do
    _signature = hex!("0x4a28c017")
    {:ok, "log", decode_log_4a28c017_call(calldata)}
  end

  def decode_call(calldata = <<74, 102, 203, 52>> <> _) do
    _signature = hex!("0x4a66cb34")
    {:ok, "log", decode_log_4a66cb34_call(calldata)}
  end

  def decode_call(calldata = <<75, 92, 66, 119>> <> _) do
    _signature = hex!("0x4b5c4277")
    {:ok, "log", decode_log_4b5c4277_call(calldata)}
  end

  def decode_call(calldata = <<76, 18, 61, 87>> <> _) do
    _signature = hex!("0x4c123d57")
    {:ok, "log", decode_log_4c123d57_call(calldata)}
  end

  def decode_call(calldata = <<76, 237, 167, 90>> <> _) do
    _signature = hex!("0x4ceda75a")
    {:ok, "log", decode_log_4ceda75a_call(calldata)}
  end

  def decode_call(calldata = <<79, 4, 253, 198>> <> _) do
    _signature = hex!("0x4f04fdc6")
    {:ok, "log", decode_log_4f04fdc6_call(calldata)}
  end

  def decode_call(calldata = <<80, 112, 150, 152>> <> _) do
    _signature = hex!("0x50709698")
    {:ok, "log", decode_log_50709698_call(calldata)}
  end

  def decode_call(calldata = <<80, 173, 70, 29>> <> _) do
    _signature = hex!("0x50ad461d")
    {:ok, "log", decode_log_50ad461d_call(calldata)}
  end

  def decode_call(calldata = <<81, 94, 56, 182>> <> _) do
    _signature = hex!("0x515e38b6")
    {:ok, "log", decode_log_515e38b6_call(calldata)}
  end

  def decode_call(calldata = <<81, 151, 62, 201>> <> _) do
    _signature = hex!("0x51973ec9")
    {:ok, "log", decode_log_51973ec9_call(calldata)}
  end

  def decode_call(calldata = <<81, 240, 159, 248>> <> _) do
    _signature = hex!("0x51f09ff8")
    {:ok, "log", decode_log_51f09ff8_call(calldata)}
  end

  def decode_call(calldata = <<83, 142, 6, 171>> <> _) do
    _signature = hex!("0x538e06ab")
    {:ok, "log", decode_log_538e06ab_call(calldata)}
  end

  def decode_call(calldata = <<84, 167, 169, 160>> <> _) do
    _signature = hex!("0x54a7a9a0")
    {:ok, "log", decode_log_54a7a9a0_call(calldata)}
  end

  def decode_call(calldata = <<86, 165, 209, 177>> <> _) do
    _signature = hex!("0x56a5d1b1")
    {:ok, "log", decode_log_56a5d1b1_call(calldata)}
  end

  def decode_call(calldata = <<88, 33, 239, 161>> <> _) do
    _signature = hex!("0x5821efa1")
    {:ok, "log", decode_log_5821efa1_call(calldata)}
  end

  def decode_call(calldata = <<89, 112, 224, 137>> <> _) do
    _signature = hex!("0x5970e089")
    {:ok, "log", decode_log_5970e089_call(calldata)}
  end

  def decode_call(calldata = <<89, 207, 203, 227>> <> _) do
    _signature = hex!("0x59cfcbe3")
    {:ok, "log", decode_log_59cfcbe3_call(calldata)}
  end

  def decode_call(calldata = <<90, 71, 118, 50>> <> _) do
    _signature = hex!("0x5a477632")
    {:ok, "log", decode_log_5a477632_call(calldata)}
  end

  def decode_call(calldata = <<90, 155, 94, 213>> <> _) do
    _signature = hex!("0x5a9b5ed5")
    {:ok, "log", decode_log_5a9b5ed5_call(calldata)}
  end

  def decode_call(calldata = <<90, 184, 78, 31>> <> _) do
    _signature = hex!("0x5ab84e1f")
    {:ok, "log", decode_log_5ab84e1f_call(calldata)}
  end

  def decode_call(calldata = <<90, 189, 153, 42>> <> _) do
    _signature = hex!("0x5abd992a")
    {:ok, "log", decode_log_5abd992a_call(calldata)}
  end

  def decode_call(calldata = <<92, 67, 13, 71>> <> _) do
    _signature = hex!("0x5c430d47")
    {:ok, "log", decode_log_5c430d47_call(calldata)}
  end

  def decode_call(calldata = <<92, 150, 179, 49>> <> _) do
    _signature = hex!("0x5c96b331")
    {:ok, "log", decode_log_5c96b331_call(calldata)}
  end

  def decode_call(calldata = <<92, 205, 78, 55>> <> _) do
    _signature = hex!("0x5ccd4e37")
    {:ok, "log", decode_log_5ccd4e37_call(calldata)}
  end

  def decode_call(calldata = <<93, 2, 197, 11>> <> _) do
    _signature = hex!("0x5d02c50b")
    {:ok, "log", decode_log_5d02c50b_call(calldata)}
  end

  def decode_call(calldata = <<93, 8, 187, 5>> <> _) do
    _signature = hex!("0x5d08bb05")
    {:ok, "log", decode_log_5d08bb05_call(calldata)}
  end

  def decode_call(calldata = <<93, 26, 151, 26>> <> _) do
    _signature = hex!("0x5d1a971a")
    {:ok, "log", decode_log_5d1a971a_call(calldata)}
  end

  def decode_call(calldata = <<93, 162, 151, 235>> <> _) do
    _signature = hex!("0x5da297eb")
    {:ok, "log", decode_log_5da297eb_call(calldata)}
  end

  def decode_call(calldata = <<94, 132, 176, 234>> <> _) do
    _signature = hex!("0x5e84b0ea")
    {:ok, "log", decode_log_5e84b0ea_call(calldata)}
  end

  def decode_call(calldata = <<94, 162, 183, 174>> <> _) do
    _signature = hex!("0x5ea2b7ae")
    {:ok, "log", decode_log_5ea2b7ae_call(calldata)}
  end

  def decode_call(calldata = <<95, 21, 210, 140>> <> _) do
    _signature = hex!("0x5f15d28c")
    {:ok, "log", decode_log_5f15d28c_call(calldata)}
  end

  def decode_call(calldata = <<95, 29, 92, 159>> <> _) do
    _signature = hex!("0x5f1d5c9f")
    {:ok, "log", decode_log_5f1d5c9f_call(calldata)}
  end

  def decode_call(calldata = <<95, 116, 58, 124>> <> _) do
    _signature = hex!("0x5f743a7c")
    {:ok, "log", decode_log_5f743a7c_call(calldata)}
  end

  def decode_call(calldata = <<95, 123, 154, 251>> <> _) do
    _signature = hex!("0x5f7b9afb")
    {:ok, "log", decode_log_5f7b9afb_call(calldata)}
  end

  def decode_call(calldata = <<97, 104, 237, 97>> <> _) do
    _signature = hex!("0x6168ed61")
    {:ok, "log", decode_log_6168ed61_call(calldata)}
  end

  def decode_call(calldata = <<97, 158, 77, 14>> <> _) do
    _signature = hex!("0x619e4d0e")
    {:ok, "log", decode_log_619e4d0e_call(calldata)}
  end

  def decode_call(calldata = <<99, 24, 54, 120>> <> _) do
    _signature = hex!("0x63183678")
    {:ok, "log", decode_log_63183678_call(calldata)}
  end

  def decode_call(calldata = <<99, 203, 65, 249>> <> _) do
    _signature = hex!("0x63cb41f9")
    {:ok, "log", decode_log_63cb41f9_call(calldata)}
  end

  def decode_call(calldata = <<99, 251, 139, 197>> <> _) do
    _signature = hex!("0x63fb8bc5")
    {:ok, "log", decode_log_63fb8bc5_call(calldata)}
  end

  def decode_call(calldata = <<100, 63, 208, 223>> <> _) do
    _signature = hex!("0x643fd0df")
    {:ok, "log", decode_log_643fd0df_call(calldata)}
  end

  def decode_call(calldata = <<100, 181, 187, 103>> <> _) do
    _signature = hex!("0x64b5bb67")
    {:ok, "log", decode_log_64b5bb67_call(calldata)}
  end

  def decode_call(calldata = <<102, 3, 117, 221>> <> _) do
    _signature = hex!("0x660375dd")
    {:ok, "log", decode_log_660375dd_call(calldata)}
  end

  def decode_call(calldata = <<102, 91, 241, 52>> <> _) do
    _signature = hex!("0x665bf134")
    {:ok, "log", decode_log_665bf134_call(calldata)}
  end

  def decode_call(calldata = <<102, 241, 188, 103>> <> _) do
    _signature = hex!("0x66f1bc67")
    {:ok, "log", decode_log_66f1bc67_call(calldata)}
  end

  def decode_call(calldata = <<103, 130, 9, 168>> <> _) do
    _signature = hex!("0x678209a8")
    {:ok, "log", decode_log_678209a8_call(calldata)}
  end

  def decode_call(calldata = <<103, 221, 111, 241>> <> _) do
    _signature = hex!("0x67dd6ff1")
    {:ok, "log", decode_log_67dd6ff1_call(calldata)}
  end

  def decode_call(calldata = <<104, 200, 184, 189>> <> _) do
    _signature = hex!("0x68c8b8bd")
    {:ok, "log", decode_log_68c8b8bd_call(calldata)}
  end

  def decode_call(calldata = <<105, 26, 143, 116>> <> _) do
    _signature = hex!("0x691a8f74")
    {:ok, "log", decode_log_691a8f74_call(calldata)}
  end

  def decode_call(calldata = <<105, 39, 108, 134>> <> _) do
    _signature = hex!("0x69276c86")
    {:ok, "log", decode_log_69276c86_call(calldata)}
  end

  def decode_call(calldata = <<105, 100, 11, 89>> <> _) do
    _signature = hex!("0x69640b59")
    {:ok, "log", decode_log_69640b59_call(calldata)}
  end

  def decode_call(calldata = <<106, 17, 153, 226>> <> _) do
    _signature = hex!("0x6a1199e2")
    {:ok, "log", decode_log_6a1199e2_call(calldata)}
  end

  def decode_call(calldata = <<106, 156, 71, 139>> <> _) do
    _signature = hex!("0x6a9c478b")
    {:ok, "log", decode_log_6a9c478b_call(calldata)}
  end

  def decode_call(calldata = <<107, 14, 93, 83>> <> _) do
    _signature = hex!("0x6b0e5d53")
    {:ok, "log", decode_log_6b0e5d53_call(calldata)}
  end

  def decode_call(calldata = <<108, 222, 64, 184>> <> _) do
    _signature = hex!("0x6cde40b8")
    {:ok, "log", decode_log_6cde40b8_call(calldata)}
  end

  def decode_call(calldata = <<109, 30, 135, 81>> <> _) do
    _signature = hex!("0x6d1e8751")
    {:ok, "log", decode_log_6d1e8751_call(calldata)}
  end

  def decode_call(calldata = <<109, 87, 47, 68>> <> _) do
    _signature = hex!("0x6d572f44")
    {:ok, "log", decode_log_6d572f44_call(calldata)}
  end

  def decode_call(calldata = <<109, 112, 69, 193>> <> _) do
    _signature = hex!("0x6d7045c1")
    {:ok, "log", decode_log_6d7045c1_call(calldata)}
  end

  def decode_call(calldata = <<109, 212, 52, 202>> <> _) do
    _signature = hex!("0x6dd434ca")
    {:ok, "log", decode_log_6dd434ca_call(calldata)}
  end

  def decode_call(calldata = <<111, 26, 89, 78>> <> _) do
    _signature = hex!("0x6f1a594e")
    {:ok, "log", decode_log_6f1a594e_call(calldata)}
  end

  def decode_call(calldata = <<111, 124, 96, 62>> <> _) do
    _signature = hex!("0x6f7c603e")
    {:ok, "log", decode_log_6f7c603e_call(calldata)}
  end

  def decode_call(calldata = <<113, 144, 165, 41>> <> _) do
    _signature = hex!("0x7190a529")
    {:ok, "log", decode_log_7190a529_call(calldata)}
  end

  def decode_call(calldata = <<113, 208, 74, 242>> <> _) do
    _signature = hex!("0x71d04af2")
    {:ok, "log", decode_log_71d04af2_call(calldata)}
  end

  def decode_call(calldata = <<115, 110, 251, 182>> <> _) do
    _signature = hex!("0x736efbb6")
    {:ok, "log", decode_log_736efbb6_call(calldata)}
  end

  def decode_call(calldata = <<116, 45, 110, 231>> <> _) do
    _signature = hex!("0x742d6ee7")
    {:ok, "log", decode_log_742d6ee7_call(calldata)}
  end

  def decode_call(calldata = <<116, 100, 206, 35>> <> _) do
    _signature = hex!("0x7464ce23")
    {:ok, "log", decode_log_7464ce23_call(calldata)}
  end

  def decode_call(calldata = <<117, 159, 134, 187>> <> _) do
    _signature = hex!("0x759f86bb")
    {:ok, "log", decode_log_759f86bb_call(calldata)}
  end

  def decode_call(calldata = <<117, 182, 5, 211>> <> _) do
    _signature = hex!("0x75b605d3")
    {:ok, "log", decode_log_75b605d3_call(calldata)}
  end

  def decode_call(calldata = <<118, 38, 219, 146>> <> _) do
    _signature = hex!("0x7626db92")
    {:ok, "log", decode_log_7626db92_call(calldata)}
  end

  def decode_call(calldata = <<121, 136, 76, 43>> <> _) do
    _signature = hex!("0x79884c2b")
    {:ok, "log", decode_log_79884c2b_call(calldata)}
  end

  def decode_call(calldata = <<122, 246, 171, 37>> <> _) do
    _signature = hex!("0x7af6ab25")
    {:ok, "log", decode_log_7af6ab25_call(calldata)}
  end

  def decode_call(calldata = <<122, 250, 201, 89>> <> _) do
    _signature = hex!("0x7afac959")
    {:ok, "log", decode_log_7afac959_call(calldata)}
  end

  def decode_call(calldata = <<123, 192, 216, 72>> <> _) do
    _signature = hex!("0x7bc0d848")
    {:ok, "log", decode_log_7bc0d848_call(calldata)}
  end

  def decode_call(calldata = <<123, 224, 195, 235>> <> _) do
    _signature = hex!("0x7be0c3eb")
    {:ok, "log", decode_log_7be0c3eb_call(calldata)}
  end

  def decode_call(calldata = <<123, 241, 129, 161>> <> _) do
    _signature = hex!("0x7bf181a1")
    {:ok, "log", decode_log_7bf181a1_call(calldata)}
  end

  def decode_call(calldata = <<124, 70, 50, 164>> <> _) do
    _signature = hex!("0x7c4632a4")
    {:ok, "log", decode_log_7c4632a4_call(calldata)}
  end

  def decode_call(calldata = <<124, 195, 198, 7>> <> _) do
    _signature = hex!("0x7cc3c607")
    {:ok, "log", decode_log_7cc3c607_call(calldata)}
  end

  def decode_call(calldata = <<125, 36, 73, 29>> <> _) do
    _signature = hex!("0x7d24491d")
    {:ok, "log", decode_log_7d24491d_call(calldata)}
  end

  def decode_call(calldata = <<125, 212, 208, 224>> <> _) do
    _signature = hex!("0x7dd4d0e0")
    {:ok, "log", decode_log_7dd4d0e0_call(calldata)}
  end

  def decode_call(calldata = <<127, 155, 188, 162>> <> _) do
    _signature = hex!("0x7f9bbca2")
    {:ok, "log", decode_log_7f9bbca2_call(calldata)}
  end

  def decode_call(calldata = <<128, 10, 28, 103>> <> _) do
    _signature = hex!("0x800a1c67")
    {:ok, "log", decode_log_800a1c67_call(calldata)}
  end

  def decode_call(calldata = <<128, 230, 162, 11>> <> _) do
    _signature = hex!("0x80e6a20b")
    {:ok, "log", decode_log_80e6a20b_call(calldata)}
  end

  def decode_call(calldata = <<130, 17, 42, 66>> <> _) do
    _signature = hex!("0x82112a42")
    {:ok, "log", decode_log_82112a42_call(calldata)}
  end

  def decode_call(calldata = <<130, 194, 91, 116>> <> _) do
    _signature = hex!("0x82c25b74")
    {:ok, "log", decode_log_82c25b74_call(calldata)}
  end

  def decode_call(calldata = <<131, 9, 232, 168>> <> _) do
    _signature = hex!("0x8309e8a8")
    {:ok, "log", decode_log_8309e8a8_call(calldata)}
  end

  def decode_call(calldata = <<133, 11, 122, 214>> <> _) do
    _signature = hex!("0x850b7ad6")
    {:ok, "log", decode_log_850b7ad6_call(calldata)}
  end

  def decode_call(calldata = <<133, 60, 72, 73>> <> _) do
    _signature = hex!("0x853c4849")
    {:ok, "log", decode_log_853c4849_call(calldata)}
  end

  def decode_call(calldata = <<133, 75, 52, 150>> <> _) do
    _signature = hex!("0x854b3496")
    {:ok, "log", decode_log_854b3496_call(calldata)}
  end

  def decode_call(calldata = <<133, 119, 80, 33>> <> _) do
    _signature = hex!("0x85775021")
    {:ok, "log", decode_log_85775021_call(calldata)}
  end

  def decode_call(calldata = <<136, 168, 196, 6>> <> _) do
    _signature = hex!("0x88a8c406")
    {:ok, "log", decode_log_88a8c406_call(calldata)}
  end

  def decode_call(calldata = <<136, 203, 96, 65>> <> _) do
    _signature = hex!("0x88cb6041")
    {:ok, "log", decode_log_88cb6041_call(calldata)}
  end

  def decode_call(calldata = <<136, 246, 228, 178>> <> _) do
    _signature = hex!("0x88f6e4b2")
    {:ok, "log", decode_log_88f6e4b2_call(calldata)}
  end

  def decode_call(calldata = <<137, 90, 248, 197>> <> _) do
    _signature = hex!("0x895af8c5")
    {:ok, "log", decode_log_895af8c5_call(calldata)}
  end

  def decode_call(calldata = <<138, 247, 207, 138>> <> _) do
    _signature = hex!("0x8af7cf8a")
    {:ok, "log", decode_log_8af7cf8a_call(calldata)}
  end

  def decode_call(calldata = <<140, 50, 155, 26>> <> _) do
    _signature = hex!("0x8c329b1a")
    {:ok, "log", decode_log_8c329b1a_call(calldata)}
  end

  def decode_call(calldata = <<140, 78, 93, 230>> <> _) do
    _signature = hex!("0x8c4e5de6")
    {:ok, "log", decode_log_8c4e5de6_call(calldata)}
  end

  def decode_call(calldata = <<141, 166, 222, 245>> <> _) do
    _signature = hex!("0x8da6def5")
    {:ok, "log", decode_log_8da6def5_call(calldata)}
  end

  def decode_call(calldata = <<142, 63, 120, 169>> <> _) do
    _signature = hex!("0x8e3f78a9")
    {:ok, "log", decode_log_8e3f78a9_call(calldata)}
  end

  def decode_call(calldata = <<142, 105, 251, 93>> <> _) do
    _signature = hex!("0x8e69fb5d")
    {:ok, "log", decode_log_8e69fb5d_call(calldata)}
  end

  def decode_call(calldata = <<142, 175, 176, 43>> <> _) do
    _signature = hex!("0x8eafb02b")
    {:ok, "log", decode_log_8eafb02b_call(calldata)}
  end

  def decode_call(calldata = <<142, 243, 243, 153>> <> _) do
    _signature = hex!("0x8ef3f399")
    {:ok, "log", decode_log_8ef3f399_call(calldata)}
  end

  def decode_call(calldata = <<143, 115, 109, 22>> <> _) do
    _signature = hex!("0x8f736d16")
    {:ok, "log", decode_log_8f736d16_call(calldata)}
  end

  def decode_call(calldata = <<143, 234, 197, 37>> <> _) do
    _signature = hex!("0x8feac525")
    {:ok, "log", decode_log_8feac525_call(calldata)}
  end

  def decode_call(calldata = <<144, 195, 10, 86>> <> _) do
    _signature = hex!("0x90c30a56")
    {:ok, "log", decode_log_90c30a56_call(calldata)}
  end

  def decode_call(calldata = <<144, 251, 6, 170>> <> _) do
    _signature = hex!("0x90fb06aa")
    {:ok, "log", decode_log_90fb06aa_call(calldata)}
  end

  def decode_call(calldata = <<145, 67, 219, 177>> <> _) do
    _signature = hex!("0x9143dbb1")
    {:ok, "log", decode_log_9143dbb1_call(calldata)}
  end

  def decode_call(calldata = <<145, 160, 46, 42>> <> _) do
    _signature = hex!("0x91a02e2a")
    {:ok, "log", decode_log_91a02e2a_call(calldata)}
  end

  def decode_call(calldata = <<145, 209, 17, 46>> <> _) do
    _signature = hex!("0x91d1112e")
    {:ok, "log", decode_log_91d1112e_call(calldata)}
  end

  def decode_call(calldata = <<147, 43, 187, 56>> <> _) do
    _signature = hex!("0x932bbb38")
    {:ok, "log", decode_log_932bbb38_call(calldata)}
  end

  def decode_call(calldata = <<147, 94, 9, 191>> <> _) do
    _signature = hex!("0x935e09bf")
    {:ok, "log", decode_log_935e09bf_call(calldata)}
  end

  def decode_call(calldata = <<148, 37, 13, 119>> <> _) do
    _signature = hex!("0x94250d77")
    {:ok, "log", decode_log_94250d77_call(calldata)}
  end

  def decode_call(calldata = <<149, 140, 40, 198>> <> _) do
    _signature = hex!("0x958c28c6")
    {:ok, "log", decode_log_958c28c6_call(calldata)}
  end

  def decode_call(calldata = <<149, 145, 185, 83>> <> _) do
    _signature = hex!("0x9591b953")
    {:ok, "log", decode_log_9591b953_call(calldata)}
  end

  def decode_call(calldata = <<149, 237, 1, 149>> <> _) do
    _signature = hex!("0x95ed0195")
    {:ok, "log", decode_log_95ed0195_call(calldata)}
  end

  def decode_call(calldata = <<151, 211, 148, 216>> <> _) do
    _signature = hex!("0x97d394d8")
    {:ok, "log", decode_log_97d394d8_call(calldata)}
  end

  def decode_call(calldata = <<154, 129, 106, 131>> <> _) do
    _signature = hex!("0x9a816a83")
    {:ok, "log", decode_log_9a816a83_call(calldata)}
  end

  def decode_call(calldata = <<154, 205, 54, 22>> <> _) do
    _signature = hex!("0x9acd3616")
    {:ok, "log", decode_log_9acd3616_call(calldata)}
  end

  def decode_call(calldata = <<155, 66, 84, 226>> <> _) do
    _signature = hex!("0x9b4254e2")
    {:ok, "log", decode_log_9b4254e2_call(calldata)}
  end

  def decode_call(calldata = <<155, 110, 192, 66>> <> _) do
    _signature = hex!("0x9b6ec042")
    {:ok, "log", decode_log_9b6ec042_call(calldata)}
  end

  def decode_call(calldata = <<156, 58, 223, 161>> <> _) do
    _signature = hex!("0x9c3adfa1")
    {:ok, "log", decode_log_9c3adfa1_call(calldata)}
  end

  def decode_call(calldata = <<156, 79, 153, 251>> <> _) do
    _signature = hex!("0x9c4f99fb")
    {:ok, "log", decode_log_9c4f99fb_call(calldata)}
  end

  def decode_call(calldata = <<156, 186, 143, 255>> <> _) do
    _signature = hex!("0x9cba8fff")
    {:ok, "log", decode_log_9cba8fff_call(calldata)}
  end

  def decode_call(calldata = <<157, 34, 213, 221>> <> _) do
    _signature = hex!("0x9d22d5dd")
    {:ok, "log", decode_log_9d22d5dd_call(calldata)}
  end

  def decode_call(calldata = <<159, 27, 195, 110>> <> _) do
    _signature = hex!("0x9f1bc36e")
    {:ok, "log", decode_log_9f1bc36e_call(calldata)}
  end

  def decode_call(calldata = <<159, 251, 47, 147>> <> _) do
    _signature = hex!("0x9ffb2f93")
    {:ok, "log", decode_log_9ffb2f93_call(calldata)}
  end

  def decode_call(calldata = <<160, 78, 47, 135>> <> _) do
    _signature = hex!("0xa04e2f87")
    {:ok, "log", decode_log_a04e2f87_call(calldata)}
  end

  def decode_call(calldata = <<160, 164, 121, 99>> <> _) do
    _signature = hex!("0xa0a47963")
    {:ok, "log", decode_log_a0a47963_call(calldata)}
  end

  def decode_call(calldata = <<161, 188, 201, 179>> <> _) do
    _signature = hex!("0xa1bcc9b3")
    {:ok, "log", decode_log_a1bcc9b3_call(calldata)}
  end

  def decode_call(calldata = <<161, 239, 76, 187>> <> _) do
    _signature = hex!("0xa1ef4cbb")
    {:ok, "log", decode_log_a1ef4cbb_call(calldata)}
  end

  def decode_call(calldata = <<161, 242, 232, 170>> <> _) do
    _signature = hex!("0xa1f2e8aa")
    {:ok, "log", decode_log_a1f2e8aa_call(calldata)}
  end

  def decode_call(calldata = <<163, 27, 253, 204>> <> _) do
    _signature = hex!("0xa31bfdcc")
    {:ok, "log", decode_log_a31bfdcc_call(calldata)}
  end

  def decode_call(calldata = <<165, 180, 252, 153>> <> _) do
    _signature = hex!("0xa5b4fc99")
    {:ok, "log", decode_log_a5b4fc99_call(calldata)}
  end

  def decode_call(calldata = <<165, 202, 218, 148>> <> _) do
    _signature = hex!("0xa5cada94")
    {:ok, "log", decode_log_a5cada94_call(calldata)}
  end

  def decode_call(calldata = <<166, 245, 11, 15>> <> _) do
    _signature = hex!("0xa6f50b0f")
    {:ok, "log", decode_log_a6f50b0f_call(calldata)}
  end

  def decode_call(calldata = <<167, 60, 29, 182>> <> _) do
    _signature = hex!("0xa73c1db6")
    {:ok, "log", decode_log_a73c1db6_call(calldata)}
  end

  def decode_call(calldata = <<167, 92, 89, 222>> <> _) do
    _signature = hex!("0xa75c59de")
    {:ok, "log", decode_log_a75c59de_call(calldata)}
  end

  def decode_call(calldata = <<167, 168, 120, 83>> <> _) do
    _signature = hex!("0xa7a87853")
    {:ok, "log", decode_log_a7a87853_call(calldata)}
  end

  def decode_call(calldata = <<168, 38, 202, 235>> <> _) do
    _signature = hex!("0xa826caeb")
    {:ok, "log", decode_log_a826caeb_call(calldata)}
  end

  def decode_call(calldata = <<170, 101, 64, 200>> <> _) do
    _signature = hex!("0xaa6540c8")
    {:ok, "log", decode_log_aa6540c8_call(calldata)}
  end

  def decode_call(calldata = <<170, 188, 154, 49>> <> _) do
    _signature = hex!("0xaabc9a31")
    {:ok, "log", decode_log_aabc9a31_call(calldata)}
  end

  def decode_call(calldata = <<171, 8, 90, 230>> <> _) do
    _signature = hex!("0xab085ae6")
    {:ok, "log", decode_log_ab085ae6_call(calldata)}
  end

  def decode_call(calldata = <<171, 247, 58, 152>> <> _) do
    _signature = hex!("0xabf73a98")
    {:ok, "log", decode_log_abf73a98_call(calldata)}
  end

  def decode_call(calldata = <<173, 224, 82, 199>> <> _) do
    _signature = hex!("0xade052c7")
    {:ok, "log", decode_log_ade052c7_call(calldata)}
  end

  def decode_call(calldata = <<174, 46, 197, 129>> <> _) do
    _signature = hex!("0xae2ec581")
    {:ok, "log", decode_log_ae2ec581_call(calldata)}
  end

  def decode_call(calldata = <<176, 40, 201, 189>> <> _) do
    _signature = hex!("0xb028c9bd")
    {:ok, "log", decode_log_b028c9bd_call(calldata)}
  end

  def decode_call(calldata = <<176, 118, 132, 127>> <> _) do
    _signature = hex!("0xb076847f")
    {:ok, "log", decode_log_b076847f_call(calldata)}
  end

  def decode_call(calldata = <<176, 224, 249, 181>> <> _) do
    _signature = hex!("0xb0e0f9b5")
    {:ok, "log", decode_log_b0e0f9b5_call(calldata)}
  end

  def decode_call(calldata = <<177, 21, 97, 31>> <> _) do
    _signature = hex!("0xb115611f")
    {:ok, "log", decode_log_b115611f_call(calldata)}
  end

  def decode_call(calldata = <<179, 166, 182, 189>> <> _) do
    _signature = hex!("0xb3a6b6bd")
    {:ok, "log", decode_log_b3a6b6bd_call(calldata)}
  end

  def decode_call(calldata = <<180, 195, 20, 255>> <> _) do
    _signature = hex!("0xb4c314ff")
    {:ok, "log", decode_log_b4c314ff_call(calldata)}
  end

  def decode_call(calldata = <<181, 157, 189, 96>> <> _) do
    _signature = hex!("0xb59dbd60")
    {:ok, "log", decode_log_b59dbd60_call(calldata)}
  end

  def decode_call(calldata = <<182, 14, 114, 204>> <> _) do
    _signature = hex!("0xb60e72cc")
    {:ok, "log", decode_log_b60e72cc_call(calldata)}
  end

  def decode_call(calldata = <<182, 155, 202, 246>> <> _) do
    _signature = hex!("0xb69bcaf6")
    {:ok, "log", decode_log_b69bcaf6_call(calldata)}
  end

  def decode_call(calldata = <<182, 245, 119, 161>> <> _) do
    _signature = hex!("0xb6f577a1")
    {:ok, "log", decode_log_b6f577a1_call(calldata)}
  end

  def decode_call(calldata = <<183, 185, 20, 202>> <> _) do
    _signature = hex!("0xb7b914ca")
    {:ok, "log", decode_log_b7b914ca_call(calldata)}
  end

  def decode_call(calldata = <<184, 87, 22, 58>> <> _) do
    _signature = hex!("0xb857163a")
    {:ok, "log", decode_log_b857163a_call(calldata)}
  end

  def decode_call(calldata = <<186, 83, 93, 156>> <> _) do
    _signature = hex!("0xba535d9c")
    {:ok, "log", decode_log_ba535d9c_call(calldata)}
  end

  def decode_call(calldata = <<188, 11, 97, 254>> <> _) do
    _signature = hex!("0xbc0b61fe")
    {:ok, "log", decode_log_bc0b61fe_call(calldata)}
  end

  def decode_call(calldata = <<188, 253, 155, 224>> <> _) do
    _signature = hex!("0xbcfd9be0")
    {:ok, "log", decode_log_bcfd9be0_call(calldata)}
  end

  def decode_call(calldata = <<190, 85, 52, 129>> <> _) do
    _signature = hex!("0xbe553481")
    {:ok, "log", decode_log_be553481_call(calldata)}
  end

  def decode_call(calldata = <<190, 152, 67, 83>> <> _) do
    _signature = hex!("0xbe984353")
    {:ok, "log", decode_log_be984353_call(calldata)}
  end

  def decode_call(calldata = <<191, 1, 248, 145>> <> _) do
    _signature = hex!("0xbf01f891")
    {:ok, "log", decode_log_bf01f891_call(calldata)}
  end

  def decode_call(calldata = <<192, 163, 2, 216>> <> _) do
    _signature = hex!("0xc0a302d8")
    {:ok, "log", decode_log_c0a302d8_call(calldata)}
  end

  def decode_call(calldata = <<194, 31, 100, 199>> <> _) do
    _signature = hex!("0xc21f64c7")
    {:ok, "log", decode_log_c21f64c7_call(calldata)}
  end

  def decode_call(calldata = <<195, 113, 199, 219>> <> _) do
    _signature = hex!("0xc371c7db")
    {:ok, "log", decode_log_c371c7db_call(calldata)}
  end

  def decode_call(calldata = <<195, 168, 166, 84>> <> _) do
    _signature = hex!("0xc3a8a654")
    {:ok, "log", decode_log_c3a8a654_call(calldata)}
  end

  def decode_call(calldata = <<195, 181, 86, 53>> <> _) do
    _signature = hex!("0xc3b55635")
    {:ok, "log", decode_log_c3b55635_call(calldata)}
  end

  def decode_call(calldata = <<195, 252, 57, 112>> <> _) do
    _signature = hex!("0xc3fc3970")
    {:ok, "log", decode_log_c3fc3970_call(calldata)}
  end

  def decode_call(calldata = <<196, 100, 62, 32>> <> _) do
    _signature = hex!("0xc4643e20")
    {:ok, "log", decode_log_c4643e20_call(calldata)}
  end

  def decode_call(calldata = <<197, 152, 209, 133>> <> _) do
    _signature = hex!("0xc598d185")
    {:ok, "log", decode_log_c598d185_call(calldata)}
  end

  def decode_call(calldata = <<197, 173, 133, 249>> <> _) do
    _signature = hex!("0xc5ad85f9")
    {:ok, "log", decode_log_c5ad85f9_call(calldata)}
  end

  def decode_call(calldata = <<198, 126, 169, 209>> <> _) do
    _signature = hex!("0xc67ea9d1")
    {:ok, "log", decode_log_c67ea9d1_call(calldata)}
  end

  def decode_call(calldata = <<198, 172, 199, 168>> <> _) do
    _signature = hex!("0xc6acc7a8")
    {:ok, "log", decode_log_c6acc7a8_call(calldata)}
  end

  def decode_call(calldata = <<201, 29, 94, 212>> <> _) do
    _signature = hex!("0xc91d5ed4")
    {:ok, "log", decode_log_c91d5ed4_call(calldata)}
  end

  def decode_call(calldata = <<201, 89, 88, 214>> <> _) do
    _signature = hex!("0xc95958d6")
    {:ok, "log", decode_log_c95958d6_call(calldata)}
  end

  def decode_call(calldata = <<202, 71, 196, 235>> <> _) do
    _signature = hex!("0xca47c4eb")
    {:ok, "log", decode_log_ca47c4eb_call(calldata)}
  end

  def decode_call(calldata = <<202, 119, 51, 177>> <> _) do
    _signature = hex!("0xca7733b1")
    {:ok, "log", decode_log_ca7733b1_call(calldata)}
  end

  def decode_call(calldata = <<202, 196, 52, 121>> <> _) do
    _signature = hex!("0xcac43479")
    {:ok, "log", decode_log_cac43479_call(calldata)}
  end

  def decode_call(calldata = <<204, 50, 171, 7>> <> _) do
    _signature = hex!("0xcc32ab07")
    {:ok, "log", decode_log_cc32ab07_call(calldata)}
  end

  def decode_call(calldata = <<204, 247, 144, 161>> <> _) do
    _signature = hex!("0xccf790a1")
    {:ok, "log", decode_log_ccf790a1_call(calldata)}
  end

  def decode_call(calldata = <<206, 181, 244, 215>> <> _) do
    _signature = hex!("0xceb5f4d7")
    {:ok, "log", decode_log_ceb5f4d7_call(calldata)}
  end

  def decode_call(calldata = <<207, 0, 152, 128>> <> _) do
    _signature = hex!("0xcf009880")
    {:ok, "log", decode_log_cf009880_call(calldata)}
  end

  def decode_call(calldata = <<207, 2, 15, 177>> <> _) do
    _signature = hex!("0xcf020fb1")
    {:ok, "log", decode_log_cf020fb1_call(calldata)}
  end

  def decode_call(calldata = <<207, 24, 16, 92>> <> _) do
    _signature = hex!("0xcf18105c")
    {:ok, "log", decode_log_cf18105c_call(calldata)}
  end

  def decode_call(calldata = <<207, 57, 68, 133>> <> _) do
    _signature = hex!("0xcf394485")
    {:ok, "log", decode_log_cf394485_call(calldata)}
  end

  def decode_call(calldata = <<209, 237, 122, 60>> <> _) do
    _signature = hex!("0xd1ed7a3c")
    {:ok, "log", decode_log_d1ed7a3c_call(calldata)}
  end

  def decode_call(calldata = <<210, 118, 54, 103>> <> _) do
    _signature = hex!("0xd2763667")
    {:ok, "log", decode_log_d2763667_call(calldata)}
  end

  def decode_call(calldata = <<210, 212, 35, 205>> <> _) do
    _signature = hex!("0xd2d423cd")
    {:ok, "log", decode_log_d2d423cd_call(calldata)}
  end

  def decode_call(calldata = <<213, 131, 198, 2>> <> _) do
    _signature = hex!("0xd583c602")
    {:ok, "log", decode_log_d583c602_call(calldata)}
  end

  def decode_call(calldata = <<214, 1, 159, 28>> <> _) do
    _signature = hex!("0xd6019f1c")
    {:ok, "log", decode_log_d6019f1c_call(calldata)}
  end

  def decode_call(calldata = <<214, 174, 250, 210>> <> _) do
    _signature = hex!("0xd6aefad2")
    {:ok, "log", decode_log_d6aefad2_call(calldata)}
  end

  def decode_call(calldata = <<216, 18, 161, 103>> <> _) do
    _signature = hex!("0xd812a167")
    {:ok, "log", decode_log_d812a167_call(calldata)}
  end

  def decode_call(calldata = <<218, 240, 212, 170>> <> _) do
    _signature = hex!("0xdaf0d4aa")
    {:ok, "log", decode_log_daf0d4aa_call(calldata)}
  end

  def decode_call(calldata = <<219, 180, 194, 71>> <> _) do
    _signature = hex!("0xdbb4c247")
    {:ok, "log", decode_log_dbb4c247_call(calldata)}
  end

  def decode_call(calldata = <<220, 94, 147, 91>> <> _) do
    _signature = hex!("0xdc5e935b")
    {:ok, "log", decode_log_dc5e935b_call(calldata)}
  end

  def decode_call(calldata = <<221, 176, 101, 33>> <> _) do
    _signature = hex!("0xddb06521")
    {:ok, "log", decode_log_ddb06521_call(calldata)}
  end

  def decode_call(calldata = <<221, 219, 149, 97>> <> _) do
    _signature = hex!("0xdddb9561")
    {:ok, "log", decode_log_dddb9561_call(calldata)}
  end

  def decode_call(calldata = <<222, 3, 231, 116>> <> _) do
    _signature = hex!("0xde03e774")
    {:ok, "log", decode_log_de03e774_call(calldata)}
  end

  def decode_call(calldata = <<222, 104, 242, 10>> <> _) do
    _signature = hex!("0xde68f20a")
    {:ok, "log", decode_log_de68f20a_call(calldata)}
  end

  def decode_call(calldata = <<222, 154, 146, 112>> <> _) do
    _signature = hex!("0xde9a9270")
    {:ok, "log", decode_log_de9a9270_call(calldata)}
  end

  def decode_call(calldata = <<223, 196, 162, 232>> <> _) do
    _signature = hex!("0xdfc4a2e8")
    {:ok, "log", decode_log_dfc4a2e8_call(calldata)}
  end

  def decode_call(calldata = <<224, 98, 91, 41>> <> _) do
    _signature = hex!("0xe0625b29")
    {:ok, "log", decode_log_e0625b29_call(calldata)}
  end

  def decode_call(calldata = <<224, 233, 91, 152>> <> _) do
    _signature = hex!("0xe0e95b98")
    {:ok, "log", decode_log_e0e95b98_call(calldata)}
  end

  def decode_call(calldata = <<224, 233, 173, 79>> <> _) do
    _signature = hex!("0xe0e9ad4f")
    {:ok, "log", decode_log_e0e9ad4f_call(calldata)}
  end

  def decode_call(calldata = <<226, 29, 226, 120>> <> _) do
    _signature = hex!("0xe21de278")
    {:ok, "log", decode_log_e21de278_call(calldata)}
  end

  def decode_call(calldata = <<226, 152, 244, 125>> <> _) do
    _signature = hex!("0xe298f47d")
    {:ok, "log", decode_log_e298f47d_call(calldata)}
  end

  def decode_call(calldata = <<226, 191, 214, 11>> <> _) do
    _signature = hex!("0xe2bfd60b")
    {:ok, "log", decode_log_e2bfd60b_call(calldata)}
  end

  def decode_call(calldata = <<227, 81, 20, 15>> <> _) do
    _signature = hex!("0xe351140f")
    {:ok, "log", decode_log_e351140f_call(calldata)}
  end

  def decode_call(calldata = <<227, 169, 202, 47>> <> _) do
    _signature = hex!("0xe3a9ca2f")
    {:ok, "log", decode_log_e3a9ca2f_call(calldata)}
  end

  def decode_call(calldata = <<228, 27, 111, 111>> <> _) do
    _signature = hex!("0xe41b6f6f")
    {:ok, "log", decode_log_e41b6f6f_call(calldata)}
  end

  def decode_call(calldata = <<229, 231, 11, 43>> <> _) do
    _signature = hex!("0xe5e70b2b")
    {:ok, "log", decode_log_e5e70b2b_call(calldata)}
  end

  def decode_call(calldata = <<232, 211, 1, 141>> <> _) do
    _signature = hex!("0xe8d3018d")
    {:ok, "log", decode_log_e8d3018d_call(calldata)}
  end

  def decode_call(calldata = <<232, 222, 251, 169>> <> _) do
    _signature = hex!("0xe8defba9")
    {:ok, "log", decode_log_e8defba9_call(calldata)}
  end

  def decode_call(calldata = <<235, 27, 255, 128>> <> _) do
    _signature = hex!("0xeb1bff80")
    {:ok, "log", decode_log_eb1bff80_call(calldata)}
  end

  def decode_call(calldata = <<235, 127, 111, 210>> <> _) do
    _signature = hex!("0xeb7f6fd2")
    {:ok, "log", decode_log_eb7f6fd2_call(calldata)}
  end

  def decode_call(calldata = <<235, 131, 12, 146>> <> _) do
    _signature = hex!("0xeb830c92")
    {:ok, "log", decode_log_eb830c92_call(calldata)}
  end

  def decode_call(calldata = <<235, 146, 141, 127>> <> _) do
    _signature = hex!("0xeb928d7f")
    {:ok, "log", decode_log_eb928d7f_call(calldata)}
  end

  def decode_call(calldata = <<237, 143, 40, 246>> <> _) do
    _signature = hex!("0xed8f28f6")
    {:ok, "log", decode_log_ed8f28f6_call(calldata)}
  end

  def decode_call(calldata = <<239, 28, 239, 231>> <> _) do
    _signature = hex!("0xef1cefe7")
    {:ok, "log", decode_log_ef1cefe7_call(calldata)}
  end

  def decode_call(calldata = <<239, 82, 144, 24>> <> _) do
    _signature = hex!("0xef529018")
    {:ok, "log", decode_log_ef529018_call(calldata)}
  end

  def decode_call(calldata = <<239, 114, 197, 19>> <> _) do
    _signature = hex!("0xef72c513")
    {:ok, "log", decode_log_ef72c513_call(calldata)}
  end

  def decode_call(calldata = <<240, 135, 68, 232>> <> _) do
    _signature = hex!("0xf08744e8")
    {:ok, "log", decode_log_f08744e8_call(calldata)}
  end

  def decode_call(calldata = <<241, 22, 153, 237>> <> _) do
    _signature = hex!("0xf11699ed")
    {:ok, "log", decode_log_f11699ed_call(calldata)}
  end

  def decode_call(calldata = <<242, 166, 98, 134>> <> _) do
    _signature = hex!("0xf2a66286")
    {:ok, "log", decode_log_f2a66286_call(calldata)}
  end

  def decode_call(calldata = <<244, 93, 125, 44>> <> _) do
    _signature = hex!("0xf45d7d2c")
    {:ok, "log", decode_log_f45d7d2c_call(calldata)}
  end

  def decode_call(calldata = <<244, 136, 14, 164>> <> _) do
    _signature = hex!("0xf4880ea4")
    {:ok, "log", decode_log_f4880ea4_call(calldata)}
  end

  def decode_call(calldata = <<245, 188, 34, 73>> <> _) do
    _signature = hex!("0xf5bc2249")
    {:ok, "log", decode_log_f5bc2249_call(calldata)}
  end

  def decode_call(calldata = <<246, 102, 113, 90>> <> _) do
    _signature = hex!("0xf666715a")
    {:ok, "log", decode_log_f666715a_call(calldata)}
  end

  def decode_call(calldata = <<247, 227, 98, 69>> <> _) do
    _signature = hex!("0xf7e36245")
    {:ok, "log", decode_log_f7e36245_call(calldata)}
  end

  def decode_call(calldata = <<248, 8, 218, 32>> <> _) do
    _signature = hex!("0xf808da20")
    {:ok, "log", decode_log_f808da20_call(calldata)}
  end

  def decode_call(calldata = <<248, 44, 80, 241>> <> _) do
    _signature = hex!("0xf82c50f1")
    {:ok, "log", decode_log_f82c50f1_call(calldata)}
  end

  def decode_call(calldata = <<248, 245, 27, 30>> <> _) do
    _signature = hex!("0xf8f51b1e")
    {:ok, "log", decode_log_f8f51b1e_call(calldata)}
  end

  def decode_call(calldata = <<249, 173, 43, 137>> <> _) do
    _signature = hex!("0xf9ad2b89")
    {:ok, "log", decode_log_f9ad2b89_call(calldata)}
  end

  def decode_call(calldata = <<250, 129, 133, 175>> <> _) do
    _signature = hex!("0xfa8185af")
    {:ok, "log", decode_log_fa8185af_call(calldata)}
  end

  def decode_call(calldata = <<251, 119, 34, 101>> <> _) do
    _signature = hex!("0xfb772265")
    {:ok, "log", decode_log_fb772265_call(calldata)}
  end

  def decode_call(calldata = <<252, 72, 69, 240>> <> _) do
    _signature = hex!("0xfc4845f0")
    {:ok, "log", decode_log_fc4845f0_call(calldata)}
  end

  def decode_call(calldata = <<252, 236, 117, 224>> <> _) do
    _signature = hex!("0xfcec75e0")
    {:ok, "log", decode_log_fcec75e0_call(calldata)}
  end

  def decode_call(calldata = <<253, 180, 249, 144>> <> _) do
    _signature = hex!("0xfdb4f990")
    {:ok, "log", decode_log_fdb4f990_call(calldata)}
  end

  def decode_call(calldata = <<254, 221, 31, 255>> <> _) do
    _signature = hex!("0xfedd1fff")
    {:ok, "log", decode_log_fedd1fff_call(calldata)}
  end

  def decode_call(calldata = <<95, 145, 176, 175>> <> _) do
    _signature = hex!("0x5f91b0af")
    {:ok, "logAddress", decode_log_address_call(calldata)}
  end

  def decode_call(calldata = <<186, 122, 184, 78>> <> _) do
    _signature = hex!("0xba7ab84e")
    {:ok, "logBool", decode_log_bool_call(calldata)}
  end

  def decode_call(calldata = <<225, 123, 249, 86>> <> _) do
    _signature = hex!("0xe17bf956")
    {:ok, "logBytes", decode_log_bytes_call(calldata)}
  end

  def decode_call(calldata = <<111, 65, 113, 201>> <> _) do
    _signature = hex!("0x6f4171c9")
    {:ok, "logBytes1", decode_log_bytes1_call(calldata)}
  end

  def decode_call(calldata = <<157, 194, 168, 151>> <> _) do
    _signature = hex!("0x9dc2a897")
    {:ok, "logBytes10", decode_log_bytes10_call(calldata)}
  end

  def decode_call(calldata = <<220, 8, 182, 167>> <> _) do
    _signature = hex!("0xdc08b6a7")
    {:ok, "logBytes11", decode_log_bytes11_call(calldata)}
  end

  def decode_call(calldata = <<118, 86, 214, 199>> <> _) do
    _signature = hex!("0x7656d6c7")
    {:ok, "logBytes12", decode_log_bytes12_call(calldata)}
  end

  def decode_call(calldata = <<52, 193, 216, 27>> <> _) do
    _signature = hex!("0x34c1d81b")
    {:ok, "logBytes13", decode_log_bytes13_call(calldata)}
  end

  def decode_call(calldata = <<60, 234, 186, 101>> <> _) do
    _signature = hex!("0x3ceaba65")
    {:ok, "logBytes14", decode_log_bytes14_call(calldata)}
  end

  def decode_call(calldata = <<89, 26, 61, 162>> <> _) do
    _signature = hex!("0x591a3da2")
    {:ok, "logBytes15", decode_log_bytes15_call(calldata)}
  end

  def decode_call(calldata = <<31, 141, 115, 18>> <> _) do
    _signature = hex!("0x1f8d7312")
    {:ok, "logBytes16", decode_log_bytes16_call(calldata)}
  end

  def decode_call(calldata = <<248, 154, 83, 47>> <> _) do
    _signature = hex!("0xf89a532f")
    {:ok, "logBytes17", decode_log_bytes17_call(calldata)}
  end

  def decode_call(calldata = <<216, 101, 38, 66>> <> _) do
    _signature = hex!("0xd8652642")
    {:ok, "logBytes18", decode_log_bytes18_call(calldata)}
  end

  def decode_call(calldata = <<0, 245, 107, 201>> <> _) do
    _signature = hex!("0x00f56bc9")
    {:ok, "logBytes19", decode_log_bytes19_call(calldata)}
  end

  def decode_call(calldata = <<155, 94, 148, 62>> <> _) do
    _signature = hex!("0x9b5e943e")
    {:ok, "logBytes2", decode_log_bytes2_call(calldata)}
  end

  def decode_call(calldata = <<236, 184, 86, 126>> <> _) do
    _signature = hex!("0xecb8567e")
    {:ok, "logBytes20", decode_log_bytes20_call(calldata)}
  end

  def decode_call(calldata = <<48, 82, 192, 143>> <> _) do
    _signature = hex!("0x3052c08f")
    {:ok, "logBytes21", decode_log_bytes21_call(calldata)}
  end

  def decode_call(calldata = <<128, 122, 180, 52>> <> _) do
    _signature = hex!("0x807ab434")
    {:ok, "logBytes22", decode_log_bytes22_call(calldata)}
  end

  def decode_call(calldata = <<73, 121, 176, 55>> <> _) do
    _signature = hex!("0x4979b037")
    {:ok, "logBytes23", decode_log_bytes23_call(calldata)}
  end

  def decode_call(calldata = <<9, 119, 174, 252>> <> _) do
    _signature = hex!("0x0977aefc")
    {:ok, "logBytes24", decode_log_bytes24_call(calldata)}
  end

  def decode_call(calldata = <<174, 169, 150, 63>> <> _) do
    _signature = hex!("0xaea9963f")
    {:ok, "logBytes25", decode_log_bytes25_call(calldata)}
  end

  def decode_call(calldata = <<211, 99, 86, 40>> <> _) do
    _signature = hex!("0xd3635628")
    {:ok, "logBytes26", decode_log_bytes26_call(calldata)}
  end

  def decode_call(calldata = <<252, 55, 47, 159>> <> _) do
    _signature = hex!("0xfc372f9f")
    {:ok, "logBytes27", decode_log_bytes27_call(calldata)}
  end

  def decode_call(calldata = <<56, 47, 154, 52>> <> _) do
    _signature = hex!("0x382f9a34")
    {:ok, "logBytes28", decode_log_bytes28_call(calldata)}
  end

  def decode_call(calldata = <<122, 24, 118, 65>> <> _) do
    _signature = hex!("0x7a187641")
    {:ok, "logBytes29", decode_log_bytes29_call(calldata)}
  end

  def decode_call(calldata = <<119, 130, 250, 45>> <> _) do
    _signature = hex!("0x7782fa2d")
    {:ok, "logBytes3", decode_log_bytes3_call(calldata)}
  end

  def decode_call(calldata = <<196, 52, 14, 246>> <> _) do
    _signature = hex!("0xc4340ef6")
    {:ok, "logBytes30", decode_log_bytes30_call(calldata)}
  end

  def decode_call(calldata = <<129, 252, 134, 72>> <> _) do
    _signature = hex!("0x81fc8648")
    {:ok, "logBytes31", decode_log_bytes31_call(calldata)}
  end

  def decode_call(calldata = <<45, 33, 214, 247>> <> _) do
    _signature = hex!("0x2d21d6f7")
    {:ok, "logBytes32", decode_log_bytes32_call(calldata)}
  end

  def decode_call(calldata = <<251, 163, 173, 57>> <> _) do
    _signature = hex!("0xfba3ad39")
    {:ok, "logBytes4", decode_log_bytes4_call(calldata)}
  end

  def decode_call(calldata = <<85, 131, 190, 46>> <> _) do
    _signature = hex!("0x5583be2e")
    {:ok, "logBytes5", decode_log_bytes5_call(calldata)}
  end

  def decode_call(calldata = <<73, 66, 173, 198>> <> _) do
    _signature = hex!("0x4942adc6")
    {:ok, "logBytes6", decode_log_bytes6_call(calldata)}
  end

  def decode_call(calldata = <<69, 116, 175, 171>> <> _) do
    _signature = hex!("0x4574afab")
    {:ok, "logBytes7", decode_log_bytes7_call(calldata)}
  end

  def decode_call(calldata = <<153, 2, 228, 127>> <> _) do
    _signature = hex!("0x9902e47f")
    {:ok, "logBytes8", decode_log_bytes8_call(calldata)}
  end

  def decode_call(calldata = <<80, 161, 56, 223>> <> _) do
    _signature = hex!("0x50a138df")
    {:ok, "logBytes9", decode_log_bytes9_call(calldata)}
  end

  def decode_call(calldata = <<101, 37, 181, 245>> <> _) do
    _signature = hex!("0x6525b5f5")
    {:ok, "logInt", decode_log_int_call(calldata)}
  end

  def decode_call(calldata = <<11, 181, 99, 214>> <> _) do
    _signature = hex!("0x0bb563d6")
    {:ok, "logString", decode_log_string_call(calldata)}
  end

  def decode_call(calldata = <<153, 5, 183, 68>> <> _) do
    _signature = hex!("0x9905b744")
    {:ok, "logUint", decode_log_uint_call(calldata)}
  end

  def decode_call(_) do
    :not_found
  end

  def decode_event(_, _) do
    :not_found
  end

  def decode_error(_) do
    if true do
      :not_found
    else
      {:ok, "Impossible", <<>>}
    end
  end

  def bytecode() do
    hex!("0x")
  end

  def deployed_bytecode() do
    hex!("0x")
  end
end
